/*
 ███▄ ▄███▓▄▄▄      ██▀███  ██▓█    ██  ██████     ▄▄▄      ██ ▄█▄▄▄          ███▄    █ ██▄▄▄█████▓██▀███  ▒█████   ▄████ 
▓██▒▀█▀ ██▒████▄   ▓██ ▒ ██▓██▒██  ▓██▒██    ▒    ▒████▄    ██▄█▒████▄        ██ ▀█   █▓██▓  ██▒ ▓▓██ ▒ ██▒██▒  ██▒██▒ ▀█▒
▓██    ▓██▒██  ▀█▄ ▓██ ░▄█ ▒██▓██  ▒██░ ▓██▄      ▒██  ▀█▄ ▓███▄▒██  ▀█▄     ▓██  ▀█ ██▒██▒ ▓██░ ▒▓██ ░▄█ ▒██░  ██▒██░▄▄▄░
▒██    ▒██░██▄▄▄▄██▒██▀▀█▄ ░██▓▓█  ░██░ ▒   ██▒   ░██▄▄▄▄██▓██ █░██▄▄▄▄██    ▓██▒  ▐▌██░██░ ▓██▓ ░▒██▀▀█▄ ▒██   ██░▓█  ██▓
▒██▒   ░██▒▓█   ▓██░██▓ ▒██░██▒▒█████▓▒██████▒▒    ▓█   ▓██▒██▒ █▓█   ▓██▒   ▒██░   ▓██░██░ ▒██▒ ░░██▓ ▒██░ ████▓▒░▒▓███▀▒
░ ▒░   ░  ░▒▒   ▓▒█░ ▒▓ ░▒▓░▓ ░▒▓▒ ▒ ▒▒ ▒▓▒ ▒ ░    ▒▒   ▓▒█▒ ▒▒ ▓▒▒   ▓▒█░   ░ ▒░   ▒ ▒░▓   ▒ ░░  ░ ▒▓ ░▒▓░ ▒░▒░▒░ ░▒   ▒ 
░  ░      ░ ▒   ▒▒ ░ ░▒ ░ ▒░▒ ░░▒░ ░ ░░ ░▒  ░ ░     ▒   ▒▒ ░ ░▒ ▒░▒   ▒▒ ░   ░ ░░   ░ ▒░▒ ░   ░     ░▒ ░ ▒░ ░ ▒ ▒░  ░   ░ 
░      ░    ░   ▒    ░░   ░ ▒ ░░░░ ░ ░░  ░  ░       ░   ▒  ░ ░░ ░ ░   ▒         ░   ░ ░ ▒ ░ ░       ░░   ░░ ░ ░ ▒ ░ ░   ░ 
       ░        ░  ░  ░     ░    ░          ░           ░  ░  ░       ░  ░            ░ ░            ░        ░ ░       ░ 
                                                                                                                          

*/
#include "Emu/Windows Kits/10/Include/10.0.22621.0/um/ntdllEmu.hpp"
/*
struct _PEB *
__cdecl
NtCurrentPeb(VOID);

*/
void EmuApi::EmuNtCurrentPeb(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    PVOID NtCurrentPebResult = NtCurrentPeb();


    uc_reg_write(uc, UC_X86_REG_RAX, &NtCurrentPebResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCurrentPeb\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupOpenLocalPolicy(
    IN     PLSA_OBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN     ACCESS_MASK             AccessMask        ,
    INOUT  PLSA_LOOKUP_HANDLE      PolicyHandle      );

*/
void EmuApi::EmuLsaLookupOpenLocalPolicy(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLSA_OBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    LSA_OBJECT_ATTRIBUTES stObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &stObjectAttributes, sizeof(stObjectAttributes));
    }

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AccessMask);

    PLSA_LOOKUP_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &PolicyHandle);

    PVOID rlPolicyHandle{};

    if(PolicyHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PolicyHandle, &rlPolicyHandle, sizeof(rlPolicyHandle));
    }


    NTSTATUS LsaLookupOpenLocalPolicyResult = LsaLookupOpenLocalPolicy((PLSA_OBJECT_ATTRIBUTES)&stObjectAttributes,(ACCESS_MASK)AccessMask,(PLSA_LOOKUP_HANDLE)&rlPolicyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupOpenLocalPolicyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &stObjectAttributes, sizeof(stObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AccessMask);
    uc_reg_write(uc, UC_X86_REG_R8, &PolicyHandle);

    if(PolicyHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PolicyHandle, &rlPolicyHandle, sizeof(rlPolicyHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupOpenLocalPolicy\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupClose(
    IN  LSA_LOOKUP_HANDLE  ObjectHandle  );

*/
void EmuApi::EmuLsaLookupClose(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_LOOKUP_HANDLE ObjectHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectHandle);


    NTSTATUS LsaLookupCloseResult = LsaLookupClose((LSA_LOOKUP_HANDLE)ObjectHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupCloseResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupClose\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupTranslateSids(
    IN   LSA_LOOKUP_HANDLE              PolicyHandle       ,
    IN   ULONG                          Count              ,
    IN   PSID *                         Sids               ,
    OUT  PLSA_REFERENCED_DOMAIN_LIST *  ReferencedDomains  ,
    OUT  PLSA_TRANSLATED_NAME *         Names              );

*/
void EmuApi::EmuLsaLookupTranslateSids(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_LOOKUP_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);

    PSID * Sids{};
    uc_reg_read(uc, UC_X86_REG_R8, &Sids);

    PSID * dpSids{};

    if(Sids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    PLSA_REFERENCED_DOMAIN_LIST * ReferencedDomains{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReferencedDomains);

    PLSA_REFERENCED_DOMAIN_LIST * dpReferencedDomains{};

    if(ReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    LSA_REFERENCED_DOMAIN_LIST stReferencedDomains{};

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }

    PLSA_TRANSLATED_NAME * Names{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Names, sizeof(Names));

    PLSA_TRANSLATED_NAME * dpNames{};

    if(Names != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Names, &dpNames, sizeof(dpNames));
    }

    LSA_TRANSLATED_NAME stNames{};

    if(dpNames != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpNames, &stNames, sizeof(stNames));
    }


    NTSTATUS LsaLookupTranslateSidsResult = LsaLookupTranslateSids((LSA_LOOKUP_HANDLE)PolicyHandle,(ULONG)Count,(PSID *)&dpSids,(PLSA_REFERENCED_DOMAIN_LIST *)&stReferencedDomains,(PLSA_TRANSLATED_NAME *)&stNames);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupTranslateSidsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    uc_reg_write(uc, UC_X86_REG_R8, &Sids);

    if(Sids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ReferencedDomains);

    if(ReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Names, sizeof(Names));

    if(Names != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Names, &dpNames, sizeof(dpNames));
    }

    if(dpNames != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpNames, &stNames, sizeof(stNames));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupTranslateSids\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupTranslateNames(
    IN   LSA_LOOKUP_HANDLE              PolicyHandle       ,
    IN   ULONG                          Flags              ,
    IN   ULONG                          Count              ,
    IN   PLSA_UNICODE_STRING            Names              ,
    OUT  PLSA_REFERENCED_DOMAIN_LIST *  ReferencedDomains  ,
    OUT  PLSA_TRANSLATED_SID2 *         Sids               );

*/
void EmuApi::EmuLsaLookupTranslateNames(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_LOOKUP_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Count);

    PLSA_UNICODE_STRING Names{};
    uc_reg_read(uc, UC_X86_REG_R9, &Names);

    std::wstring rlwNames;

    USHORT rlLengthNames;

    USHORT rlMaxLengthNames;
    uc_mem_read(uc, (DWORD_PTR)Names, &rlLengthNames, sizeof(rlLengthNames));
    uc_mem_read(uc, (DWORD_PTR)Names+16, &rlMaxLengthNames, sizeof(rlMaxLengthNames));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Names+64, rlwNames, true, rlLengthNames)) { printf("Error when read Names in LsaLookupTranslateNames"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stNames{};
    stNames.Length = rlLengthNames;
    stNames.MaximumLength = rlMaxLengthNames;
    stNames.Buffer = rlwNames.data();

    PLSA_REFERENCED_DOMAIN_LIST * ReferencedDomains{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReferencedDomains, sizeof(ReferencedDomains));

    PLSA_REFERENCED_DOMAIN_LIST * dpReferencedDomains{};

    if(ReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    LSA_REFERENCED_DOMAIN_LIST stReferencedDomains{};

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }

    PLSA_TRANSLATED_SID2 * Sids{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Sids, sizeof(Sids));

    PLSA_TRANSLATED_SID2 * dpSids{};

    if(Sids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    LSA_TRANSLATED_SID2 stSids{};

    if(dpSids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpSids, &stSids, sizeof(stSids));
    }


    NTSTATUS LsaLookupTranslateNamesResult = LsaLookupTranslateNames((LSA_LOOKUP_HANDLE)PolicyHandle,(ULONG)Flags,(ULONG)Count,(PLSA_UNICODE_STRING)&stNames,(PLSA_REFERENCED_DOMAIN_LIST *)&stReferencedDomains,(PLSA_TRANSLATED_SID2 *)&stSids);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupTranslateNamesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8D, &Count);
    uc_mem_write(uc, (DWORD_PTR)Names, &stNames.Length, sizeof(stNames.Length));
    uc_mem_write(uc, (DWORD_PTR)Names+16, &stNames.MaximumLength, sizeof(stNames.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Names+64, stNames.Buffer, true, stNames.Length)) { printf("Error when read Names in LsaLookupTranslateNames"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReferencedDomains, sizeof(ReferencedDomains));

    if(ReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Sids, sizeof(Sids));

    if(Sids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    if(dpSids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpSids, &stSids, sizeof(stSids));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupTranslateNames\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupGetDomainInfo(
    IN   LSA_LOOKUP_HANDLE             PolicyHandle     ,
    IN   LSA_LOOKUP_DOMAIN_INFO_CLASS  DomainInfoClass  ,
    OUT  PVOID *                       DomainInfo       );

*/
void EmuApi::EmuLsaLookupGetDomainInfo(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_LOOKUP_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    LSA_LOOKUP_DOMAIN_INFO_CLASS DomainInfoClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DomainInfoClass);

    PVOID * DomainInfo{};
    uc_reg_read(uc, UC_X86_REG_R8, &DomainInfo);

    PVOID * dpDomainInfo{};

    if(DomainInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DomainInfo, &dpDomainInfo, sizeof(dpDomainInfo));
    }


    NTSTATUS LsaLookupGetDomainInfoResult = LsaLookupGetDomainInfo((LSA_LOOKUP_HANDLE)PolicyHandle,(LSA_LOOKUP_DOMAIN_INFO_CLASS)DomainInfoClass,(PVOID *)&dpDomainInfo);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupGetDomainInfoResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DomainInfoClass);
    uc_reg_write(uc, UC_X86_REG_R8, &DomainInfo);

    if(DomainInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DomainInfo, &dpDomainInfo, sizeof(dpDomainInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupGetDomainInfo\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupFreeMemory(
    IN  PVOID  Buffer  );

*/
void EmuApi::EmuLsaLookupFreeMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);


    NTSTATUS LsaLookupFreeMemoryResult = LsaLookupFreeMemory((PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupFreeMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupFreeMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaRegisterLogonProcess(
    IN   PLSA_STRING            LogonProcessName  ,
    OUT  PHANDLE                LsaHandle         ,
    OUT  PLSA_OPERATIONAL_MODE  SecurityMode      );

*/
void EmuApi::EmuLsaRegisterLogonProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLSA_STRING LogonProcessName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LogonProcessName);

    std::string rlaLogonProcessName;

    USHORT rlLengthLogonProcessName;

    USHORT rlMaxLengthLogonProcessName;
    uc_mem_read(uc, (DWORD_PTR)LogonProcessName, &rlLengthLogonProcessName, sizeof(rlLengthLogonProcessName));
    uc_mem_read(uc, (DWORD_PTR)LogonProcessName+16, &rlMaxLengthLogonProcessName, sizeof(rlMaxLengthLogonProcessName));
    if(!EmuReadNullTermString(uc, (DWORD_PTR)LogonProcessName+64, rlaLogonProcessName, true, rlLengthLogonProcessName)) { printf("Error when read LogonProcessName in LsaRegisterLogonProcess"); _CrtDbgBreak(); }

    LSA_STRING stLogonProcessName{};
    stLogonProcessName.Length = rlLengthLogonProcessName;
    stLogonProcessName.MaximumLength = rlMaxLengthLogonProcessName;
    stLogonProcessName.Buffer = rlaLogonProcessName.data();

    HANDLE LsaHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LsaHandle);

    HANDLE dpLsaHandle{};

    if(LsaHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LsaHandle, &dpLsaHandle, sizeof(dpLsaHandle));
    }

    PLSA_OPERATIONAL_MODE SecurityMode{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityMode);

    ULONG rlSecurityMode{};

    if(SecurityMode != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityMode, &rlSecurityMode, sizeof(rlSecurityMode));
    }


    NTSTATUS LsaRegisterLogonProcessResult = LsaRegisterLogonProcess((PLSA_STRING)&stLogonProcessName,(PHANDLE)dpLsaHandle,(PLSA_OPERATIONAL_MODE)&rlSecurityMode);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaRegisterLogonProcessResult);
    uc_mem_write(uc, (DWORD_PTR)LogonProcessName, &stLogonProcessName.Length, sizeof(stLogonProcessName.Length));
    uc_mem_write(uc, (DWORD_PTR)LogonProcessName+16, &stLogonProcessName.MaximumLength, sizeof(stLogonProcessName.MaximumLength));
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)LogonProcessName+64, stLogonProcessName.Buffer, true, stLogonProcessName.Length)) { printf("Error when read LogonProcessName in LsaRegisterLogonProcess"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &LsaHandle);

    if(LsaHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LsaHandle, &dpLsaHandle, sizeof(dpLsaHandle));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityMode);

    if(SecurityMode != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityMode, &rlSecurityMode, sizeof(rlSecurityMode));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaRegisterLogonProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLogonUser(
    IN          HANDLE               LsaHandle                        ,
    IN          PLSA_STRING          OriginName                       ,
    IN          SECURITY_LOGON_TYPE  LogonType                        ,
    IN          ULONG                AuthenticationPackage            ,
    IN          PVOID                AuthenticationInformation        ,
    IN          ULONG                AuthenticationInformationLength  ,
    INOPTIONAL  PTOKEN_GROUPS        LocalGroups                      ,
    IN          PTOKEN_SOURCE        SourceContext                    ,
    OUT         PVOID *              ProfileBuffer                    ,
    OUT         PULONG               ProfileBufferLength              ,
    OUT         PLUID                LogonId                          ,
    OUT         PHANDLE              Token                            ,
    OUT         PQUOTA_LIMITS        Quotas                           ,
    OUT         PNTSTATUS            SubStatus                        );

*/
void EmuApi::EmuLsaLogonUser(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LsaHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LsaHandle);

    PLSA_STRING OriginName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &OriginName);

    std::string rlaOriginName;

    USHORT rlLengthOriginName;

    USHORT rlMaxLengthOriginName;
    uc_mem_read(uc, (DWORD_PTR)OriginName, &rlLengthOriginName, sizeof(rlLengthOriginName));
    uc_mem_read(uc, (DWORD_PTR)OriginName+16, &rlMaxLengthOriginName, sizeof(rlMaxLengthOriginName));
    if(!EmuReadNullTermString(uc, (DWORD_PTR)OriginName+64, rlaOriginName, true, rlLengthOriginName)) { printf("Error when read OriginName in LsaLogonUser"); _CrtDbgBreak(); }

    LSA_STRING stOriginName{};
    stOriginName.Length = rlLengthOriginName;
    stOriginName.MaximumLength = rlMaxLengthOriginName;
    stOriginName.Buffer = rlaOriginName.data();

    SECURITY_LOGON_TYPE LogonType{};
    uc_reg_read(uc, UC_X86_REG_R8D, &LogonType);

    ULONG AuthenticationPackage{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AuthenticationPackage);

    PVOID AuthenticationInformation{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AuthenticationInformation, sizeof(AuthenticationInformation));

    ULONG AuthenticationInformationLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AuthenticationInformationLength, sizeof(AuthenticationInformationLength));

    PTOKEN_GROUPS LocalGroups{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &LocalGroups, sizeof(LocalGroups));

    TOKEN_GROUPS stLocalGroups{};

    if(LocalGroups != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LocalGroups, &stLocalGroups, sizeof(stLocalGroups));
    }

    PTOKEN_SOURCE SourceContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &SourceContext, sizeof(SourceContext));

    TOKEN_SOURCE stSourceContext{};

    if(SourceContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceContext, &stSourceContext, sizeof(stSourceContext));
    }

    PVOID * ProfileBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ProfileBuffer, sizeof(ProfileBuffer));

    PVOID * dpProfileBuffer{};

    if(ProfileBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProfileBuffer, &dpProfileBuffer, sizeof(dpProfileBuffer));
    }

    PULONG ProfileBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ProfileBufferLength, sizeof(ProfileBufferLength));

    ULONG rlProfileBufferLength{};

    if(ProfileBufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProfileBufferLength, &rlProfileBufferLength, sizeof(rlProfileBufferLength));
    }

    PLUID LogonId{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &LogonId, sizeof(LogonId));

    LUID stLogonId{};

    if(LogonId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LogonId, &stLogonId, sizeof(stLogonId));
    }

    HANDLE Token{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &Token, sizeof(Token));

    HANDLE dpToken{};

    if(Token != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Token, &dpToken, sizeof(dpToken));
    }

    PQUOTA_LIMITS Quotas{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &Quotas, sizeof(Quotas));

    QUOTA_LIMITS stQuotas{};

    if(Quotas != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Quotas, &stQuotas, sizeof(stQuotas));
    }

    PNTSTATUS SubStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &SubStatus, sizeof(SubStatus));

    NTSTATUS rlSubStatus{};

    if(SubStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SubStatus, &rlSubStatus, sizeof(rlSubStatus));
    }


    NTSTATUS LsaLogonUserResult = LsaLogonUser((HANDLE)LsaHandle,(PLSA_STRING)&stOriginName,(SECURITY_LOGON_TYPE)LogonType,(ULONG)AuthenticationPackage,(PVOID)&AuthenticationInformation,(ULONG)AuthenticationInformationLength,(PTOKEN_GROUPS)&stLocalGroups,(PTOKEN_SOURCE)&stSourceContext,(PVOID *)&dpProfileBuffer,(PULONG)&rlProfileBufferLength,(PLUID)&stLogonId,(PHANDLE)dpToken,(PQUOTA_LIMITS)&stQuotas,(PNTSTATUS)&rlSubStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLogonUserResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LsaHandle);
    uc_mem_write(uc, (DWORD_PTR)OriginName, &stOriginName.Length, sizeof(stOriginName.Length));
    uc_mem_write(uc, (DWORD_PTR)OriginName+16, &stOriginName.MaximumLength, sizeof(stOriginName.MaximumLength));
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)OriginName+64, stOriginName.Buffer, true, stOriginName.Length)) { printf("Error when read OriginName in LsaLogonUser"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &LogonType);
    uc_reg_write(uc, UC_X86_REG_R9D, &AuthenticationPackage);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AuthenticationInformation, sizeof(AuthenticationInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AuthenticationInformationLength, sizeof(AuthenticationInformationLength));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &LocalGroups, sizeof(LocalGroups));

    if(LocalGroups != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LocalGroups, &stLocalGroups, sizeof(stLocalGroups));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &SourceContext, sizeof(SourceContext));

    if(SourceContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceContext, &stSourceContext, sizeof(stSourceContext));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ProfileBuffer, sizeof(ProfileBuffer));

    if(ProfileBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProfileBuffer, &dpProfileBuffer, sizeof(dpProfileBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ProfileBufferLength, sizeof(ProfileBufferLength));

    if(ProfileBufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProfileBufferLength, &rlProfileBufferLength, sizeof(rlProfileBufferLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &LogonId, sizeof(LogonId));

    if(LogonId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LogonId, &stLogonId, sizeof(stLogonId));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+96, &Token, sizeof(Token));

    if(Token != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Token, &dpToken, sizeof(dpToken));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &Quotas, sizeof(Quotas));

    if(Quotas != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Quotas, &stQuotas, sizeof(stQuotas));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+112, &SubStatus, sizeof(SubStatus));

    if(SubStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SubStatus, &rlSubStatus, sizeof(rlSubStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLogonUser\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupAuthenticationPackage(
    IN   HANDLE       LsaHandle              ,
    IN   PLSA_STRING  PackageName            ,
    OUT  PULONG       AuthenticationPackage  );

*/
void EmuApi::EmuLsaLookupAuthenticationPackage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LsaHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LsaHandle);

    PLSA_STRING PackageName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PackageName);

    std::string rlaPackageName;

    USHORT rlLengthPackageName;

    USHORT rlMaxLengthPackageName;
    uc_mem_read(uc, (DWORD_PTR)PackageName, &rlLengthPackageName, sizeof(rlLengthPackageName));
    uc_mem_read(uc, (DWORD_PTR)PackageName+16, &rlMaxLengthPackageName, sizeof(rlMaxLengthPackageName));
    if(!EmuReadNullTermString(uc, (DWORD_PTR)PackageName+64, rlaPackageName, true, rlLengthPackageName)) { printf("Error when read PackageName in LsaLookupAuthenticationPackage"); _CrtDbgBreak(); }

    LSA_STRING stPackageName{};
    stPackageName.Length = rlLengthPackageName;
    stPackageName.MaximumLength = rlMaxLengthPackageName;
    stPackageName.Buffer = rlaPackageName.data();

    PULONG AuthenticationPackage{};
    uc_reg_read(uc, UC_X86_REG_R8, &AuthenticationPackage);

    ULONG rlAuthenticationPackage{};

    if(AuthenticationPackage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AuthenticationPackage, &rlAuthenticationPackage, sizeof(rlAuthenticationPackage));
    }


    NTSTATUS LsaLookupAuthenticationPackageResult = LsaLookupAuthenticationPackage((HANDLE)LsaHandle,(PLSA_STRING)&stPackageName,(PULONG)&rlAuthenticationPackage);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupAuthenticationPackageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LsaHandle);
    uc_mem_write(uc, (DWORD_PTR)PackageName, &stPackageName.Length, sizeof(stPackageName.Length));
    uc_mem_write(uc, (DWORD_PTR)PackageName+16, &stPackageName.MaximumLength, sizeof(stPackageName.MaximumLength));
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)PackageName+64, stPackageName.Buffer, true, stPackageName.Length)) { printf("Error when read PackageName in LsaLookupAuthenticationPackage"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &AuthenticationPackage);

    if(AuthenticationPackage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AuthenticationPackage, &rlAuthenticationPackage, sizeof(rlAuthenticationPackage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupAuthenticationPackage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaFreeReturnBuffer(
    IN  PVOID  Buffer  );

*/
void EmuApi::EmuLsaFreeReturnBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);


    NTSTATUS LsaFreeReturnBufferResult = LsaFreeReturnBuffer((PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaFreeReturnBufferResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaFreeReturnBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaCallAuthenticationPackage(
    IN           HANDLE     LsaHandle              ,
    IN           ULONG      AuthenticationPackage  ,
    IN           PVOID      ProtocolSubmitBuffer   ,
    IN           ULONG      SubmitBufferLength     ,
    OUTOPTIONAL  PVOID *    ProtocolReturnBuffer   ,
    OUTOPTIONAL  PULONG     ReturnBufferLength     ,
    OUTOPTIONAL  PNTSTATUS  ProtocolStatus         );

*/
void EmuApi::EmuLsaCallAuthenticationPackage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LsaHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LsaHandle);

    ULONG AuthenticationPackage{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AuthenticationPackage);

    PVOID ProtocolSubmitBuffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProtocolSubmitBuffer);

    ULONG SubmitBufferLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &SubmitBufferLength);

    PVOID * ProtocolReturnBuffer{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ProtocolReturnBuffer, sizeof(ProtocolReturnBuffer));

    PVOID * dpProtocolReturnBuffer{};

    if(ProtocolReturnBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProtocolReturnBuffer, &dpProtocolReturnBuffer, sizeof(dpProtocolReturnBuffer));
    }

    PULONG ReturnBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnBufferLength, sizeof(ReturnBufferLength));

    ULONG rlReturnBufferLength{};

    if(ReturnBufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnBufferLength, &rlReturnBufferLength, sizeof(rlReturnBufferLength));
    }

    PNTSTATUS ProtocolStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ProtocolStatus, sizeof(ProtocolStatus));

    NTSTATUS rlProtocolStatus{};

    if(ProtocolStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProtocolStatus, &rlProtocolStatus, sizeof(rlProtocolStatus));
    }


    NTSTATUS LsaCallAuthenticationPackageResult = LsaCallAuthenticationPackage((HANDLE)LsaHandle,(ULONG)AuthenticationPackage,(PVOID)&ProtocolSubmitBuffer,(ULONG)SubmitBufferLength,(PVOID *)&dpProtocolReturnBuffer,(PULONG)&rlReturnBufferLength,(PNTSTATUS)&rlProtocolStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaCallAuthenticationPackageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LsaHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &AuthenticationPackage);
    uc_reg_write(uc, UC_X86_REG_R8, &ProtocolSubmitBuffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &SubmitBufferLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ProtocolReturnBuffer, sizeof(ProtocolReturnBuffer));

    if(ProtocolReturnBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProtocolReturnBuffer, &dpProtocolReturnBuffer, sizeof(dpProtocolReturnBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnBufferLength, sizeof(ReturnBufferLength));

    if(ReturnBufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnBufferLength, &rlReturnBufferLength, sizeof(rlReturnBufferLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ProtocolStatus, sizeof(ProtocolStatus));

    if(ProtocolStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProtocolStatus, &rlProtocolStatus, sizeof(rlProtocolStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaCallAuthenticationPackage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaDeregisterLogonProcess(
    IN  HANDLE  LsaHandle  );

*/
void EmuApi::EmuLsaDeregisterLogonProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LsaHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LsaHandle);


    NTSTATUS LsaDeregisterLogonProcessResult = LsaDeregisterLogonProcess((HANDLE)LsaHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaDeregisterLogonProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LsaHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaDeregisterLogonProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaConnectUntrusted(
    OUT  PHANDLE  LsaHandle  );

*/
void EmuApi::EmuLsaConnectUntrusted(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LsaHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LsaHandle);

    HANDLE dpLsaHandle{};

    if(LsaHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LsaHandle, &dpLsaHandle, sizeof(dpLsaHandle));
    }


    NTSTATUS LsaConnectUntrustedResult = LsaConnectUntrusted((PHANDLE)dpLsaHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaConnectUntrustedResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LsaHandle);

    if(LsaHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LsaHandle, &dpLsaHandle, sizeof(dpLsaHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaConnectUntrusted\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaFreeMemory(
    INOPTIONAL  PVOID  Buffer  );

*/
void EmuApi::EmuLsaFreeMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);


    NTSTATUS LsaFreeMemoryResult = LsaFreeMemory((PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaFreeMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaFreeMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaClose(
    IN  LSA_HANDLE  ObjectHandle  );

*/
void EmuApi::EmuLsaClose(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE ObjectHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectHandle);


    NTSTATUS LsaCloseResult = LsaClose((LSA_HANDLE)ObjectHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaCloseResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaClose\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaEnumerateLogonSessions(
    OUT  PULONG   LogonSessionCount  ,
    OUT  PLUID *  LogonSessionList   );

*/
void EmuApi::EmuLsaEnumerateLogonSessions(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG LogonSessionCount{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LogonSessionCount);

    ULONG rlLogonSessionCount{};

    if(LogonSessionCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LogonSessionCount, &rlLogonSessionCount, sizeof(rlLogonSessionCount));
    }

    PLUID * LogonSessionList{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LogonSessionList);

    PLUID * dpLogonSessionList{};

    if(LogonSessionList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LogonSessionList, &dpLogonSessionList, sizeof(dpLogonSessionList));
    }

    LUID stLogonSessionList{};

    if(dpLogonSessionList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpLogonSessionList, &stLogonSessionList, sizeof(stLogonSessionList));
    }


    NTSTATUS LsaEnumerateLogonSessionsResult = LsaEnumerateLogonSessions((PULONG)&rlLogonSessionCount,(PLUID *)&stLogonSessionList);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaEnumerateLogonSessionsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LogonSessionCount);

    if(LogonSessionCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LogonSessionCount, &rlLogonSessionCount, sizeof(rlLogonSessionCount));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &LogonSessionList);

    if(LogonSessionList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LogonSessionList, &dpLogonSessionList, sizeof(dpLogonSessionList));
    }

    if(dpLogonSessionList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpLogonSessionList, &stLogonSessionList, sizeof(stLogonSessionList));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaEnumerateLogonSessions\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaGetLogonSessionData(
    IN   PLUID                           LogonId             ,
    OUT  PSECURITY_LOGON_SESSION_DATA *  ppLogonSessionData  );

*/
void EmuApi::EmuLsaGetLogonSessionData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLUID LogonId{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LogonId);

    LUID stLogonId{};

    if(LogonId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LogonId, &stLogonId, sizeof(stLogonId));
    }

    PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ppLogonSessionData);

    PSECURITY_LOGON_SESSION_DATA * dpppLogonSessionData{};

    if(ppLogonSessionData != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ppLogonSessionData, &dpppLogonSessionData, sizeof(dpppLogonSessionData));
    }

    SECURITY_LOGON_SESSION_DATA stppLogonSessionData{};

    if(dpppLogonSessionData != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpppLogonSessionData, &stppLogonSessionData, sizeof(stppLogonSessionData));
    }


    NTSTATUS LsaGetLogonSessionDataResult = LsaGetLogonSessionData((PLUID)&stLogonId,(PSECURITY_LOGON_SESSION_DATA *)&stppLogonSessionData);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaGetLogonSessionDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LogonId);

    if(LogonId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LogonId, &stLogonId, sizeof(stLogonId));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ppLogonSessionData);

    if(ppLogonSessionData != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ppLogonSessionData, &dpppLogonSessionData, sizeof(dpppLogonSessionData));
    }

    if(dpppLogonSessionData != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpppLogonSessionData, &stppLogonSessionData, sizeof(stppLogonSessionData));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaGetLogonSessionData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaOpenPolicy(
    INOPTIONAL  PLSA_UNICODE_STRING     SystemName        ,
    IN          PLSA_OBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          ACCESS_MASK             DesiredAccess     ,
    OUT         PLSA_HANDLE             PolicyHandle      );

*/
void EmuApi::EmuLsaOpenPolicy(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLSA_UNICODE_STRING SystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SystemName);

    std::wstring rlwSystemName;

    USHORT rlLengthSystemName;

    USHORT rlMaxLengthSystemName;
    uc_mem_read(uc, (DWORD_PTR)SystemName, &rlLengthSystemName, sizeof(rlLengthSystemName));
    uc_mem_read(uc, (DWORD_PTR)SystemName+16, &rlMaxLengthSystemName, sizeof(rlMaxLengthSystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SystemName+64, rlwSystemName, true, rlLengthSystemName)) { printf("Error when read SystemName in LsaOpenPolicy"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stSystemName{};
    stSystemName.Length = rlLengthSystemName;
    stSystemName.MaximumLength = rlMaxLengthSystemName;
    stSystemName.Buffer = rlwSystemName.data();

    PLSA_OBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ObjectAttributes);

    LSA_OBJECT_ATTRIBUTES stObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &stObjectAttributes, sizeof(stObjectAttributes));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DesiredAccess);

    PLSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &PolicyHandle);

    PVOID rlPolicyHandle{};

    if(PolicyHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PolicyHandle, &rlPolicyHandle, sizeof(rlPolicyHandle));
    }


    NTSTATUS LsaOpenPolicyResult = LsaOpenPolicy((PLSA_UNICODE_STRING)&stSystemName,(PLSA_OBJECT_ATTRIBUTES)&stObjectAttributes,(ACCESS_MASK)DesiredAccess,(PLSA_HANDLE)&rlPolicyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaOpenPolicyResult);
    uc_mem_write(uc, (DWORD_PTR)SystemName, &stSystemName.Length, sizeof(stSystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SystemName+16, &stSystemName.MaximumLength, sizeof(stSystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SystemName+64, stSystemName.Buffer, true, stSystemName.Length)) { printf("Error when read SystemName in LsaOpenPolicy"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &stObjectAttributes, sizeof(stObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R9, &PolicyHandle);

    if(PolicyHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PolicyHandle, &rlPolicyHandle, sizeof(rlPolicyHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaOpenPolicy\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaQueryInformationPolicy(
    IN   LSA_HANDLE                PolicyHandle      ,
    IN   POLICY_INFORMATION_CLASS  InformationClass  ,
    OUT  PVOID *                   Buffer            );

*/
void EmuApi::EmuLsaQueryInformationPolicy(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    POLICY_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &InformationClass);

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }


    NTSTATUS LsaQueryInformationPolicyResult = LsaQueryInformationPolicy((LSA_HANDLE)PolicyHandle,(POLICY_INFORMATION_CLASS)InformationClass,(PVOID *)&dpBuffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaQueryInformationPolicyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaQueryInformationPolicy\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaSetInformationPolicy(
    IN  LSA_HANDLE                PolicyHandle      ,
    IN  POLICY_INFORMATION_CLASS  InformationClass  ,
    IN  PVOID                     Buffer            );

*/
void EmuApi::EmuLsaSetInformationPolicy(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    POLICY_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &InformationClass);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);


    NTSTATUS LsaSetInformationPolicyResult = LsaSetInformationPolicy((LSA_HANDLE)PolicyHandle,(POLICY_INFORMATION_CLASS)InformationClass,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaSetInformationPolicyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaSetInformationPolicy\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaQueryDomainInformationPolicy(
    IN   LSA_HANDLE                       PolicyHandle      ,
    IN   POLICY_DOMAIN_INFORMATION_CLASS  InformationClass  ,
    OUT  PVOID *                          Buffer            );

*/
void EmuApi::EmuLsaQueryDomainInformationPolicy(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    POLICY_DOMAIN_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &InformationClass);

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }


    NTSTATUS LsaQueryDomainInformationPolicyResult = LsaQueryDomainInformationPolicy((LSA_HANDLE)PolicyHandle,(POLICY_DOMAIN_INFORMATION_CLASS)InformationClass,(PVOID *)&dpBuffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaQueryDomainInformationPolicyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaQueryDomainInformationPolicy\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaSetDomainInformationPolicy(
    IN          LSA_HANDLE                       PolicyHandle      ,
    IN          POLICY_DOMAIN_INFORMATION_CLASS  InformationClass  ,
    INOPTIONAL  PVOID                            Buffer            );

*/
void EmuApi::EmuLsaSetDomainInformationPolicy(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    POLICY_DOMAIN_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &InformationClass);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);


    NTSTATUS LsaSetDomainInformationPolicyResult = LsaSetDomainInformationPolicy((LSA_HANDLE)PolicyHandle,(POLICY_DOMAIN_INFORMATION_CLASS)InformationClass,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaSetDomainInformationPolicyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaSetDomainInformationPolicy\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaRegisterPolicyChangeNotification(
    IN  POLICY_NOTIFICATION_INFORMATION_CLASS  InformationClass         ,
    IN  HANDLE                                 NotificationEventHandle  );

*/
void EmuApi::EmuLsaRegisterPolicyChangeNotification(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &InformationClass);

    HANDLE NotificationEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NotificationEventHandle);


    NTSTATUS LsaRegisterPolicyChangeNotificationResult = LsaRegisterPolicyChangeNotification((POLICY_NOTIFICATION_INFORMATION_CLASS)InformationClass,(HANDLE)NotificationEventHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaRegisterPolicyChangeNotificationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &NotificationEventHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaRegisterPolicyChangeNotification\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaUnregisterPolicyChangeNotification(
    IN  POLICY_NOTIFICATION_INFORMATION_CLASS  InformationClass         ,
    IN  HANDLE                                 NotificationEventHandle  );

*/
void EmuApi::EmuLsaUnregisterPolicyChangeNotification(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &InformationClass);

    HANDLE NotificationEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NotificationEventHandle);


    NTSTATUS LsaUnregisterPolicyChangeNotificationResult = LsaUnregisterPolicyChangeNotification((POLICY_NOTIFICATION_INFORMATION_CLASS)InformationClass,(HANDLE)NotificationEventHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaUnregisterPolicyChangeNotificationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &NotificationEventHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaUnregisterPolicyChangeNotification\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaEnumerateTrustedDomains(
    IN     LSA_HANDLE               PolicyHandle           ,
    INOUT  PLSA_ENUMERATION_HANDLE  EnumerationContext     ,
    OUT    PVOID *                  Buffer                 ,
    IN     ULONG                    PreferedMaximumLength  ,
    OUT    PULONG                   CountReturned          );

*/
void EmuApi::EmuLsaEnumerateTrustedDomains(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_ENUMERATION_HANDLE EnumerationContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &EnumerationContext);

    ULONG rlEnumerationContext{};

    if(EnumerationContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EnumerationContext, &rlEnumerationContext, sizeof(rlEnumerationContext));
    }

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }

    ULONG PreferedMaximumLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &PreferedMaximumLength);

    PULONG CountReturned{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CountReturned, sizeof(CountReturned));

    ULONG rlCountReturned{};

    if(CountReturned != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CountReturned, &rlCountReturned, sizeof(rlCountReturned));
    }


    NTSTATUS LsaEnumerateTrustedDomainsResult = LsaEnumerateTrustedDomains((LSA_HANDLE)PolicyHandle,(PLSA_ENUMERATION_HANDLE)&rlEnumerationContext,(PVOID *)&dpBuffer,(ULONG)PreferedMaximumLength,(PULONG)&rlCountReturned);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaEnumerateTrustedDomainsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &EnumerationContext);

    if(EnumerationContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EnumerationContext, &rlEnumerationContext, sizeof(rlEnumerationContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &PreferedMaximumLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CountReturned, sizeof(CountReturned));

    if(CountReturned != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CountReturned, &rlCountReturned, sizeof(rlCountReturned));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaEnumerateTrustedDomains\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupNames(
    IN   LSA_HANDLE                     PolicyHandle       ,
    IN   ULONG                          Count              ,
    IN   PLSA_UNICODE_STRING            Names              ,
    OUT  PLSA_REFERENCED_DOMAIN_LIST *  ReferencedDomains  ,
    OUT  PLSA_TRANSLATED_SID *          Sids               );

*/
void EmuApi::EmuLsaLookupNames(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);

    PLSA_UNICODE_STRING Names{};
    uc_reg_read(uc, UC_X86_REG_R8, &Names);

    std::wstring rlwNames;

    USHORT rlLengthNames;

    USHORT rlMaxLengthNames;
    uc_mem_read(uc, (DWORD_PTR)Names, &rlLengthNames, sizeof(rlLengthNames));
    uc_mem_read(uc, (DWORD_PTR)Names+16, &rlMaxLengthNames, sizeof(rlMaxLengthNames));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Names+64, rlwNames, true, rlLengthNames)) { printf("Error when read Names in LsaLookupNames"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stNames{};
    stNames.Length = rlLengthNames;
    stNames.MaximumLength = rlMaxLengthNames;
    stNames.Buffer = rlwNames.data();

    PLSA_REFERENCED_DOMAIN_LIST * ReferencedDomains{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReferencedDomains);

    PLSA_REFERENCED_DOMAIN_LIST * dpReferencedDomains{};

    if(ReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    LSA_REFERENCED_DOMAIN_LIST stReferencedDomains{};

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }

    PLSA_TRANSLATED_SID * Sids{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Sids, sizeof(Sids));

    PLSA_TRANSLATED_SID * dpSids{};

    if(Sids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    LSA_TRANSLATED_SID stSids{};

    if(dpSids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpSids, &stSids, sizeof(stSids));
    }


    NTSTATUS LsaLookupNamesResult = LsaLookupNames((LSA_HANDLE)PolicyHandle,(ULONG)Count,(PLSA_UNICODE_STRING)&stNames,(PLSA_REFERENCED_DOMAIN_LIST *)&stReferencedDomains,(PLSA_TRANSLATED_SID *)&stSids);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupNamesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    uc_mem_write(uc, (DWORD_PTR)Names, &stNames.Length, sizeof(stNames.Length));
    uc_mem_write(uc, (DWORD_PTR)Names+16, &stNames.MaximumLength, sizeof(stNames.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Names+64, stNames.Buffer, true, stNames.Length)) { printf("Error when read Names in LsaLookupNames"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &ReferencedDomains);

    if(ReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Sids, sizeof(Sids));

    if(Sids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    if(dpSids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpSids, &stSids, sizeof(stSids));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupNames\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupNames2(
    IN   LSA_HANDLE                     PolicyHandle       ,
    IN   ULONG                          Flags              ,
    IN   ULONG                          Count              ,
    IN   PLSA_UNICODE_STRING            Names              ,
    OUT  PLSA_REFERENCED_DOMAIN_LIST *  ReferencedDomains  ,
    OUT  PLSA_TRANSLATED_SID2 *         Sids               );

*/
void EmuApi::EmuLsaLookupNames2(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Count);

    PLSA_UNICODE_STRING Names{};
    uc_reg_read(uc, UC_X86_REG_R9, &Names);

    std::wstring rlwNames;

    USHORT rlLengthNames;

    USHORT rlMaxLengthNames;
    uc_mem_read(uc, (DWORD_PTR)Names, &rlLengthNames, sizeof(rlLengthNames));
    uc_mem_read(uc, (DWORD_PTR)Names+16, &rlMaxLengthNames, sizeof(rlMaxLengthNames));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Names+64, rlwNames, true, rlLengthNames)) { printf("Error when read Names in LsaLookupNames2"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stNames{};
    stNames.Length = rlLengthNames;
    stNames.MaximumLength = rlMaxLengthNames;
    stNames.Buffer = rlwNames.data();

    PLSA_REFERENCED_DOMAIN_LIST * ReferencedDomains{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReferencedDomains, sizeof(ReferencedDomains));

    PLSA_REFERENCED_DOMAIN_LIST * dpReferencedDomains{};

    if(ReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    LSA_REFERENCED_DOMAIN_LIST stReferencedDomains{};

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }

    PLSA_TRANSLATED_SID2 * Sids{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Sids, sizeof(Sids));

    PLSA_TRANSLATED_SID2 * dpSids{};

    if(Sids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    LSA_TRANSLATED_SID2 stSids{};

    if(dpSids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpSids, &stSids, sizeof(stSids));
    }


    NTSTATUS LsaLookupNames2Result = LsaLookupNames2((LSA_HANDLE)PolicyHandle,(ULONG)Flags,(ULONG)Count,(PLSA_UNICODE_STRING)&stNames,(PLSA_REFERENCED_DOMAIN_LIST *)&stReferencedDomains,(PLSA_TRANSLATED_SID2 *)&stSids);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupNames2Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8D, &Count);
    uc_mem_write(uc, (DWORD_PTR)Names, &stNames.Length, sizeof(stNames.Length));
    uc_mem_write(uc, (DWORD_PTR)Names+16, &stNames.MaximumLength, sizeof(stNames.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Names+64, stNames.Buffer, true, stNames.Length)) { printf("Error when read Names in LsaLookupNames2"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReferencedDomains, sizeof(ReferencedDomains));

    if(ReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Sids, sizeof(Sids));

    if(Sids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    if(dpSids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpSids, &stSids, sizeof(stSids));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupNames2\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaLookupSids(
    IN   LSA_HANDLE                     PolicyHandle       ,
    IN   ULONG                          Count              ,
    IN   PSID *                         Sids               ,
    OUT  PLSA_REFERENCED_DOMAIN_LIST *  ReferencedDomains  ,
    OUT  PLSA_TRANSLATED_NAME *         Names              );

*/
void EmuApi::EmuLsaLookupSids(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);

    PSID * Sids{};
    uc_reg_read(uc, UC_X86_REG_R8, &Sids);

    PSID * dpSids{};

    if(Sids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }

    PLSA_REFERENCED_DOMAIN_LIST * ReferencedDomains{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReferencedDomains);

    PLSA_REFERENCED_DOMAIN_LIST * dpReferencedDomains{};

    if(ReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    LSA_REFERENCED_DOMAIN_LIST stReferencedDomains{};

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }

    PLSA_TRANSLATED_NAME * Names{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Names, sizeof(Names));

    PLSA_TRANSLATED_NAME * dpNames{};

    if(Names != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Names, &dpNames, sizeof(dpNames));
    }

    LSA_TRANSLATED_NAME stNames{};

    if(dpNames != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpNames, &stNames, sizeof(stNames));
    }


    NTSTATUS LsaLookupSidsResult = LsaLookupSids((LSA_HANDLE)PolicyHandle,(ULONG)Count,(PSID *)&dpSids,(PLSA_REFERENCED_DOMAIN_LIST *)&stReferencedDomains,(PLSA_TRANSLATED_NAME *)&stNames);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaLookupSidsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    uc_reg_write(uc, UC_X86_REG_R8, &Sids);

    if(Sids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sids, &dpSids, sizeof(dpSids));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ReferencedDomains);

    if(ReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReferencedDomains, &dpReferencedDomains, sizeof(dpReferencedDomains));
    }

    if(dpReferencedDomains != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpReferencedDomains, &stReferencedDomains, sizeof(stReferencedDomains));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Names, sizeof(Names));

    if(Names != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Names, &dpNames, sizeof(dpNames));
    }

    if(dpNames != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpNames, &stNames, sizeof(stNames));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaLookupSids\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaEnumerateAccountsWithUserRight(
    IN          LSA_HANDLE           PolicyHandle   ,
    INOPTIONAL  PLSA_UNICODE_STRING  UserRight      ,
    OUT         PVOID *              Buffer         ,
    OUT         PULONG               CountReturned  );

*/
void EmuApi::EmuLsaEnumerateAccountsWithUserRight(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING UserRight{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UserRight);

    std::wstring rlwUserRight;

    USHORT rlLengthUserRight;

    USHORT rlMaxLengthUserRight;
    uc_mem_read(uc, (DWORD_PTR)UserRight, &rlLengthUserRight, sizeof(rlLengthUserRight));
    uc_mem_read(uc, (DWORD_PTR)UserRight+16, &rlMaxLengthUserRight, sizeof(rlMaxLengthUserRight));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UserRight+64, rlwUserRight, true, rlLengthUserRight)) { printf("Error when read UserRight in LsaEnumerateAccountsWithUserRight"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stUserRight{};
    stUserRight.Length = rlLengthUserRight;
    stUserRight.MaximumLength = rlMaxLengthUserRight;
    stUserRight.Buffer = rlwUserRight.data();

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }

    PULONG CountReturned{};
    uc_reg_read(uc, UC_X86_REG_R9, &CountReturned);

    ULONG rlCountReturned{};

    if(CountReturned != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CountReturned, &rlCountReturned, sizeof(rlCountReturned));
    }


    NTSTATUS LsaEnumerateAccountsWithUserRightResult = LsaEnumerateAccountsWithUserRight((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stUserRight,(PVOID *)&dpBuffer,(PULONG)&rlCountReturned);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaEnumerateAccountsWithUserRightResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)UserRight, &stUserRight.Length, sizeof(stUserRight.Length));
    uc_mem_write(uc, (DWORD_PTR)UserRight+16, &stUserRight.MaximumLength, sizeof(stUserRight.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UserRight+64, stUserRight.Buffer, true, stUserRight.Length)) { printf("Error when read UserRight in LsaEnumerateAccountsWithUserRight"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &CountReturned);

    if(CountReturned != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CountReturned, &rlCountReturned, sizeof(rlCountReturned));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaEnumerateAccountsWithUserRight\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaEnumerateAccountRights(
    IN   LSA_HANDLE             PolicyHandle   ,
    IN   PSID                   AccountSid     ,
    OUT  PLSA_UNICODE_STRING *  UserRights     ,
    OUT  PULONG                 CountOfRights  );

*/
void EmuApi::EmuLsaEnumerateAccountRights(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PSID AccountSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AccountSid);

    PLSA_UNICODE_STRING * UserRights{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserRights);

    PLSA_UNICODE_STRING * dpUserRights{};

    if(UserRights != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserRights, &dpUserRights, sizeof(dpUserRights));
    }

    std::wstring rlwUserRights;

    USHORT rlLengthUserRights;

    USHORT rlMaxLengthUserRights;
    uc_mem_read(uc, (DWORD_PTR)UserRights, &rlLengthUserRights, sizeof(rlLengthUserRights));
    uc_mem_read(uc, (DWORD_PTR)UserRights+16, &rlMaxLengthUserRights, sizeof(rlMaxLengthUserRights));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UserRights+64, rlwUserRights, true, rlLengthUserRights)) { printf("Error when read UserRights in LsaEnumerateAccountRights"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stUserRights{};
    stUserRights.Length = rlLengthUserRights;
    stUserRights.MaximumLength = rlMaxLengthUserRights;
    stUserRights.Buffer = rlwUserRights.data();

    PULONG CountOfRights{};
    uc_reg_read(uc, UC_X86_REG_R9, &CountOfRights);

    ULONG rlCountOfRights{};

    if(CountOfRights != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CountOfRights, &rlCountOfRights, sizeof(rlCountOfRights));
    }


    NTSTATUS LsaEnumerateAccountRightsResult = LsaEnumerateAccountRights((LSA_HANDLE)PolicyHandle,(PSID)&AccountSid,(PLSA_UNICODE_STRING *)&stUserRights,(PULONG)&rlCountOfRights);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaEnumerateAccountRightsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &AccountSid);
    uc_mem_write(uc, (DWORD_PTR)UserRights, &stUserRights.Length, sizeof(stUserRights.Length));
    uc_mem_write(uc, (DWORD_PTR)UserRights+16, &stUserRights.MaximumLength, sizeof(stUserRights.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UserRights+64, stUserRights.Buffer, true, stUserRights.Length)) { printf("Error when read UserRights in LsaEnumerateAccountRights"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &CountOfRights);

    if(CountOfRights != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CountOfRights, &rlCountOfRights, sizeof(rlCountOfRights));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaEnumerateAccountRights\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaAddAccountRights(
    IN  LSA_HANDLE           PolicyHandle   ,
    IN  PSID                 AccountSid     ,
    IN  PLSA_UNICODE_STRING  UserRights     ,
    IN  ULONG                CountOfRights  );

*/
void EmuApi::EmuLsaAddAccountRights(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PSID AccountSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AccountSid);

    PLSA_UNICODE_STRING UserRights{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserRights);

    std::wstring rlwUserRights;

    USHORT rlLengthUserRights;

    USHORT rlMaxLengthUserRights;
    uc_mem_read(uc, (DWORD_PTR)UserRights, &rlLengthUserRights, sizeof(rlLengthUserRights));
    uc_mem_read(uc, (DWORD_PTR)UserRights+16, &rlMaxLengthUserRights, sizeof(rlMaxLengthUserRights));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UserRights+64, rlwUserRights, true, rlLengthUserRights)) { printf("Error when read UserRights in LsaAddAccountRights"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stUserRights{};
    stUserRights.Length = rlLengthUserRights;
    stUserRights.MaximumLength = rlMaxLengthUserRights;
    stUserRights.Buffer = rlwUserRights.data();

    ULONG CountOfRights{};
    uc_reg_read(uc, UC_X86_REG_R9D, &CountOfRights);


    NTSTATUS LsaAddAccountRightsResult = LsaAddAccountRights((LSA_HANDLE)PolicyHandle,(PSID)&AccountSid,(PLSA_UNICODE_STRING)&stUserRights,(ULONG)CountOfRights);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaAddAccountRightsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &AccountSid);
    uc_mem_write(uc, (DWORD_PTR)UserRights, &stUserRights.Length, sizeof(stUserRights.Length));
    uc_mem_write(uc, (DWORD_PTR)UserRights+16, &stUserRights.MaximumLength, sizeof(stUserRights.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UserRights+64, stUserRights.Buffer, true, stUserRights.Length)) { printf("Error when read UserRights in LsaAddAccountRights"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9D, &CountOfRights);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaAddAccountRights\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaOpenTrustedDomainByName(
    IN   LSA_HANDLE           PolicyHandle         ,
    IN   PLSA_UNICODE_STRING  TrustedDomainName    ,
    IN   ACCESS_MASK          DesiredAccess        ,
    OUT  PLSA_HANDLE          TrustedDomainHandle  );

*/
void EmuApi::EmuLsaOpenTrustedDomainByName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING TrustedDomainName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainName);

    std::wstring rlwTrustedDomainName;

    USHORT rlLengthTrustedDomainName;

    USHORT rlMaxLengthTrustedDomainName;
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName, &rlLengthTrustedDomainName, sizeof(rlLengthTrustedDomainName));
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName+16, &rlMaxLengthTrustedDomainName, sizeof(rlMaxLengthTrustedDomainName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, rlwTrustedDomainName, true, rlLengthTrustedDomainName)) { printf("Error when read TrustedDomainName in LsaOpenTrustedDomainByName"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stTrustedDomainName{};
    stTrustedDomainName.Length = rlLengthTrustedDomainName;
    stTrustedDomainName.MaximumLength = rlMaxLengthTrustedDomainName;
    stTrustedDomainName.Buffer = rlwTrustedDomainName.data();

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DesiredAccess);

    PLSA_HANDLE TrustedDomainHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TrustedDomainHandle);

    PVOID rlTrustedDomainHandle{};

    if(TrustedDomainHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TrustedDomainHandle, &rlTrustedDomainHandle, sizeof(rlTrustedDomainHandle));
    }


    NTSTATUS LsaOpenTrustedDomainByNameResult = LsaOpenTrustedDomainByName((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stTrustedDomainName,(ACCESS_MASK)DesiredAccess,(PLSA_HANDLE)&rlTrustedDomainHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaOpenTrustedDomainByNameResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName, &stTrustedDomainName.Length, sizeof(stTrustedDomainName.Length));
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName+16, &stTrustedDomainName.MaximumLength, sizeof(stTrustedDomainName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, stTrustedDomainName.Buffer, true, stTrustedDomainName.Length)) { printf("Error when read TrustedDomainName in LsaOpenTrustedDomainByName"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R9, &TrustedDomainHandle);

    if(TrustedDomainHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TrustedDomainHandle, &rlTrustedDomainHandle, sizeof(rlTrustedDomainHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaOpenTrustedDomainByName\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaQueryTrustedDomainInfo(
    IN   LSA_HANDLE                 PolicyHandle      ,
    IN   PSID                       TrustedDomainSid  ,
    IN   TRUSTED_INFORMATION_CLASS  InformationClass  ,
    OUT  PVOID *                    Buffer            );

*/
void EmuApi::EmuLsaQueryTrustedDomainInfo(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PSID TrustedDomainSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainSid);

    TRUSTED_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InformationClass);

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }


    NTSTATUS LsaQueryTrustedDomainInfoResult = LsaQueryTrustedDomainInfo((LSA_HANDLE)PolicyHandle,(PSID)&TrustedDomainSid,(TRUSTED_INFORMATION_CLASS)InformationClass,(PVOID *)&dpBuffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaQueryTrustedDomainInfoResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &TrustedDomainSid);
    uc_reg_write(uc, UC_X86_REG_R8D, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaQueryTrustedDomainInfo\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaSetTrustedDomainInformation(
    IN  LSA_HANDLE                 PolicyHandle      ,
    IN  PSID                       TrustedDomainSid  ,
    IN  TRUSTED_INFORMATION_CLASS  InformationClass  ,
    IN  PVOID                      Buffer            );

*/
void EmuApi::EmuLsaSetTrustedDomainInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PSID TrustedDomainSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainSid);

    TRUSTED_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InformationClass);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);


    NTSTATUS LsaSetTrustedDomainInformationResult = LsaSetTrustedDomainInformation((LSA_HANDLE)PolicyHandle,(PSID)&TrustedDomainSid,(TRUSTED_INFORMATION_CLASS)InformationClass,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaSetTrustedDomainInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &TrustedDomainSid);
    uc_reg_write(uc, UC_X86_REG_R8D, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaSetTrustedDomainInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaDeleteTrustedDomain(
    IN  LSA_HANDLE  PolicyHandle      ,
    IN  PSID        TrustedDomainSid  );

*/
void EmuApi::EmuLsaDeleteTrustedDomain(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PSID TrustedDomainSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainSid);


    NTSTATUS LsaDeleteTrustedDomainResult = LsaDeleteTrustedDomain((LSA_HANDLE)PolicyHandle,(PSID)&TrustedDomainSid);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaDeleteTrustedDomainResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &TrustedDomainSid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaDeleteTrustedDomain\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaQueryTrustedDomainInfoByName(
    IN   LSA_HANDLE                 PolicyHandle       ,
    IN   PLSA_UNICODE_STRING        TrustedDomainName  ,
    IN   TRUSTED_INFORMATION_CLASS  InformationClass   ,
    OUT  PVOID *                    Buffer             );

*/
void EmuApi::EmuLsaQueryTrustedDomainInfoByName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING TrustedDomainName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainName);

    std::wstring rlwTrustedDomainName;

    USHORT rlLengthTrustedDomainName;

    USHORT rlMaxLengthTrustedDomainName;
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName, &rlLengthTrustedDomainName, sizeof(rlLengthTrustedDomainName));
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName+16, &rlMaxLengthTrustedDomainName, sizeof(rlMaxLengthTrustedDomainName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, rlwTrustedDomainName, true, rlLengthTrustedDomainName)) { printf("Error when read TrustedDomainName in LsaQueryTrustedDomainInfoByName"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stTrustedDomainName{};
    stTrustedDomainName.Length = rlLengthTrustedDomainName;
    stTrustedDomainName.MaximumLength = rlMaxLengthTrustedDomainName;
    stTrustedDomainName.Buffer = rlwTrustedDomainName.data();

    TRUSTED_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InformationClass);

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }


    NTSTATUS LsaQueryTrustedDomainInfoByNameResult = LsaQueryTrustedDomainInfoByName((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stTrustedDomainName,(TRUSTED_INFORMATION_CLASS)InformationClass,(PVOID *)&dpBuffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaQueryTrustedDomainInfoByNameResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName, &stTrustedDomainName.Length, sizeof(stTrustedDomainName.Length));
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName+16, &stTrustedDomainName.MaximumLength, sizeof(stTrustedDomainName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, stTrustedDomainName.Buffer, true, stTrustedDomainName.Length)) { printf("Error when read TrustedDomainName in LsaQueryTrustedDomainInfoByName"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaQueryTrustedDomainInfoByName\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaSetTrustedDomainInfoByName(
    IN  LSA_HANDLE                 PolicyHandle       ,
    IN  PLSA_UNICODE_STRING        TrustedDomainName  ,
    IN  TRUSTED_INFORMATION_CLASS  InformationClass   ,
    IN  PVOID                      Buffer             );

*/
void EmuApi::EmuLsaSetTrustedDomainInfoByName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING TrustedDomainName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainName);

    std::wstring rlwTrustedDomainName;

    USHORT rlLengthTrustedDomainName;

    USHORT rlMaxLengthTrustedDomainName;
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName, &rlLengthTrustedDomainName, sizeof(rlLengthTrustedDomainName));
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName+16, &rlMaxLengthTrustedDomainName, sizeof(rlMaxLengthTrustedDomainName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, rlwTrustedDomainName, true, rlLengthTrustedDomainName)) { printf("Error when read TrustedDomainName in LsaSetTrustedDomainInfoByName"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stTrustedDomainName{};
    stTrustedDomainName.Length = rlLengthTrustedDomainName;
    stTrustedDomainName.MaximumLength = rlMaxLengthTrustedDomainName;
    stTrustedDomainName.Buffer = rlwTrustedDomainName.data();

    TRUSTED_INFORMATION_CLASS InformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InformationClass);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);


    NTSTATUS LsaSetTrustedDomainInfoByNameResult = LsaSetTrustedDomainInfoByName((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stTrustedDomainName,(TRUSTED_INFORMATION_CLASS)InformationClass,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaSetTrustedDomainInfoByNameResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName, &stTrustedDomainName.Length, sizeof(stTrustedDomainName.Length));
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName+16, &stTrustedDomainName.MaximumLength, sizeof(stTrustedDomainName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, stTrustedDomainName.Buffer, true, stTrustedDomainName.Length)) { printf("Error when read TrustedDomainName in LsaSetTrustedDomainInfoByName"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaSetTrustedDomainInfoByName\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaEnumerateTrustedDomainsEx(
    IN     LSA_HANDLE               PolicyHandle           ,
    INOUT  PLSA_ENUMERATION_HANDLE  EnumerationContext     ,
    OUT    PVOID *                  Buffer                 ,
    IN     ULONG                    PreferedMaximumLength  ,
    OUT    PULONG                   CountReturned          );

*/
void EmuApi::EmuLsaEnumerateTrustedDomainsEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_ENUMERATION_HANDLE EnumerationContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &EnumerationContext);

    ULONG rlEnumerationContext{};

    if(EnumerationContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EnumerationContext, &rlEnumerationContext, sizeof(rlEnumerationContext));
    }

    PVOID * Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PVOID * dpBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }

    ULONG PreferedMaximumLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &PreferedMaximumLength);

    PULONG CountReturned{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CountReturned, sizeof(CountReturned));

    ULONG rlCountReturned{};

    if(CountReturned != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CountReturned, &rlCountReturned, sizeof(rlCountReturned));
    }


    NTSTATUS LsaEnumerateTrustedDomainsExResult = LsaEnumerateTrustedDomainsEx((LSA_HANDLE)PolicyHandle,(PLSA_ENUMERATION_HANDLE)&rlEnumerationContext,(PVOID *)&dpBuffer,(ULONG)PreferedMaximumLength,(PULONG)&rlCountReturned);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaEnumerateTrustedDomainsExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &EnumerationContext);

    if(EnumerationContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EnumerationContext, &rlEnumerationContext, sizeof(rlEnumerationContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &dpBuffer, sizeof(dpBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &PreferedMaximumLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CountReturned, sizeof(CountReturned));

    if(CountReturned != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CountReturned, &rlCountReturned, sizeof(rlCountReturned));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaEnumerateTrustedDomainsEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaCreateTrustedDomainEx(
    IN   LSA_HANDLE                        PolicyHandle               ,
    IN   PTRUSTED_DOMAIN_INFORMATION_EX    TrustedDomainInformation   ,
    IN   PTRUSTED_DOMAIN_AUTH_INFORMATION  AuthenticationInformation  ,
    IN   ACCESS_MASK                       DesiredAccess              ,
    OUT  PLSA_HANDLE                       TrustedDomainHandle        );

*/
void EmuApi::EmuLsaCreateTrustedDomainEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainInformation);

    TRUSTED_DOMAIN_INFORMATION_EX stTrustedDomainInformation{};

    if(TrustedDomainInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TrustedDomainInformation, &stTrustedDomainInformation, sizeof(stTrustedDomainInformation));
    }

    PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &AuthenticationInformation);

    TRUSTED_DOMAIN_AUTH_INFORMATION stAuthenticationInformation{};

    if(AuthenticationInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AuthenticationInformation, &stAuthenticationInformation, sizeof(stAuthenticationInformation));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    PLSA_HANDLE TrustedDomainHandle{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TrustedDomainHandle, sizeof(TrustedDomainHandle));

    PVOID rlTrustedDomainHandle{};

    if(TrustedDomainHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TrustedDomainHandle, &rlTrustedDomainHandle, sizeof(rlTrustedDomainHandle));
    }


    NTSTATUS LsaCreateTrustedDomainExResult = LsaCreateTrustedDomainEx((LSA_HANDLE)PolicyHandle,(PTRUSTED_DOMAIN_INFORMATION_EX)&stTrustedDomainInformation,(PTRUSTED_DOMAIN_AUTH_INFORMATION)&stAuthenticationInformation,(ACCESS_MASK)DesiredAccess,(PLSA_HANDLE)&rlTrustedDomainHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaCreateTrustedDomainExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &TrustedDomainInformation);

    if(TrustedDomainInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TrustedDomainInformation, &stTrustedDomainInformation, sizeof(stTrustedDomainInformation));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &AuthenticationInformation);

    if(AuthenticationInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AuthenticationInformation, &stAuthenticationInformation, sizeof(stAuthenticationInformation));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TrustedDomainHandle, sizeof(TrustedDomainHandle));

    if(TrustedDomainHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TrustedDomainHandle, &rlTrustedDomainHandle, sizeof(rlTrustedDomainHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaCreateTrustedDomainEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaQueryForestTrustInformation(
    IN   LSA_HANDLE                       PolicyHandle       ,
    IN   PLSA_UNICODE_STRING              TrustedDomainName  ,
    OUT  PLSA_FOREST_TRUST_INFORMATION *  ForestTrustInfo    );

*/
void EmuApi::EmuLsaQueryForestTrustInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING TrustedDomainName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainName);

    std::wstring rlwTrustedDomainName;

    USHORT rlLengthTrustedDomainName;

    USHORT rlMaxLengthTrustedDomainName;
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName, &rlLengthTrustedDomainName, sizeof(rlLengthTrustedDomainName));
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName+16, &rlMaxLengthTrustedDomainName, sizeof(rlMaxLengthTrustedDomainName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, rlwTrustedDomainName, true, rlLengthTrustedDomainName)) { printf("Error when read TrustedDomainName in LsaQueryForestTrustInformation"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stTrustedDomainName{};
    stTrustedDomainName.Length = rlLengthTrustedDomainName;
    stTrustedDomainName.MaximumLength = rlMaxLengthTrustedDomainName;
    stTrustedDomainName.Buffer = rlwTrustedDomainName.data();

    PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo{};
    uc_reg_read(uc, UC_X86_REG_R8, &ForestTrustInfo);

    PLSA_FOREST_TRUST_INFORMATION * dpForestTrustInfo{};

    if(ForestTrustInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ForestTrustInfo, &dpForestTrustInfo, sizeof(dpForestTrustInfo));
    }

    LSA_FOREST_TRUST_INFORMATION stForestTrustInfo{};

    if(dpForestTrustInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpForestTrustInfo, &stForestTrustInfo, sizeof(stForestTrustInfo));
    }


    NTSTATUS LsaQueryForestTrustInformationResult = LsaQueryForestTrustInformation((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stTrustedDomainName,(PLSA_FOREST_TRUST_INFORMATION *)&stForestTrustInfo);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaQueryForestTrustInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName, &stTrustedDomainName.Length, sizeof(stTrustedDomainName.Length));
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName+16, &stTrustedDomainName.MaximumLength, sizeof(stTrustedDomainName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, stTrustedDomainName.Buffer, true, stTrustedDomainName.Length)) { printf("Error when read TrustedDomainName in LsaQueryForestTrustInformation"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &ForestTrustInfo);

    if(ForestTrustInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ForestTrustInfo, &dpForestTrustInfo, sizeof(dpForestTrustInfo));
    }

    if(dpForestTrustInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpForestTrustInfo, &stForestTrustInfo, sizeof(stForestTrustInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaQueryForestTrustInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaSetForestTrustInformation(
    IN   LSA_HANDLE                                 PolicyHandle       ,
    IN   PLSA_UNICODE_STRING                        TrustedDomainName  ,
    IN   PLSA_FOREST_TRUST_INFORMATION              ForestTrustInfo    ,
    IN   BOOLEAN                                    CheckOnly          ,
    OUT  PLSA_FOREST_TRUST_COLLISION_INFORMATION *  CollisionInfo      );

*/
void EmuApi::EmuLsaSetForestTrustInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING TrustedDomainName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TrustedDomainName);

    std::wstring rlwTrustedDomainName;

    USHORT rlLengthTrustedDomainName;

    USHORT rlMaxLengthTrustedDomainName;
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName, &rlLengthTrustedDomainName, sizeof(rlLengthTrustedDomainName));
    uc_mem_read(uc, (DWORD_PTR)TrustedDomainName+16, &rlMaxLengthTrustedDomainName, sizeof(rlMaxLengthTrustedDomainName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, rlwTrustedDomainName, true, rlLengthTrustedDomainName)) { printf("Error when read TrustedDomainName in LsaSetForestTrustInformation"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stTrustedDomainName{};
    stTrustedDomainName.Length = rlLengthTrustedDomainName;
    stTrustedDomainName.MaximumLength = rlMaxLengthTrustedDomainName;
    stTrustedDomainName.Buffer = rlwTrustedDomainName.data();

    PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo{};
    uc_reg_read(uc, UC_X86_REG_R8, &ForestTrustInfo);

    LSA_FOREST_TRUST_INFORMATION stForestTrustInfo{};

    if(ForestTrustInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ForestTrustInfo, &stForestTrustInfo, sizeof(stForestTrustInfo));
    }

    BOOLEAN CheckOnly{};
    uc_reg_read(uc, UC_X86_REG_R9B, &CheckOnly);

    PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CollisionInfo, sizeof(CollisionInfo));

    PLSA_FOREST_TRUST_COLLISION_INFORMATION * dpCollisionInfo{};

    if(CollisionInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CollisionInfo, &dpCollisionInfo, sizeof(dpCollisionInfo));
    }

    LSA_FOREST_TRUST_COLLISION_INFORMATION stCollisionInfo{};

    if(dpCollisionInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpCollisionInfo, &stCollisionInfo, sizeof(stCollisionInfo));
    }


    NTSTATUS LsaSetForestTrustInformationResult = LsaSetForestTrustInformation((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stTrustedDomainName,(PLSA_FOREST_TRUST_INFORMATION)&stForestTrustInfo,(BOOLEAN)CheckOnly,(PLSA_FOREST_TRUST_COLLISION_INFORMATION *)&stCollisionInfo);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaSetForestTrustInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName, &stTrustedDomainName.Length, sizeof(stTrustedDomainName.Length));
    uc_mem_write(uc, (DWORD_PTR)TrustedDomainName+16, &stTrustedDomainName.MaximumLength, sizeof(stTrustedDomainName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TrustedDomainName+64, stTrustedDomainName.Buffer, true, stTrustedDomainName.Length)) { printf("Error when read TrustedDomainName in LsaSetForestTrustInformation"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &ForestTrustInfo);

    if(ForestTrustInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ForestTrustInfo, &stForestTrustInfo, sizeof(stForestTrustInfo));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &CheckOnly);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CollisionInfo, sizeof(CollisionInfo));

    if(CollisionInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CollisionInfo, &dpCollisionInfo, sizeof(dpCollisionInfo));
    }

    if(dpCollisionInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpCollisionInfo, &stCollisionInfo, sizeof(stCollisionInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaSetForestTrustInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaStorePrivateData(
    IN          LSA_HANDLE           PolicyHandle  ,
    IN          PLSA_UNICODE_STRING  KeyName       ,
    INOPTIONAL  PLSA_UNICODE_STRING  PrivateData   );

*/
void EmuApi::EmuLsaStorePrivateData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING KeyName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyName);

    std::wstring rlwKeyName;

    USHORT rlLengthKeyName;

    USHORT rlMaxLengthKeyName;
    uc_mem_read(uc, (DWORD_PTR)KeyName, &rlLengthKeyName, sizeof(rlLengthKeyName));
    uc_mem_read(uc, (DWORD_PTR)KeyName+16, &rlMaxLengthKeyName, sizeof(rlMaxLengthKeyName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)KeyName+64, rlwKeyName, true, rlLengthKeyName)) { printf("Error when read KeyName in LsaStorePrivateData"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stKeyName{};
    stKeyName.Length = rlLengthKeyName;
    stKeyName.MaximumLength = rlMaxLengthKeyName;
    stKeyName.Buffer = rlwKeyName.data();

    PLSA_UNICODE_STRING PrivateData{};
    uc_reg_read(uc, UC_X86_REG_R8, &PrivateData);

    std::wstring rlwPrivateData;

    USHORT rlLengthPrivateData;

    USHORT rlMaxLengthPrivateData;
    uc_mem_read(uc, (DWORD_PTR)PrivateData, &rlLengthPrivateData, sizeof(rlLengthPrivateData));
    uc_mem_read(uc, (DWORD_PTR)PrivateData+16, &rlMaxLengthPrivateData, sizeof(rlMaxLengthPrivateData));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PrivateData+64, rlwPrivateData, true, rlLengthPrivateData)) { printf("Error when read PrivateData in LsaStorePrivateData"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stPrivateData{};
    stPrivateData.Length = rlLengthPrivateData;
    stPrivateData.MaximumLength = rlMaxLengthPrivateData;
    stPrivateData.Buffer = rlwPrivateData.data();


    NTSTATUS LsaStorePrivateDataResult = LsaStorePrivateData((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stKeyName,(PLSA_UNICODE_STRING)&stPrivateData);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaStorePrivateDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)KeyName, &stKeyName.Length, sizeof(stKeyName.Length));
    uc_mem_write(uc, (DWORD_PTR)KeyName+16, &stKeyName.MaximumLength, sizeof(stKeyName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)KeyName+64, stKeyName.Buffer, true, stKeyName.Length)) { printf("Error when read KeyName in LsaStorePrivateData"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)PrivateData, &stPrivateData.Length, sizeof(stPrivateData.Length));
    uc_mem_write(uc, (DWORD_PTR)PrivateData+16, &stPrivateData.MaximumLength, sizeof(stPrivateData.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PrivateData+64, stPrivateData.Buffer, true, stPrivateData.Length)) { printf("Error when read PrivateData in LsaStorePrivateData"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaStorePrivateData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LsaRetrievePrivateData(
    IN   LSA_HANDLE             PolicyHandle  ,
    IN   PLSA_UNICODE_STRING    KeyName       ,
    OUT  PLSA_UNICODE_STRING *  PrivateData   );

*/
void EmuApi::EmuLsaRetrievePrivateData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LSA_HANDLE PolicyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PolicyHandle);

    PLSA_UNICODE_STRING KeyName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyName);

    std::wstring rlwKeyName;

    USHORT rlLengthKeyName;

    USHORT rlMaxLengthKeyName;
    uc_mem_read(uc, (DWORD_PTR)KeyName, &rlLengthKeyName, sizeof(rlLengthKeyName));
    uc_mem_read(uc, (DWORD_PTR)KeyName+16, &rlMaxLengthKeyName, sizeof(rlMaxLengthKeyName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)KeyName+64, rlwKeyName, true, rlLengthKeyName)) { printf("Error when read KeyName in LsaRetrievePrivateData"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stKeyName{};
    stKeyName.Length = rlLengthKeyName;
    stKeyName.MaximumLength = rlMaxLengthKeyName;
    stKeyName.Buffer = rlwKeyName.data();

    PLSA_UNICODE_STRING * PrivateData{};
    uc_reg_read(uc, UC_X86_REG_R8, &PrivateData);

    PLSA_UNICODE_STRING * dpPrivateData{};

    if(PrivateData != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivateData, &dpPrivateData, sizeof(dpPrivateData));
    }

    std::wstring rlwPrivateData;

    USHORT rlLengthPrivateData;

    USHORT rlMaxLengthPrivateData;
    uc_mem_read(uc, (DWORD_PTR)PrivateData, &rlLengthPrivateData, sizeof(rlLengthPrivateData));
    uc_mem_read(uc, (DWORD_PTR)PrivateData+16, &rlMaxLengthPrivateData, sizeof(rlMaxLengthPrivateData));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PrivateData+64, rlwPrivateData, true, rlLengthPrivateData)) { printf("Error when read PrivateData in LsaRetrievePrivateData"); _CrtDbgBreak(); }

    LSA_UNICODE_STRING stPrivateData{};
    stPrivateData.Length = rlLengthPrivateData;
    stPrivateData.MaximumLength = rlMaxLengthPrivateData;
    stPrivateData.Buffer = rlwPrivateData.data();


    NTSTATUS LsaRetrievePrivateDataResult = LsaRetrievePrivateData((LSA_HANDLE)PolicyHandle,(PLSA_UNICODE_STRING)&stKeyName,(PLSA_UNICODE_STRING *)&stPrivateData);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaRetrievePrivateDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PolicyHandle);
    uc_mem_write(uc, (DWORD_PTR)KeyName, &stKeyName.Length, sizeof(stKeyName.Length));
    uc_mem_write(uc, (DWORD_PTR)KeyName+16, &stKeyName.MaximumLength, sizeof(stKeyName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)KeyName+64, stKeyName.Buffer, true, stKeyName.Length)) { printf("Error when read KeyName in LsaRetrievePrivateData"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)PrivateData, &stPrivateData.Length, sizeof(stPrivateData.Length));
    uc_mem_write(uc, (DWORD_PTR)PrivateData+16, &stPrivateData.MaximumLength, sizeof(stPrivateData.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PrivateData+64, stPrivateData.Buffer, true, stPrivateData.Length)) { printf("Error when read PrivateData in LsaRetrievePrivateData"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaRetrievePrivateData\n";
    #endif

    return;
}


/*
ULONG
__cdecl
LsaNtStatusToWinError(
    IN  NTSTATUS  Status  );

*/
void EmuApi::EmuLsaNtStatusToWinError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS Status{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Status);


    ULONG LsaNtStatusToWinErrorResult = LsaNtStatusToWinError((NTSTATUS)Status);


    uc_reg_write(uc, UC_X86_REG_EAX, &LsaNtStatusToWinErrorResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLsaNtStatusToWinError\n";
    #endif

    return;
}

/*
ULONG
__cdecl
NtGetTickCount(VOID);

*/
void EmuApi::EmuNtGetTickCount(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    ULONG NtGetTickCountResult = NtGetTickCount();


    uc_reg_write(uc, UC_X86_REG_EAX, &NtGetTickCountResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtGetTickCount\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCopySecurityDescriptor(
      PSECURITY_DESCRIPTOR  SourceDescriptor       ,
      PSECURITY_DESCRIPTOR  DestinationDescriptor  );

*/
void EmuApi::EmuRtlCopySecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SourceDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SourceDescriptor);

    PSECURITY_DESCRIPTOR DestinationDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DestinationDescriptor);


    NTSTATUS RtlCopySecurityDescriptorResult = RtlCopySecurityDescriptor((PSECURITY_DESCRIPTOR)&SourceDescriptor,(PSECURITY_DESCRIPTOR*)&DestinationDescriptor);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCopySecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SourceDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &DestinationDescriptor);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopySecurityDescriptor\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitializeHandleTable(
      ULONG              MaximumNumberOfHandles  ,
      ULONG              SizeOfHandleTableEntry  ,
      PRTL_HANDLE_TABLE  HandleTable             );

*/
void EmuApi::EmuRtlInitializeHandleTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG MaximumNumberOfHandles{};
    uc_reg_read(uc, UC_X86_REG_ECX, &MaximumNumberOfHandles);

    ULONG SizeOfHandleTableEntry{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SizeOfHandleTableEntry);

    PRTL_HANDLE_TABLE HandleTable{};
    uc_reg_read(uc, UC_X86_REG_R8, &HandleTable);

    RTL_HANDLE_TABLE stHandleTable{};

    if(HandleTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }


    RtlInitializeHandleTable((ULONG)MaximumNumberOfHandles,(ULONG)SizeOfHandleTableEntry,(PRTL_HANDLE_TABLE)&stHandleTable);


    uc_reg_write(uc, UC_X86_REG_ECX, &MaximumNumberOfHandles);
    uc_reg_write(uc, UC_X86_REG_EDX, &SizeOfHandleTableEntry);
    uc_reg_write(uc, UC_X86_REG_R8, &HandleTable);

    if(HandleTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeHandleTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyHandleTable(
    INOUT  PRTL_HANDLE_TABLE  HandleTable  );

*/
void EmuApi::EmuRtlDestroyHandleTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_HANDLE_TABLE HandleTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HandleTable);

    RTL_HANDLE_TABLE stHandleTable{};

    if(HandleTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }


    NTSTATUS RtlDestroyHandleTableResult = RtlDestroyHandleTable((PRTL_HANDLE_TABLE)&stHandleTable);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyHandleTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HandleTable);

    if(HandleTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyHandleTable\n";
    #endif

    return;
}


/*
PRTL_HANDLE_TABLE_ENTRY
__cdecl
RtlAllocateHandle(
    IN           PRTL_HANDLE_TABLE  HandleTable  ,
    OUTOPTIONAL  PULONG             HandleIndex  );

*/
void EmuApi::EmuRtlAllocateHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_HANDLE_TABLE HandleTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HandleTable);

    RTL_HANDLE_TABLE stHandleTable{};

    if(HandleTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }

    PULONG HandleIndex{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleIndex);

    ULONG rlHandleIndex{};

    if(HandleIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleIndex, &rlHandleIndex, sizeof(rlHandleIndex));
    }


    PRTL_HANDLE_TABLE_ENTRY RtlAllocateHandleResult = RtlAllocateHandle((PRTL_HANDLE_TABLE)&stHandleTable,(PULONG)&rlHandleIndex);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlAllocateHandleResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HandleTable);

    if(HandleTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleIndex);

    if(HandleIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleIndex, &rlHandleIndex, sizeof(rlHandleIndex));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAllocateHandle\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlFreeHandle(
    IN  PRTL_HANDLE_TABLE        HandleTable  ,
    IN  PRTL_HANDLE_TABLE_ENTRY  Handle       );

*/
void EmuApi::EmuRtlFreeHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_HANDLE_TABLE HandleTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HandleTable);

    RTL_HANDLE_TABLE stHandleTable{};

    if(HandleTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }

    PRTL_HANDLE_TABLE_ENTRY Handle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handle);

    RTL_HANDLE_TABLE_ENTRY stHandle{};

    if(Handle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handle, &stHandle, sizeof(stHandle));
    }


    BOOLEAN RtlFreeHandleResult = RtlFreeHandle((PRTL_HANDLE_TABLE)&stHandleTable,(PRTL_HANDLE_TABLE_ENTRY)&stHandle);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlFreeHandleResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HandleTable);

    if(HandleTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Handle);

    if(Handle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handle, &stHandle, sizeof(stHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeHandle\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlIsValidHandle(
    IN  PRTL_HANDLE_TABLE        HandleTable  ,
    IN  PRTL_HANDLE_TABLE_ENTRY  Handle       );

*/
void EmuApi::EmuRtlIsValidHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_HANDLE_TABLE HandleTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HandleTable);

    RTL_HANDLE_TABLE stHandleTable{};

    if(HandleTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }

    PRTL_HANDLE_TABLE_ENTRY Handle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handle);

    RTL_HANDLE_TABLE_ENTRY stHandle{};

    if(Handle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handle, &stHandle, sizeof(stHandle));
    }


    BOOLEAN RtlIsValidHandleResult = RtlIsValidHandle((PRTL_HANDLE_TABLE)&stHandleTable,(PRTL_HANDLE_TABLE_ENTRY)&stHandle);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlIsValidHandleResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HandleTable);

    if(HandleTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Handle);

    if(Handle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handle, &stHandle, sizeof(stHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsValidHandle\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlIsValidIndexHandle(
    IN   PRTL_HANDLE_TABLE          HandleTable  ,
    IN   ULONG                      HandleIndex  ,
    OUT  PRTL_HANDLE_TABLE_ENTRY *  Handle       );

*/
void EmuApi::EmuRtlIsValidIndexHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_HANDLE_TABLE HandleTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HandleTable);

    RTL_HANDLE_TABLE stHandleTable{};

    if(HandleTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }

    ULONG HandleIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &HandleIndex);

    PRTL_HANDLE_TABLE_ENTRY * Handle{};
    uc_reg_read(uc, UC_X86_REG_R8, &Handle);

    PRTL_HANDLE_TABLE_ENTRY * dpHandle{};

    if(Handle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handle, &dpHandle, sizeof(dpHandle));
    }

    RTL_HANDLE_TABLE_ENTRY stHandle{};

    if(dpHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpHandle, &stHandle, sizeof(stHandle));
    }


    BOOLEAN RtlIsValidIndexHandleResult = RtlIsValidIndexHandle((PRTL_HANDLE_TABLE)&stHandleTable,(ULONG)HandleIndex,(PRTL_HANDLE_TABLE_ENTRY *)&stHandle);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlIsValidIndexHandleResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HandleTable);

    if(HandleTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleTable, &stHandleTable, sizeof(stHandleTable));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &HandleIndex);
    uc_reg_write(uc, UC_X86_REG_R8, &Handle);

    if(Handle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handle, &dpHandle, sizeof(dpHandle));
    }

    if(dpHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpHandle, &stHandle, sizeof(stHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsValidIndexHandle\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateAtomTable(
    IN   ULONG    NumberOfBuckets  ,
    OUT  PVOID *  AtomTableHandle  );

*/
void EmuApi::EmuRtlCreateAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG NumberOfBuckets{};
    uc_reg_read(uc, UC_X86_REG_ECX, &NumberOfBuckets);

    PVOID * AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AtomTableHandle);

    PVOID * dpAtomTableHandle{};

    if(AtomTableHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AtomTableHandle, &dpAtomTableHandle, sizeof(dpAtomTableHandle));
    }


    NTSTATUS RtlCreateAtomTableResult = RtlCreateAtomTable((ULONG)NumberOfBuckets,(PVOID *)&dpAtomTableHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &NumberOfBuckets);
    uc_reg_write(uc, UC_X86_REG_RDX, &AtomTableHandle);

    if(AtomTableHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AtomTableHandle, &dpAtomTableHandle, sizeof(dpAtomTableHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyAtomTable(
    IN  PVOID  AtomTableHandle  );

*/
void EmuApi::EmuRtlDestroyAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);


    NTSTATUS RtlDestroyAtomTableResult = RtlDestroyAtomTable((PVOID)&AtomTableHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlEmptyAtomTable(
    IN  PVOID    AtomTableHandle     ,
    IN  BOOLEAN  IncludePinnedAtoms  );

*/
void EmuApi::EmuRtlEmptyAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);

    BOOLEAN IncludePinnedAtoms{};
    uc_reg_read(uc, UC_X86_REG_DL, &IncludePinnedAtoms);


    NTSTATUS RtlEmptyAtomTableResult = RtlEmptyAtomTable((PVOID)&AtomTableHandle,(BOOLEAN)IncludePinnedAtoms);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlEmptyAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    uc_reg_write(uc, UC_X86_REG_DL, &IncludePinnedAtoms);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEmptyAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAtomToAtomTable(
    IN             PVOID      AtomTableHandle  ,
    IN             PWSTR      AtomName         ,
    INOUTOPTIONAL  PRTL_ATOM  Atom             );

*/
void EmuApi::EmuRtlAddAtomToAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlAddAtomToAtomTable"); _CrtDbgBreak(); }

    PRTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_R8, &Atom);

    RTL_ATOM rlAtom{};

    if(Atom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }


    NTSTATUS RtlAddAtomToAtomTableResult = RtlAddAtomToAtomTable((PVOID)&AtomTableHandle,(PWSTR)rlwAtomName.data(),(PRTL_ATOM)&rlAtom);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAtomToAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlAddAtomToAtomTable"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &Atom);

    if(Atom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAtomToAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLookupAtomInAtomTable(
    IN           PVOID      AtomTableHandle  ,
    IN           PWSTR      AtomName         ,
    OUTOPTIONAL  PRTL_ATOM  Atom             );

*/
void EmuApi::EmuRtlLookupAtomInAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlLookupAtomInAtomTable"); _CrtDbgBreak(); }

    PRTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_R8, &Atom);

    RTL_ATOM rlAtom{};

    if(Atom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }


    NTSTATUS RtlLookupAtomInAtomTableResult = RtlLookupAtomInAtomTable((PVOID)&AtomTableHandle,(PWSTR)rlwAtomName.data(),(PRTL_ATOM)&rlAtom);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLookupAtomInAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlLookupAtomInAtomTable"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &Atom);

    if(Atom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLookupAtomInAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteAtomFromAtomTable(
    IN  PVOID     AtomTableHandle  ,
    IN  RTL_ATOM  Atom             );

*/
void EmuApi::EmuRtlDeleteAtomFromAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_DX, &Atom);


    NTSTATUS RtlDeleteAtomFromAtomTableResult = RtlDeleteAtomFromAtomTable((PVOID)&AtomTableHandle,(RTL_ATOM)Atom);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteAtomFromAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    uc_reg_write(uc, UC_X86_REG_DX, &Atom);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteAtomFromAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlPinAtomInAtomTable(
    IN  PVOID     AtomTableHandle  ,
    IN  RTL_ATOM  Atom             );

*/
void EmuApi::EmuRtlPinAtomInAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_DX, &Atom);


    NTSTATUS RtlPinAtomInAtomTableResult = RtlPinAtomInAtomTable((PVOID)&AtomTableHandle,(RTL_ATOM)Atom);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlPinAtomInAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    uc_reg_write(uc, UC_X86_REG_DX, &Atom);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlPinAtomInAtomTable\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryAtomInAtomTable(
    IN             PVOID     AtomTableHandle  ,
    IN             RTL_ATOM  Atom             ,
    OUTOPTIONAL    PULONG    AtomUsage        ,
    OUTOPTIONAL    PULONG    AtomFlags        ,
    INOUT          PWSTR     AtomName         ,
    INOUTOPTIONAL  PULONG    AtomNameLength   );

*/
void EmuApi::EmuRtlQueryAtomInAtomTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID AtomTableHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomTableHandle);

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_DX, &Atom);

    PULONG AtomUsage{};
    uc_reg_read(uc, UC_X86_REG_R8, &AtomUsage);

    ULONG rlAtomUsage{};

    if(AtomUsage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AtomUsage, &rlAtomUsage, sizeof(rlAtomUsage));
    }

    PULONG AtomFlags{};
    uc_reg_read(uc, UC_X86_REG_R9, &AtomFlags);

    ULONG rlAtomFlags{};

    if(AtomFlags != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AtomFlags, &rlAtomFlags, sizeof(rlAtomFlags));
    }

    PWSTR AtomName{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AtomName, sizeof(AtomName));

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlQueryAtomInAtomTable"); _CrtDbgBreak(); }

    PULONG AtomNameLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AtomNameLength, sizeof(AtomNameLength));

    ULONG rlAtomNameLength{};

    if(AtomNameLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AtomNameLength, &rlAtomNameLength, sizeof(rlAtomNameLength));
    }


    NTSTATUS RtlQueryAtomInAtomTableResult = RtlQueryAtomInAtomTable((PVOID)&AtomTableHandle,(RTL_ATOM)Atom,(PULONG)&rlAtomUsage,(PULONG)&rlAtomFlags,(PWSTR)rlwAtomName.data(),(PULONG)&rlAtomNameLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryAtomInAtomTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AtomTableHandle);
    uc_reg_write(uc, UC_X86_REG_DX, &Atom);
    uc_reg_write(uc, UC_X86_REG_R8, &AtomUsage);

    if(AtomUsage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AtomUsage, &rlAtomUsage, sizeof(rlAtomUsage));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &AtomFlags);

    if(AtomFlags != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AtomFlags, &rlAtomFlags, sizeof(rlAtomFlags));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlQueryAtomInAtomTable"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AtomNameLength, sizeof(AtomNameLength));

    if(AtomNameLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AtomNameLength, &rlAtomNameLength, sizeof(rlAtomNameLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryAtomInAtomTable\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlGetIntegerAtom(
    IN           PWSTR    AtomName     ,
    OUTOPTIONAL  PUSHORT  IntegerAtom  );

*/
void EmuApi::EmuRtlGetIntegerAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlGetIntegerAtom"); _CrtDbgBreak(); }

    PUSHORT IntegerAtom{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IntegerAtom);

    USHORT rlIntegerAtom{};

    if(IntegerAtom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IntegerAtom, &rlIntegerAtom, sizeof(rlIntegerAtom));
    }


    BOOLEAN RtlGetIntegerAtomResult = RtlGetIntegerAtom((PWSTR)rlwAtomName.data(),(PUSHORT)&rlIntegerAtom);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlGetIntegerAtomResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in RtlGetIntegerAtom"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &IntegerAtom);

    if(IntegerAtom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IntegerAtom, &rlIntegerAtom, sizeof(rlIntegerAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetIntegerAtom\n";
    #endif

    return;
}


/*
void
__cdecl
RtlAssert(
      PVOID  VoidFailedAssertion  ,
      PVOID  VoidFileName         ,
      ULONG  LineNumber           ,
      PSTR   MutableMessage       );

*/
void EmuApi::EmuRtlAssert(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID VoidFailedAssertion{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VoidFailedAssertion);

    PVOID VoidFileName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VoidFileName);

    ULONG LineNumber{};
    uc_reg_read(uc, UC_X86_REG_R8D, &LineNumber);

    PSTR MutableMessage{};
    uc_reg_read(uc, UC_X86_REG_R9, &MutableMessage);

    std::string rlaMutableMessage;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)MutableMessage, rlaMutableMessage)) { printf("Error when read MutableMessage in RtlAssert"); _CrtDbgBreak(); }


    RtlAssert((PVOID)&VoidFailedAssertion,(PVOID)&VoidFileName,(ULONG)LineNumber,(PSTR)rlaMutableMessage.data());


    uc_reg_write(uc, UC_X86_REG_RCX, &VoidFailedAssertion);
    uc_reg_write(uc, UC_X86_REG_RDX, &VoidFileName);
    uc_reg_write(uc, UC_X86_REG_R8D, &LineNumber);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)MutableMessage, rlaMutableMessage)) { printf("Error when read MutableMessage in RtlAssert"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAssert\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitializeGenericTableAvl(
      PRTL_AVL_TABLE             Table            ,
      PRTL_AVL_COMPARE_ROUTINE   CompareRoutine   ,
      PRTL_AVL_ALLOCATE_ROUTINE  AllocateRoutine  ,
      PRTL_AVL_FREE_ROUTINE      FreeRoutine      ,
      PVOID                      TableContext     );

*/
void EmuApi::EmuRtlInitializeGenericTableAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PRTL_AVL_COMPARE_ROUTINE CompareRoutine{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CompareRoutine);

    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &AllocateRoutine);

    PRTL_AVL_FREE_ROUTINE FreeRoutine{};
    uc_reg_read(uc, UC_X86_REG_R9, &FreeRoutine);

    PVOID TableContext{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TableContext, sizeof(TableContext));


    RtlInitializeGenericTableAvl((PRTL_AVL_TABLE)&stTable,(PRTL_AVL_COMPARE_ROUTINE)CompareRoutine,(PRTL_AVL_ALLOCATE_ROUTINE)AllocateRoutine,(PRTL_AVL_FREE_ROUTINE)FreeRoutine,(PVOID)&TableContext);


    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &CompareRoutine);
    uc_reg_write(uc, UC_X86_REG_R8, &AllocateRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &FreeRoutine);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TableContext, sizeof(TableContext));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeGenericTableAvl\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlInsertElementGenericTableAvl(
      PRTL_AVL_TABLE  Table       ,
      PVOID           Buffer      ,
      ULONG           BufferSize  ,
      PBOOLEAN        NewElement  );

*/
void EmuApi::EmuRtlInsertElementGenericTableAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    ULONG BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &BufferSize);

    PBOOLEAN NewElement{};
    uc_reg_read(uc, UC_X86_REG_R9, &NewElement);

    BOOLEAN rlNewElement{};

    if(NewElement != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }


    PVOID RtlInsertElementGenericTableAvlResult = RtlInsertElementGenericTableAvl((PRTL_AVL_TABLE)&stTable,(PVOID)&Buffer,(ULONG)BufferSize,(PBOOLEAN)&rlNewElement);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlInsertElementGenericTableAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &BufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &NewElement);

    if(NewElement != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInsertElementGenericTableAvl\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlInsertElementGenericTableFullAvl(
       PRTL_AVL_TABLE       Table         ,
       PVOID                Buffer        ,
       ULONG                BufferSize    ,
       PBOOLEAN             NewElement    ,
    ,  PVOID                NodeOrParent  ,
       TABLE_SEARCH_RESULT  SearchResult  );

*/
void EmuApi::EmuRtlInsertElementGenericTableFullAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    ULONG BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &BufferSize);

    PBOOLEAN NewElement{};
    uc_reg_read(uc, UC_X86_REG_R9, &NewElement);

    BOOLEAN rlNewElement{};

    if(NewElement != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }

    PVOID NodeOrParent{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NodeOrParent, sizeof(NodeOrParent));

    TABLE_SEARCH_RESULT SearchResult{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SearchResult, sizeof(SearchResult));


    PVOID RtlInsertElementGenericTableFullAvlResult = RtlInsertElementGenericTableFullAvl((PRTL_AVL_TABLE)&stTable,(PVOID)&Buffer,(ULONG)BufferSize,(PBOOLEAN)&rlNewElement,(PVOID)&NodeOrParent,(TABLE_SEARCH_RESULT)SearchResult);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlInsertElementGenericTableFullAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &BufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &NewElement);

    if(NewElement != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NodeOrParent, sizeof(NodeOrParent));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SearchResult, sizeof(SearchResult));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInsertElementGenericTableFullAvl\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlDeleteElementGenericTableAvl(
      PRTL_AVL_TABLE  Table   ,
      PVOID           Buffer  );

*/
void EmuApi::EmuRtlDeleteElementGenericTableAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);


    BOOLEAN RtlDeleteElementGenericTableAvlResult = RtlDeleteElementGenericTableAvl((PRTL_AVL_TABLE)&stTable,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlDeleteElementGenericTableAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteElementGenericTableAvl\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlLookupElementGenericTableAvl(
      PRTL_AVL_TABLE  Table   ,
      PVOID           Buffer  );

*/
void EmuApi::EmuRtlLookupElementGenericTableAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);


    PVOID RtlLookupElementGenericTableAvlResult = RtlLookupElementGenericTableAvl((PRTL_AVL_TABLE)&stTable,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlLookupElementGenericTableAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLookupElementGenericTableAvl\n";
    #endif

    return;
}

/*
PVOID
__cdecl
RtlEnumerateGenericTableAvl(
      PRTL_AVL_TABLE  Table    ,
      BOOLEAN         Restart  );

*/
void EmuApi::EmuRtlEnumerateGenericTableAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    BOOLEAN Restart{};
    uc_reg_read(uc, UC_X86_REG_DL, &Restart);


    PVOID RtlEnumerateGenericTableAvlResult = RtlEnumerateGenericTableAvl((PRTL_AVL_TABLE)&stTable,(BOOLEAN)Restart);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEnumerateGenericTableAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_DL, &Restart);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEnumerateGenericTableAvl\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlEnumerateGenericTableWithoutSplayingAvl(
      PRTL_AVL_TABLE  Table       ,
      PVOID *         RestartKey  );

*/
void EmuApi::EmuRtlEnumerateGenericTableWithoutSplayingAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PVOID * RestartKey{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RestartKey);

    PVOID * dpRestartKey{};

    if(RestartKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RestartKey, &dpRestartKey, sizeof(dpRestartKey));
    }


    PVOID RtlEnumerateGenericTableWithoutSplayingAvlResult = RtlEnumerateGenericTableWithoutSplayingAvl((PRTL_AVL_TABLE)&stTable,(PVOID *)&dpRestartKey);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEnumerateGenericTableWithoutSplayingAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &RestartKey);

    if(RestartKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RestartKey, &dpRestartKey, sizeof(dpRestartKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEnumerateGenericTableWithoutSplayingAvl\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlEnumerateGenericTableLikeADirectory(
    IN     PRTL_AVL_TABLE           Table          ,
    IN     PRTL_AVL_MATCH_FUNCTION  MatchFunction  ,
    IN     PVOID                    MatchData      ,
    IN     ULONG                    NextFlag       ,
    INOUT  PVOID *                  RestartKey     ,
    INOUT  PULONG                   DeleteCount    ,
    INOUT  PVOID                    Buffer         );

*/
void EmuApi::EmuRtlEnumerateGenericTableLikeADirectory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    PRTL_AVL_MATCH_FUNCTION MatchFunction{};
    uc_reg_read(uc, UC_X86_REG_RDX, &MatchFunction);

    PVOID MatchData{};
    uc_reg_read(uc, UC_X86_REG_R8, &MatchData);

    ULONG NextFlag{};
    uc_reg_read(uc, UC_X86_REG_R9D, &NextFlag);

    PVOID * RestartKey{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RestartKey, sizeof(RestartKey));

    PVOID * dpRestartKey{};

    if(RestartKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RestartKey, &dpRestartKey, sizeof(dpRestartKey));
    }

    PULONG DeleteCount{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &DeleteCount, sizeof(DeleteCount));

    ULONG rlDeleteCount{};

    if(DeleteCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DeleteCount, &rlDeleteCount, sizeof(rlDeleteCount));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Buffer, sizeof(Buffer));


    PVOID RtlEnumerateGenericTableLikeADirectoryResult = RtlEnumerateGenericTableLikeADirectory((PRTL_AVL_TABLE)&stTable,(PRTL_AVL_MATCH_FUNCTION)MatchFunction,(PVOID)&MatchData,(ULONG)NextFlag,(PVOID *)&dpRestartKey,(PULONG)&rlDeleteCount,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEnumerateGenericTableLikeADirectoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &MatchFunction);
    uc_reg_write(uc, UC_X86_REG_R8, &MatchData);
    uc_reg_write(uc, UC_X86_REG_R9D, &NextFlag);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RestartKey, sizeof(RestartKey));

    if(RestartKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RestartKey, &dpRestartKey, sizeof(dpRestartKey));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &DeleteCount, sizeof(DeleteCount));

    if(DeleteCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DeleteCount, &rlDeleteCount, sizeof(rlDeleteCount));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Buffer, sizeof(Buffer));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEnumerateGenericTableLikeADirectory\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlGetElementGenericTableAvl(
      PRTL_AVL_TABLE  Table  ,
      ULONG           I      );

*/
void EmuApi::EmuRtlGetElementGenericTableAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }

    ULONG I{};
    uc_reg_read(uc, UC_X86_REG_EDX, &I);


    PVOID RtlGetElementGenericTableAvlResult = RtlGetElementGenericTableAvl((PRTL_AVL_TABLE)&stTable,(ULONG)I);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlGetElementGenericTableAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &I);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetElementGenericTableAvl\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlNumberGenericTableElementsAvl(
      PRTL_AVL_TABLE  Table  );

*/
void EmuApi::EmuRtlNumberGenericTableElementsAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }


    ULONG RtlNumberGenericTableElementsAvlResult = RtlNumberGenericTableElementsAvl((PRTL_AVL_TABLE)&stTable);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNumberGenericTableElementsAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNumberGenericTableElementsAvl\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlIsGenericTableEmptyAvl(
      PRTL_AVL_TABLE  Table  );

*/
void EmuApi::EmuRtlIsGenericTableEmptyAvl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_AVL_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_AVL_TABLE stTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }


    BOOLEAN RtlIsGenericTableEmptyAvlResult = RtlIsGenericTableEmptyAvl((PRTL_AVL_TABLE)&stTable);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlIsGenericTableEmptyAvlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &stTable, sizeof(stTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsGenericTableEmptyAvl\n";
    #endif

    return;
}


/*
PRTL_SPLAY_LINKS
__cdecl
RtlSplay(
      PRTL_SPLAY_LINKS  Links  );

*/
void EmuApi::EmuRtlSplay(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }


    PRTL_SPLAY_LINKS RtlSplayResult = RtlSplay((PRTL_SPLAY_LINKS)&rlLinks);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSplayResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSplay\n";
    #endif

    return;
}


/*
PRTL_SPLAY_LINKS
__cdecl
RtlDelete(
      PRTL_SPLAY_LINKS  Links  );

*/
void EmuApi::EmuRtlDelete(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }


    PRTL_SPLAY_LINKS RtlDeleteResult = RtlDelete((PRTL_SPLAY_LINKS)&rlLinks);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlDeleteResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDelete\n";
    #endif

    return;
}


/*
void
__cdecl
RtlDeleteNoSplay(
      PRTL_SPLAY_LINKS    Links  ,
      PRTL_SPLAY_LINKS *  Root   );

*/
void EmuApi::EmuRtlDeleteNoSplay(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }

    PRTL_SPLAY_LINKS * Root{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Root);

    PRTL_SPLAY_LINKS * dpRoot{};

    if(Root != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Root, &dpRoot, sizeof(dpRoot));
    }

    RTL_SPLAY_LINKS rlRoot{};

    if(dpRoot != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpRoot, &rlRoot, sizeof(rlRoot));
    }


    RtlDeleteNoSplay((PRTL_SPLAY_LINKS)&rlLinks,(PRTL_SPLAY_LINKS *)&rlRoot);


    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Root);

    if(Root != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Root, &dpRoot, sizeof(dpRoot));
    }

    if(dpRoot != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpRoot, &rlRoot, sizeof(rlRoot));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteNoSplay\n";
    #endif

    return;
}


/*
PRTL_SPLAY_LINKS
__cdecl
RtlSubtreeSuccessor(
      PRTL_SPLAY_LINKS  Links  );

*/
void EmuApi::EmuRtlSubtreeSuccessor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }


    PRTL_SPLAY_LINKS RtlSubtreeSuccessorResult = RtlSubtreeSuccessor((PRTL_SPLAY_LINKS)&rlLinks);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSubtreeSuccessorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSubtreeSuccessor\n";
    #endif

    return;
}


/*
PRTL_SPLAY_LINKS
__cdecl
RtlSubtreePredecessor(
      PRTL_SPLAY_LINKS  Links  );

*/
void EmuApi::EmuRtlSubtreePredecessor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }


    PRTL_SPLAY_LINKS RtlSubtreePredecessorResult = RtlSubtreePredecessor((PRTL_SPLAY_LINKS)&rlLinks);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSubtreePredecessorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSubtreePredecessor\n";
    #endif

    return;
}


/*
PRTL_SPLAY_LINKS
__cdecl
RtlRealSuccessor(
      PRTL_SPLAY_LINKS  Links  );

*/
void EmuApi::EmuRtlRealSuccessor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }


    PRTL_SPLAY_LINKS RtlRealSuccessorResult = RtlRealSuccessor((PRTL_SPLAY_LINKS)&rlLinks);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlRealSuccessorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRealSuccessor\n";
    #endif

    return;
}


/*
PRTL_SPLAY_LINKS
__cdecl
RtlRealPredecessor(
      PRTL_SPLAY_LINKS  Links  );

*/
void EmuApi::EmuRtlRealPredecessor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_SPLAY_LINKS Links{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Links);

    RTL_SPLAY_LINKS rlLinks{};

    if(Links != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }


    PRTL_SPLAY_LINKS RtlRealPredecessorResult = RtlRealPredecessor((PRTL_SPLAY_LINKS)&rlLinks);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlRealPredecessorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Links);

    if(Links != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Links, &rlLinks, sizeof(rlLinks));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRealPredecessor\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitializeGenericTable(
      PRTL_GENERIC_TABLE             Table            ,
      PRTL_GENERIC_COMPARE_ROUTINE   CompareRoutine   ,
      PRTL_GENERIC_ALLOCATE_ROUTINE  AllocateRoutine  ,
      PRTL_GENERIC_FREE_ROUTINE      FreeRoutine      ,
      PVOID                          TableContext     );

*/
void EmuApi::EmuRtlInitializeGenericTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CompareRoutine);

    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &AllocateRoutine);

    PRTL_GENERIC_FREE_ROUTINE FreeRoutine{};
    uc_reg_read(uc, UC_X86_REG_R9, &FreeRoutine);

    PVOID TableContext{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TableContext, sizeof(TableContext));


    RtlInitializeGenericTable((PRTL_GENERIC_TABLE)&rlTable,(PRTL_GENERIC_COMPARE_ROUTINE)CompareRoutine,(PRTL_GENERIC_ALLOCATE_ROUTINE)AllocateRoutine,(PRTL_GENERIC_FREE_ROUTINE)FreeRoutine,(PVOID)&TableContext);


    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &CompareRoutine);
    uc_reg_write(uc, UC_X86_REG_R8, &AllocateRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &FreeRoutine);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TableContext, sizeof(TableContext));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeGenericTable\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlInsertElementGenericTable(
      PRTL_GENERIC_TABLE  Table       ,
      PVOID               Buffer      ,
      ULONG               BufferSize  ,
      PBOOLEAN            NewElement  );

*/
void EmuApi::EmuRtlInsertElementGenericTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    ULONG BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &BufferSize);

    PBOOLEAN NewElement{};
    uc_reg_read(uc, UC_X86_REG_R9, &NewElement);

    BOOLEAN rlNewElement{};

    if(NewElement != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }


    PVOID RtlInsertElementGenericTableResult = RtlInsertElementGenericTable((PRTL_GENERIC_TABLE)&rlTable,(PVOID)&Buffer,(ULONG)BufferSize,(PBOOLEAN)&rlNewElement);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlInsertElementGenericTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &BufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &NewElement);

    if(NewElement != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInsertElementGenericTable\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlInsertElementGenericTableFull(
       PRTL_GENERIC_TABLE   Table         ,
       PVOID                Buffer        ,
       ULONG                BufferSize    ,
       PBOOLEAN             NewElement    ,
    ,  PVOID                NodeOrParent  ,
       TABLE_SEARCH_RESULT  SearchResult  );

*/
void EmuApi::EmuRtlInsertElementGenericTableFull(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    ULONG BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &BufferSize);

    PBOOLEAN NewElement{};
    uc_reg_read(uc, UC_X86_REG_R9, &NewElement);

    BOOLEAN rlNewElement{};

    if(NewElement != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }

    PVOID NodeOrParent{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NodeOrParent, sizeof(NodeOrParent));

    TABLE_SEARCH_RESULT SearchResult{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SearchResult, sizeof(SearchResult));


    PVOID RtlInsertElementGenericTableFullResult = RtlInsertElementGenericTableFull((PRTL_GENERIC_TABLE)&rlTable,(PVOID)&Buffer,(ULONG)BufferSize,(PBOOLEAN)&rlNewElement,(PVOID)&NodeOrParent,(TABLE_SEARCH_RESULT)SearchResult);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlInsertElementGenericTableFullResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &BufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &NewElement);

    if(NewElement != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewElement, &rlNewElement, sizeof(rlNewElement));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NodeOrParent, sizeof(NodeOrParent));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SearchResult, sizeof(SearchResult));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInsertElementGenericTableFull\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlDeleteElementGenericTable(
      PRTL_GENERIC_TABLE  Table   ,
      PVOID               Buffer  );

*/
void EmuApi::EmuRtlDeleteElementGenericTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);


    BOOLEAN RtlDeleteElementGenericTableResult = RtlDeleteElementGenericTable((PRTL_GENERIC_TABLE)&rlTable,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlDeleteElementGenericTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteElementGenericTable\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlLookupElementGenericTable(
      PRTL_GENERIC_TABLE  Table   ,
      PVOID               Buffer  );

*/
void EmuApi::EmuRtlLookupElementGenericTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);


    PVOID RtlLookupElementGenericTableResult = RtlLookupElementGenericTable((PRTL_GENERIC_TABLE)&rlTable,(PVOID)&Buffer);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlLookupElementGenericTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLookupElementGenericTable\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlEnumerateGenericTable(
      PRTL_GENERIC_TABLE  Table    ,
      BOOLEAN             Restart  );

*/
void EmuApi::EmuRtlEnumerateGenericTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    BOOLEAN Restart{};
    uc_reg_read(uc, UC_X86_REG_DL, &Restart);


    PVOID RtlEnumerateGenericTableResult = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE)&rlTable,(BOOLEAN)Restart);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEnumerateGenericTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_DL, &Restart);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEnumerateGenericTable\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlEnumerateGenericTableWithoutSplaying(
      PRTL_GENERIC_TABLE  Table       ,
      PVOID *             RestartKey  );

*/
void EmuApi::EmuRtlEnumerateGenericTableWithoutSplaying(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    PVOID * RestartKey{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RestartKey);

    PVOID * dpRestartKey{};

    if(RestartKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RestartKey, &dpRestartKey, sizeof(dpRestartKey));
    }


    PVOID RtlEnumerateGenericTableWithoutSplayingResult = RtlEnumerateGenericTableWithoutSplaying((PRTL_GENERIC_TABLE)&rlTable,(PVOID *)&dpRestartKey);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEnumerateGenericTableWithoutSplayingResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &RestartKey);

    if(RestartKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RestartKey, &dpRestartKey, sizeof(dpRestartKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEnumerateGenericTableWithoutSplaying\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlGetElementGenericTable(
      PRTL_GENERIC_TABLE  Table  ,
      ULONG               I      );

*/
void EmuApi::EmuRtlGetElementGenericTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }

    ULONG I{};
    uc_reg_read(uc, UC_X86_REG_EDX, &I);


    PVOID RtlGetElementGenericTableResult = RtlGetElementGenericTable((PRTL_GENERIC_TABLE)&rlTable,(ULONG)I);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlGetElementGenericTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &I);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetElementGenericTable\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlNumberGenericTableElements(
      PRTL_GENERIC_TABLE  Table  );

*/
void EmuApi::EmuRtlNumberGenericTableElements(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }


    ULONG RtlNumberGenericTableElementsResult = RtlNumberGenericTableElements((PRTL_GENERIC_TABLE)&rlTable);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNumberGenericTableElementsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNumberGenericTableElements\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlIsGenericTableEmpty(
      PRTL_GENERIC_TABLE  Table  );

*/
void EmuApi::EmuRtlIsGenericTableEmpty(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_GENERIC_TABLE Table{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Table);

    RTL_GENERIC_TABLE rlTable{};

    if(Table != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }


    BOOLEAN RtlIsGenericTableEmptyResult = RtlIsGenericTableEmpty((PRTL_GENERIC_TABLE)&rlTable);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlIsGenericTableEmptyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Table);

    if(Table != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Table, &rlTable, sizeof(rlTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsGenericTableEmpty\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlCreateHeap(
    IN   ULONG                 Flags        ,
    IN   PVOID                 HeapBase     ,
    ,IN  SIZE_T                ReserveSize  ,
    ,IN  SIZE_T                CommitSize   ,
    ,IN  PVOID                 Lock         ,
    ,IN  PRTL_HEAP_PARAMETERS  Parameters   );

*/
void EmuApi::EmuRtlCreateHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PVOID HeapBase{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HeapBase);

    SIZE_T ReserveSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReserveSize);

    SIZE_T CommitSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &CommitSize);

    PVOID Lock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Lock, sizeof(Lock));

    PRTL_HEAP_PARAMETERS Parameters{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Parameters, sizeof(Parameters));

    RTL_HEAP_PARAMETERS stParameters{};

    if(Parameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Parameters, &stParameters, sizeof(stParameters));
    }


    PVOID RtlCreateHeapResult = RtlCreateHeap((ULONG)Flags,(PVOID)&HeapBase,(SIZE_T)ReserveSize,(SIZE_T)CommitSize,(PVOID)&Lock,(PRTL_HEAP_PARAMETERS)&stParameters);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlCreateHeapResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_reg_write(uc, UC_X86_REG_RDX, &HeapBase);
    uc_reg_write(uc, UC_X86_REG_R8, &ReserveSize);
    uc_reg_write(uc, UC_X86_REG_R9, &CommitSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Lock, sizeof(Lock));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Parameters, sizeof(Parameters));

    if(Parameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Parameters, &stParameters, sizeof(stParameters));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateHeap\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlDestroyHeap(
    IN  PVOID  HeapHandle  );

*/
void EmuApi::EmuRtlDestroyHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);


    PVOID RtlDestroyHeapResult = RtlDestroyHeap((PVOID)&HeapHandle);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlDestroyHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyHeap\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlAllocateHeap(
    IN  PVOID   HeapHandle  ,
    IN  ULONG   Flags       ,
    IN  SIZE_T  Size        );

*/
void EmuApi::EmuRtlAllocateHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    SIZE_T Size{};
    uc_reg_read(uc, UC_X86_REG_R8, &Size);


    PVOID RtlAllocateHeapResult = RtlAllocateHeap((PVOID)&HeapHandle,(ULONG)Flags,(SIZE_T)Size);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlAllocateHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &Size);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAllocateHeap\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlFreeHeap(
    IN          PVOID  HeapHandle   ,
    INOPTIONAL  ULONG  Flags        ,
    IN          PVOID  BaseAddress  );

*/
void EmuApi::EmuRtlFreeHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);


    LOGICAL RtlFreeHeapResult = RtlFreeHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&BaseAddress);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFreeHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeHeap\n";
    #endif

    return;
}


/*
SIZE_T
__cdecl
RtlSizeHeap(
    IN  PVOID  HeapHandle   ,
    IN  ULONG  Flags        ,
    IN  PVOID  BaseAddress  );

*/
void EmuApi::EmuRtlSizeHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);


    SIZE_T RtlSizeHeapResult = RtlSizeHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&BaseAddress);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSizeHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSizeHeap\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlZeroHeap(
    IN  PVOID  HeapHandle  ,
    IN  ULONG  Flags       );

*/
void EmuApi::EmuRtlZeroHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);


    NTSTATUS RtlZeroHeapResult = RtlZeroHeap((PVOID)&HeapHandle,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlZeroHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlZeroHeap\n";
    #endif

    return;
}


/*
void
__cdecl
RtlProtectHeap(
      PVOID    HeapHandle    ,
      BOOLEAN  MakeReadOnly  );

*/
void EmuApi::EmuRtlProtectHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    BOOLEAN MakeReadOnly{};
    uc_reg_read(uc, UC_X86_REG_DL, &MakeReadOnly);


    RtlProtectHeap((PVOID)&HeapHandle,(BOOLEAN)MakeReadOnly);


    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_DL, &MakeReadOnly);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlProtectHeap\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlGetNtGlobalFlags(VOID);

*/
void EmuApi::EmuRtlGetNtGlobalFlags(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    ULONG RtlGetNtGlobalFlagsResult = RtlGetNtGlobalFlags();


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetNtGlobalFlagsResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetNtGlobalFlags\n";
    #endif

    return;
}


/*
void
__cdecl
RtlGetCallersAddress(
      PVOID *  CallersAddress  ,
      PVOID *  CallersCaller   );

*/
void EmuApi::EmuRtlGetCallersAddress(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * CallersAddress{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CallersAddress);

    PVOID * dpCallersAddress{};

    if(CallersAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CallersAddress, &dpCallersAddress, sizeof(dpCallersAddress));
    }

    PVOID * CallersCaller{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CallersCaller);

    PVOID * dpCallersCaller{};

    if(CallersCaller != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CallersCaller, &dpCallersCaller, sizeof(dpCallersCaller));
    }


    RtlGetCallersAddress((PVOID *)&dpCallersAddress,(PVOID *)&dpCallersCaller);


    uc_reg_write(uc, UC_X86_REG_RCX, &CallersAddress);

    if(CallersAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CallersAddress, &dpCallersAddress, sizeof(dpCallersAddress));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &CallersCaller);

    if(CallersCaller != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CallersCaller, &dpCallersCaller, sizeof(dpCallersCaller));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCallersAddress\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlWalkFrameChain(
    OUT  PVOID *  Callers  ,
    IN   ULONG    Count    ,
    IN   ULONG    Flags    );

*/
void EmuApi::EmuRtlWalkFrameChain(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * Callers{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Callers);

    PVOID * dpCallers{};

    if(Callers != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Callers, &dpCallers, sizeof(dpCallers));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    ULONG RtlWalkFrameChainResult = RtlWalkFrameChain((PVOID *)&dpCallers,(ULONG)Count,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlWalkFrameChainResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Callers);

    if(Callers != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Callers, &dpCallers, sizeof(dpCallers));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlWalkFrameChain\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlGetNtProductType(
      PNT_PRODUCT_TYPE  NtProductType  );

*/
void EmuApi::EmuRtlGetNtProductType(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PNT_PRODUCT_TYPE NtProductType{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NtProductType);

    enum _NT_PRODUCT_TYPE rlNtProductType{};

    if(NtProductType != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NtProductType, &rlNtProductType, sizeof(rlNtProductType));
    }


    BOOLEAN RtlGetNtProductTypeResult = RtlGetNtProductType((PNT_PRODUCT_TYPE)&rlNtProductType);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlGetNtProductTypeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NtProductType);

    if(NtProductType != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NtProductType, &rlNtProductType, sizeof(rlNtProductType));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetNtProductType\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlFormatCurrentUserKeyPath(
    OUT  PUNICODE_STRING  CurrentUserKeyPath  );

*/
void EmuApi::EmuRtlFormatCurrentUserKeyPath(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING CurrentUserKeyPath{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CurrentUserKeyPath);

    std::wstring rlwCurrentUserKeyPath;

    USHORT rlLengthCurrentUserKeyPath;

    USHORT rlMaxLengthCurrentUserKeyPath;
    uc_mem_read(uc, (DWORD_PTR)CurrentUserKeyPath, &rlLengthCurrentUserKeyPath, sizeof(rlLengthCurrentUserKeyPath));
    uc_mem_read(uc, (DWORD_PTR)CurrentUserKeyPath+16, &rlMaxLengthCurrentUserKeyPath, sizeof(rlMaxLengthCurrentUserKeyPath));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)CurrentUserKeyPath+64, rlwCurrentUserKeyPath, true, rlLengthCurrentUserKeyPath)) { printf("Error when read CurrentUserKeyPath in RtlFormatCurrentUserKeyPath"); _CrtDbgBreak(); }

    UNICODE_STRING stCurrentUserKeyPath{};
    stCurrentUserKeyPath.Length = rlLengthCurrentUserKeyPath;
    stCurrentUserKeyPath.MaximumLength = rlMaxLengthCurrentUserKeyPath;
    stCurrentUserKeyPath.Buffer = rlwCurrentUserKeyPath.data();


    NTSTATUS RtlFormatCurrentUserKeyPathResult = RtlFormatCurrentUserKeyPath((PUNICODE_STRING)&stCurrentUserKeyPath);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFormatCurrentUserKeyPathResult);
    uc_mem_write(uc, (DWORD_PTR)CurrentUserKeyPath, &stCurrentUserKeyPath.Length, sizeof(stCurrentUserKeyPath.Length));
    uc_mem_write(uc, (DWORD_PTR)CurrentUserKeyPath+16, &stCurrentUserKeyPath.MaximumLength, sizeof(stCurrentUserKeyPath.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)CurrentUserKeyPath+64, stCurrentUserKeyPath.Buffer, true, stCurrentUserKeyPath.Length)) { printf("Error when read CurrentUserKeyPath in RtlFormatCurrentUserKeyPath"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFormatCurrentUserKeyPath\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlOpenCurrentUser(
    IN   ULONG    DesiredAccess   ,
    OUT  PHANDLE  CurrentUserKey  );

*/
void EmuApi::EmuRtlOpenCurrentUser(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_ECX, &DesiredAccess);

    HANDLE CurrentUserKey{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CurrentUserKey);

    HANDLE dpCurrentUserKey{};

    if(CurrentUserKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CurrentUserKey, &dpCurrentUserKey, sizeof(dpCurrentUserKey));
    }


    NTSTATUS RtlOpenCurrentUserResult = RtlOpenCurrentUser((ULONG)DesiredAccess,(PHANDLE)dpCurrentUserKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlOpenCurrentUserResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_RDX, &CurrentUserKey);

    if(CurrentUserKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CurrentUserKey, &dpCurrentUserKey, sizeof(dpCurrentUserKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlOpenCurrentUser\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryRegistryValues(
    IN  ULONG                      RelativeTo   ,
    IN  PCWSTR                     Path         ,
    IN  PRTL_QUERY_REGISTRY_TABLE  QueryTable   ,
    IN  PVOID                      Context      ,
    IN  PVOID                      Environment  );

*/
void EmuApi::EmuRtlQueryRegistryValues(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG RelativeTo{};
    uc_reg_read(uc, UC_X86_REG_ECX, &RelativeTo);

    PWSTR Path{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Path);

    std::wstring rlwPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlQueryRegistryValues"); _CrtDbgBreak(); }

    PRTL_QUERY_REGISTRY_TABLE QueryTable{};
    uc_reg_read(uc, UC_X86_REG_R8, &QueryTable);

    RTL_QUERY_REGISTRY_TABLE stQueryTable{};

    if(QueryTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)QueryTable, &stQueryTable, sizeof(stQueryTable));
    }

    PVOID Context{};
    uc_reg_read(uc, UC_X86_REG_R9, &Context);

    PVOID Environment{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Environment, sizeof(Environment));


    NTSTATUS RtlQueryRegistryValuesResult = RtlQueryRegistryValues((ULONG)RelativeTo,(PCWSTR)rlwPath.data(),(PRTL_QUERY_REGISTRY_TABLE)&stQueryTable,(PVOID)&Context,(PVOID)&Environment);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryRegistryValuesResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &RelativeTo);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlQueryRegistryValues"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &QueryTable);

    if(QueryTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)QueryTable, &stQueryTable, sizeof(stQueryTable));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Context);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Environment, sizeof(Environment));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryRegistryValues\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlWriteRegistryValue(
    IN  ULONG   RelativeTo   ,
    IN  PCWSTR  Path         ,
    IN  PCWSTR  ValueName    ,
    IN  ULONG   ValueType    ,
    IN  PVOID   ValueData    ,
    IN  ULONG   ValueLength  );

*/
void EmuApi::EmuRtlWriteRegistryValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG RelativeTo{};
    uc_reg_read(uc, UC_X86_REG_ECX, &RelativeTo);

    PWSTR Path{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Path);

    std::wstring rlwPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlWriteRegistryValue"); _CrtDbgBreak(); }

    PWSTR ValueName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ValueName);

    std::wstring rlwValueName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName, rlwValueName)) { printf("Error when read ValueName in RtlWriteRegistryValue"); _CrtDbgBreak(); }

    ULONG ValueType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ValueType);

    PVOID ValueData{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ValueData, sizeof(ValueData));

    ULONG ValueLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ValueLength, sizeof(ValueLength));


    NTSTATUS RtlWriteRegistryValueResult = RtlWriteRegistryValue((ULONG)RelativeTo,(PCWSTR)rlwPath.data(),(PCWSTR)rlwValueName.data(),(ULONG)ValueType,(PVOID)&ValueData,(ULONG)ValueLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlWriteRegistryValueResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &RelativeTo);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlWriteRegistryValue"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName, rlwValueName)) { printf("Error when read ValueName in RtlWriteRegistryValue"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9D, &ValueType);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ValueData, sizeof(ValueData));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ValueLength, sizeof(ValueLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlWriteRegistryValue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteRegistryValue(
    IN  ULONG   RelativeTo  ,
    IN  PCWSTR  Path        ,
    IN  PCWSTR  ValueName   );

*/
void EmuApi::EmuRtlDeleteRegistryValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG RelativeTo{};
    uc_reg_read(uc, UC_X86_REG_ECX, &RelativeTo);

    PWSTR Path{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Path);

    std::wstring rlwPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlDeleteRegistryValue"); _CrtDbgBreak(); }

    PWSTR ValueName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ValueName);

    std::wstring rlwValueName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName, rlwValueName)) { printf("Error when read ValueName in RtlDeleteRegistryValue"); _CrtDbgBreak(); }


    NTSTATUS RtlDeleteRegistryValueResult = RtlDeleteRegistryValue((ULONG)RelativeTo,(PCWSTR)rlwPath.data(),(PCWSTR)rlwValueName.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteRegistryValueResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &RelativeTo);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlDeleteRegistryValue"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName, rlwValueName)) { printf("Error when read ValueName in RtlDeleteRegistryValue"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteRegistryValue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateRegistryKey(
    IN  ULONG  RelativeTo  ,
    IN  PWSTR  Path        );

*/
void EmuApi::EmuRtlCreateRegistryKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG RelativeTo{};
    uc_reg_read(uc, UC_X86_REG_ECX, &RelativeTo);

    PWSTR Path{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Path);

    std::wstring rlwPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlCreateRegistryKey"); _CrtDbgBreak(); }


    NTSTATUS RtlCreateRegistryKeyResult = RtlCreateRegistryKey((ULONG)RelativeTo,(PWSTR)rlwPath.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateRegistryKeyResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &RelativeTo);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlCreateRegistryKey"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateRegistryKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCheckRegistryKey(
    IN  ULONG  RelativeTo  ,
    IN  PWSTR  Path        );

*/
void EmuApi::EmuRtlCheckRegistryKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG RelativeTo{};
    uc_reg_read(uc, UC_X86_REG_ECX, &RelativeTo);

    PWSTR Path{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Path);

    std::wstring rlwPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlCheckRegistryKey"); _CrtDbgBreak(); }


    NTSTATUS RtlCheckRegistryKeyResult = RtlCheckRegistryKey((ULONG)RelativeTo,(PWSTR)rlwPath.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCheckRegistryKeyResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &RelativeTo);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Path, rlwPath)) { printf("Error when read Path in RtlCheckRegistryKey"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCheckRegistryKey\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlLockHeap(
    IN  PVOID  HeapHandle  );

*/
void EmuApi::EmuRtlLockHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);


    BOOLEAN RtlLockHeapResult = RtlLockHeap((PVOID)&HeapHandle);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlLockHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLockHeap\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlUnlockHeap(
    IN  PVOID  HeapHandle  );

*/
void EmuApi::EmuRtlUnlockHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);


    BOOLEAN RtlUnlockHeapResult = RtlUnlockHeap((PVOID)&HeapHandle);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlUnlockHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnlockHeap\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlReAllocateHeap(
    IN  PVOID   HeapHandle   ,
    IN  ULONG   Flags        ,
    IN  PVOID   BaseAddress  ,
    IN  SIZE_T  Size         );

*/
void EmuApi::EmuRtlReAllocateHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    SIZE_T Size{};
    uc_reg_read(uc, UC_X86_REG_R9, &Size);


    PVOID RtlReAllocateHeapResult = RtlReAllocateHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&BaseAddress,(SIZE_T)Size);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlReAllocateHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R9, &Size);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlReAllocateHeap\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlGetUserInfoHeap(
    IN           PVOID    HeapHandle   ,
    IN           ULONG    Flags        ,
    IN           PVOID    BaseAddress  ,
    OUTOPTIONAL  PVOID *  UserValue    ,
    OUTOPTIONAL  PULONG   UserFlags    );

*/
void EmuApi::EmuRtlGetUserInfoHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    PVOID * UserValue{};
    uc_reg_read(uc, UC_X86_REG_R9, &UserValue);

    PVOID * dpUserValue{};

    if(UserValue != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserValue, &dpUserValue, sizeof(dpUserValue));
    }

    PULONG UserFlags{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &UserFlags, sizeof(UserFlags));

    ULONG rlUserFlags{};

    if(UserFlags != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserFlags, &rlUserFlags, sizeof(rlUserFlags));
    }


    BOOLEAN RtlGetUserInfoHeapResult = RtlGetUserInfoHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&BaseAddress,(PVOID *)&dpUserValue,(PULONG)&rlUserFlags);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlGetUserInfoHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R9, &UserValue);

    if(UserValue != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserValue, &dpUserValue, sizeof(dpUserValue));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &UserFlags, sizeof(UserFlags));

    if(UserFlags != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserFlags, &rlUserFlags, sizeof(rlUserFlags));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetUserInfoHeap\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlSetUserValueHeap(
    IN  PVOID  HeapHandle   ,
    IN  ULONG  Flags        ,
    IN  PVOID  BaseAddress  ,
    IN  PVOID  UserValue    );

*/
void EmuApi::EmuRtlSetUserValueHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    PVOID UserValue{};
    uc_reg_read(uc, UC_X86_REG_R9, &UserValue);


    BOOLEAN RtlSetUserValueHeapResult = RtlSetUserValueHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&BaseAddress,(PVOID)&UserValue);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlSetUserValueHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R9, &UserValue);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetUserValueHeap\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlSetUserFlagsHeap(
    IN  PVOID  HeapHandle      ,
    IN  ULONG  Flags           ,
    IN  PVOID  BaseAddress     ,
    IN  ULONG  UserFlagsReset  ,
    IN  ULONG  UserFlagsSet    );

*/
void EmuApi::EmuRtlSetUserFlagsHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    ULONG UserFlagsReset{};
    uc_reg_read(uc, UC_X86_REG_R9D, &UserFlagsReset);

    ULONG UserFlagsSet{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &UserFlagsSet, sizeof(UserFlagsSet));


    BOOLEAN RtlSetUserFlagsHeapResult = RtlSetUserFlagsHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&BaseAddress,(ULONG)UserFlagsReset,(ULONG)UserFlagsSet);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlSetUserFlagsHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R9D, &UserFlagsReset);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &UserFlagsSet, sizeof(UserFlagsSet));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetUserFlagsHeap\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlCreateTagHeap(
    IN          PVOID  HeapHandle  ,
    IN          ULONG  Flags       ,
    INOPTIONAL  PWSTR  TagPrefix   ,
    IN          PWSTR  TagNames    );

*/
void EmuApi::EmuRtlCreateTagHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PWSTR TagPrefix{};
    uc_reg_read(uc, UC_X86_REG_R8, &TagPrefix);

    std::wstring rlwTagPrefix;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TagPrefix, rlwTagPrefix)) { printf("Error when read TagPrefix in RtlCreateTagHeap"); _CrtDbgBreak(); }

    PWSTR TagNames{};
    uc_reg_read(uc, UC_X86_REG_R9, &TagNames);

    std::wstring rlwTagNames;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)TagNames, rlwTagNames)) { printf("Error when read TagNames in RtlCreateTagHeap"); _CrtDbgBreak(); }


    ULONG RtlCreateTagHeapResult = RtlCreateTagHeap((PVOID)&HeapHandle,(ULONG)Flags,(PWSTR)rlwTagPrefix.data(),(PWSTR)rlwTagNames.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateTagHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TagPrefix, rlwTagPrefix)) { printf("Error when read TagPrefix in RtlCreateTagHeap"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)TagNames, rlwTagNames)) { printf("Error when read TagNames in RtlCreateTagHeap"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateTagHeap\n";
    #endif

    return;
}


/*
PWSTR
__cdecl
RtlQueryTagHeap(
    IN           PVOID               HeapHandle     ,
    IN           ULONG               Flags          ,
    IN           USHORT              TagIndex       ,
    IN           BOOLEAN             ResetCounters  ,
    OUTOPTIONAL  PRTL_HEAP_TAG_INFO  TagInfo        );

*/
void EmuApi::EmuRtlQueryTagHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    USHORT TagIndex{};
    uc_reg_read(uc, UC_X86_REG_R8W, &TagIndex);

    BOOLEAN ResetCounters{};
    uc_reg_read(uc, UC_X86_REG_R9B, &ResetCounters);

    PRTL_HEAP_TAG_INFO TagInfo{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TagInfo, sizeof(TagInfo));

    RTL_HEAP_TAG_INFO stTagInfo{};

    if(TagInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TagInfo, &stTagInfo, sizeof(stTagInfo));
    }


    PWSTR RtlQueryTagHeapResult = RtlQueryTagHeap((PVOID)&HeapHandle,(ULONG)Flags,(USHORT)TagIndex,(BOOLEAN)ResetCounters,(PRTL_HEAP_TAG_INFO)&stTagInfo);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlQueryTagHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8W, &TagIndex);
    uc_reg_write(uc, UC_X86_REG_R9B, &ResetCounters);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TagInfo, sizeof(TagInfo));

    if(TagInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TagInfo, &stTagInfo, sizeof(stTagInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryTagHeap\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlExtendHeap(
    IN  PVOID   HeapHandle  ,
    IN  ULONG   Flags       ,
    IN  PVOID   Base        ,
    IN  SIZE_T  Size        );

*/
void EmuApi::EmuRtlExtendHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID Base{};
    uc_reg_read(uc, UC_X86_REG_R8, &Base);

    SIZE_T Size{};
    uc_reg_read(uc, UC_X86_REG_R9, &Size);


    NTSTATUS RtlExtendHeapResult = RtlExtendHeap((PVOID)&HeapHandle,(ULONG)Flags,(PVOID)&Base,(SIZE_T)Size);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlExtendHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &Base);
    uc_reg_write(uc, UC_X86_REG_R9, &Size);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlExtendHeap\n";
    #endif

    return;
}


/*
SIZE_T
__cdecl
RtlCompactHeap(
    IN  PVOID  HeapHandle  ,
    IN  ULONG  Flags       );

*/
void EmuApi::EmuRtlCompactHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);


    SIZE_T RtlCompactHeapResult = RtlCompactHeap((PVOID)&HeapHandle,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlCompactHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCompactHeap\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlValidateProcessHeaps(VOID);

*/
void EmuApi::EmuRtlValidateProcessHeaps(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    BOOLEAN RtlValidateProcessHeapsResult = RtlValidateProcessHeaps();


    uc_reg_write(uc, UC_X86_REG_AL, &RtlValidateProcessHeapsResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlValidateProcessHeaps\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlGetProcessHeaps(
    IN   ULONG    NumberOfHeaps  ,
    OUT  PVOID *  ProcessHeaps   );

*/
void EmuApi::EmuRtlGetProcessHeaps(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG NumberOfHeaps{};
    uc_reg_read(uc, UC_X86_REG_ECX, &NumberOfHeaps);

    PVOID * ProcessHeaps{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcessHeaps);

    PVOID * dpProcessHeaps{};

    if(ProcessHeaps != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHeaps, &dpProcessHeaps, sizeof(dpProcessHeaps));
    }


    ULONG RtlGetProcessHeapsResult = RtlGetProcessHeaps((ULONG)NumberOfHeaps,(PVOID *)&dpProcessHeaps);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetProcessHeapsResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &NumberOfHeaps);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcessHeaps);

    if(ProcessHeaps != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHeaps, &dpProcessHeaps, sizeof(dpProcessHeaps));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetProcessHeaps\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUsageHeap(
    IN     PVOID            HeapHandle  ,
    IN     ULONG            Flags       ,
    INOUT  PRTL_HEAP_USAGE  Usage       );

*/
void EmuApi::EmuRtlUsageHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PRTL_HEAP_USAGE Usage{};
    uc_reg_read(uc, UC_X86_REG_R8, &Usage);

    RTL_HEAP_USAGE stUsage{};

    if(Usage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Usage, &stUsage, sizeof(stUsage));
    }


    NTSTATUS RtlUsageHeapResult = RtlUsageHeap((PVOID)&HeapHandle,(ULONG)Flags,(PRTL_HEAP_USAGE)&stUsage);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUsageHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &Usage);

    if(Usage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Usage, &stUsage, sizeof(stUsage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUsageHeap\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlWalkHeap(
    IN     PVOID                 HeapHandle  ,
    INOUT  PRTL_HEAP_WALK_ENTRY  Entry       );

*/
void EmuApi::EmuRtlWalkHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    PRTL_HEAP_WALK_ENTRY Entry{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Entry);

    RTL_HEAP_WALK_ENTRY stEntry{};

    if(Entry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Entry, &stEntry, sizeof(stEntry));
    }


    NTSTATUS RtlWalkHeapResult = RtlWalkHeap((PVOID)&HeapHandle,(PRTL_HEAP_WALK_ENTRY)&stEntry);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlWalkHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Entry);

    if(Entry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Entry, &stEntry, sizeof(stEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlWalkHeap\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlMultipleAllocateHeap(
    IN   PVOID    HeapHandle  ,
    IN   ULONG    Flags       ,
    IN   SIZE_T   Size        ,
    IN   ULONG    Count       ,
    OUT  PVOID *  Array       );

*/
void EmuApi::EmuRtlMultipleAllocateHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    SIZE_T Size{};
    uc_reg_read(uc, UC_X86_REG_R8, &Size);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Count);

    PVOID * Array{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Array, sizeof(Array));

    PVOID * dpArray{};

    if(Array != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Array, &dpArray, sizeof(dpArray));
    }


    ULONG RtlMultipleAllocateHeapResult = RtlMultipleAllocateHeap((PVOID)&HeapHandle,(ULONG)Flags,(SIZE_T)Size,(ULONG)Count,(PVOID *)&dpArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlMultipleAllocateHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &Size);
    uc_reg_write(uc, UC_X86_REG_R9D, &Count);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Array, sizeof(Array));

    if(Array != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Array, &dpArray, sizeof(dpArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlMultipleAllocateHeap\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlMultipleFreeHeap(
    IN  PVOID    HeapHandle  ,
    IN  ULONG    Flags       ,
    IN  ULONG    Count       ,
    IN  PVOID *  Array       );

*/
void EmuApi::EmuRtlMultipleFreeHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID HeapHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HeapHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Count);

    PVOID * Array{};
    uc_reg_read(uc, UC_X86_REG_R9, &Array);

    PVOID * dpArray{};

    if(Array != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Array, &dpArray, sizeof(dpArray));
    }


    ULONG RtlMultipleFreeHeapResult = RtlMultipleFreeHeap((PVOID)&HeapHandle,(ULONG)Flags,(ULONG)Count,(PVOID *)&dpArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlMultipleFreeHeapResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HeapHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8D, &Count);
    uc_reg_write(uc, UC_X86_REG_R9, &Array);

    if(Array != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Array, &dpArray, sizeof(dpArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlMultipleFreeHeap\n";
    #endif

    return;
}


/*
void
__cdecl
RtlDetectHeapLeaks(VOID);

*/
void EmuApi::EmuRtlDetectHeapLeaks(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    RtlDetectHeapLeaks();


    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDetectHeapLeaks\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateMemoryZone(
    OUT  PVOID *  MemoryZone   ,
    IN   SIZE_T   InitialSize  ,
         ULONG    Flags        );

*/
void EmuApi::EmuRtlCreateMemoryZone(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * MemoryZone{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryZone);

    PVOID * dpMemoryZone{};

    if(MemoryZone != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MemoryZone, &dpMemoryZone, sizeof(dpMemoryZone));
    }

    SIZE_T InitialSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &InitialSize);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS RtlCreateMemoryZoneResult = RtlCreateMemoryZone((PVOID *)&dpMemoryZone,(SIZE_T)InitialSize,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateMemoryZoneResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryZone);

    if(MemoryZone != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MemoryZone, &dpMemoryZone, sizeof(dpMemoryZone));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &InitialSize);
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateMemoryZone\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyMemoryZone(
    IN  PVOID  MemoryZone  );

*/
void EmuApi::EmuRtlDestroyMemoryZone(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryZone{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryZone);


    NTSTATUS RtlDestroyMemoryZoneResult = RtlDestroyMemoryZone((PVOID)&MemoryZone);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyMemoryZoneResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryZone);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyMemoryZone\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAllocateMemoryZone(
    IN   PVOID    MemoryZone  ,
    IN   SIZE_T   BlockSize   ,
    OUT  PVOID *  Block       );

*/
void EmuApi::EmuRtlAllocateMemoryZone(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryZone{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryZone);

    SIZE_T BlockSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BlockSize);

    PVOID * Block{};
    uc_reg_read(uc, UC_X86_REG_R8, &Block);

    PVOID * dpBlock{};

    if(Block != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Block, &dpBlock, sizeof(dpBlock));
    }


    NTSTATUS RtlAllocateMemoryZoneResult = RtlAllocateMemoryZone((PVOID)&MemoryZone,(SIZE_T)BlockSize,(PVOID *)&dpBlock);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAllocateMemoryZoneResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryZone);
    uc_reg_write(uc, UC_X86_REG_RDX, &BlockSize);
    uc_reg_write(uc, UC_X86_REG_R8, &Block);

    if(Block != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Block, &dpBlock, sizeof(dpBlock));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAllocateMemoryZone\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlResetMemoryZone(
    IN  PVOID  MemoryZone  );

*/
void EmuApi::EmuRtlResetMemoryZone(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryZone{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryZone);


    NTSTATUS RtlResetMemoryZoneResult = RtlResetMemoryZone((PVOID)&MemoryZone);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlResetMemoryZoneResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryZone);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlResetMemoryZone\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLockMemoryZone(
    IN  PVOID  MemoryZone  );

*/
void EmuApi::EmuRtlLockMemoryZone(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryZone{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryZone);


    NTSTATUS RtlLockMemoryZoneResult = RtlLockMemoryZone((PVOID)&MemoryZone);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLockMemoryZoneResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryZone);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLockMemoryZone\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnlockMemoryZone(
    IN  PVOID  MemoryZone  );

*/
void EmuApi::EmuRtlUnlockMemoryZone(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryZone{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryZone);


    NTSTATUS RtlUnlockMemoryZoneResult = RtlUnlockMemoryZone((PVOID)&MemoryZone);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnlockMemoryZoneResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryZone);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnlockMemoryZone\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateMemoryBlockLookaside(
    OUT  PVOID *  MemoryBlockLookaside  ,
    IN   ULONG    Flags                 ,
    IN   ULONG    InitialSize           ,
    IN   ULONG    MinimumBlockSize      ,
    IN   ULONG    MaximumBlockSize      );

*/
void EmuApi::EmuRtlCreateMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);

    PVOID * dpMemoryBlockLookaside{};

    if(MemoryBlockLookaside != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MemoryBlockLookaside, &dpMemoryBlockLookaside, sizeof(dpMemoryBlockLookaside));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    ULONG InitialSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InitialSize);

    ULONG MinimumBlockSize{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MinimumBlockSize);

    ULONG MaximumBlockSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaximumBlockSize, sizeof(MaximumBlockSize));


    NTSTATUS RtlCreateMemoryBlockLookasideResult = RtlCreateMemoryBlockLookaside((PVOID *)&dpMemoryBlockLookaside,(ULONG)Flags,(ULONG)InitialSize,(ULONG)MinimumBlockSize,(ULONG)MaximumBlockSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);

    if(MemoryBlockLookaside != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MemoryBlockLookaside, &dpMemoryBlockLookaside, sizeof(dpMemoryBlockLookaside));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8D, &InitialSize);
    uc_reg_write(uc, UC_X86_REG_R9D, &MinimumBlockSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaximumBlockSize, sizeof(MaximumBlockSize));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyMemoryBlockLookaside(
    IN  PVOID  MemoryBlockLookaside  );

*/
void EmuApi::EmuRtlDestroyMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);


    NTSTATUS RtlDestroyMemoryBlockLookasideResult = RtlDestroyMemoryBlockLookaside((PVOID)&MemoryBlockLookaside);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAllocateMemoryBlockLookaside(
    IN   PVOID    MemoryBlockLookaside  ,
    IN   ULONG    BlockSize             ,
    OUT  PVOID *  Block                 );

*/
void EmuApi::EmuRtlAllocateMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);

    ULONG BlockSize{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BlockSize);

    PVOID * Block{};
    uc_reg_read(uc, UC_X86_REG_R8, &Block);

    PVOID * dpBlock{};

    if(Block != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Block, &dpBlock, sizeof(dpBlock));
    }


    NTSTATUS RtlAllocateMemoryBlockLookasideResult = RtlAllocateMemoryBlockLookaside((PVOID)&MemoryBlockLookaside,(ULONG)BlockSize,(PVOID *)&dpBlock);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAllocateMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    uc_reg_write(uc, UC_X86_REG_EDX, &BlockSize);
    uc_reg_write(uc, UC_X86_REG_R8, &Block);

    if(Block != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Block, &dpBlock, sizeof(dpBlock));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAllocateMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlFreeMemoryBlockLookaside(
      PVOID  MemoryBlockLookaside  ,
      PVOID  Block                 );

*/
void EmuApi::EmuRtlFreeMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);

    PVOID Block{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Block);


    NTSTATUS RtlFreeMemoryBlockLookasideResult = RtlFreeMemoryBlockLookaside((PVOID)&MemoryBlockLookaside,(PVOID)&Block);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFreeMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    uc_reg_write(uc, UC_X86_REG_RDX, &Block);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlExtendMemoryBlockLookaside(
    IN  PVOID  MemoryBlockLookaside  ,
    IN  ULONG  Increment             );

*/
void EmuApi::EmuRtlExtendMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);

    ULONG Increment{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Increment);


    NTSTATUS RtlExtendMemoryBlockLookasideResult = RtlExtendMemoryBlockLookaside((PVOID)&MemoryBlockLookaside,(ULONG)Increment);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlExtendMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    uc_reg_write(uc, UC_X86_REG_EDX, &Increment);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlExtendMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlResetMemoryBlockLookaside(
    IN  PVOID  MemoryBlockLookaside  );

*/
void EmuApi::EmuRtlResetMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);


    NTSTATUS RtlResetMemoryBlockLookasideResult = RtlResetMemoryBlockLookaside((PVOID)&MemoryBlockLookaside);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlResetMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlResetMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLockMemoryBlockLookaside(
    IN  PVOID  MemoryBlockLookaside  );

*/
void EmuApi::EmuRtlLockMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);


    NTSTATUS RtlLockMemoryBlockLookasideResult = RtlLockMemoryBlockLookaside((PVOID)&MemoryBlockLookaside);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLockMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLockMemoryBlockLookaside\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnlockMemoryBlockLookaside(
    IN  PVOID  MemoryBlockLookaside  );

*/
void EmuApi::EmuRtlUnlockMemoryBlockLookaside(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID MemoryBlockLookaside{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);


    NTSTATUS RtlUnlockMemoryBlockLookasideResult = RtlUnlockMemoryBlockLookaside((PVOID)&MemoryBlockLookaside);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnlockMemoryBlockLookasideResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MemoryBlockLookaside);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnlockMemoryBlockLookaside\n";
    #endif

    return;
}


/*
HANDLE
__cdecl
RtlGetCurrentTransaction(VOID);

*/
void EmuApi::EmuRtlGetCurrentTransaction(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    HANDLE RtlGetCurrentTransactionResult = RtlGetCurrentTransaction();


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlGetCurrentTransactionResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCurrentTransaction\n";
    #endif

    return;
}


/*
LOGICAL
__cdecl
RtlSetCurrentTransaction(
    IN  HANDLE  TransactionHandle  );

*/
void EmuApi::EmuRtlSetCurrentTransaction(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TransactionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TransactionHandle);


    LOGICAL RtlSetCurrentTransactionResult = RtlSetCurrentTransaction((HANDLE)TransactionHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetCurrentTransactionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TransactionHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetCurrentTransaction\n";
    #endif

    return;
}


/*
PRTL_DEBUG_INFORMATION
__cdecl
RtlCreateQueryDebugBuffer(
    INOPTIONAL  ULONG    MaximumCommit  ,
    IN          BOOLEAN  UseEventPair   );

*/
void EmuApi::EmuRtlCreateQueryDebugBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG MaximumCommit{};
    uc_reg_read(uc, UC_X86_REG_ECX, &MaximumCommit);

    BOOLEAN UseEventPair{};
    uc_reg_read(uc, UC_X86_REG_DL, &UseEventPair);


    PRTL_DEBUG_INFORMATION RtlCreateQueryDebugBufferResult = RtlCreateQueryDebugBuffer((ULONG)MaximumCommit,(BOOLEAN)UseEventPair);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlCreateQueryDebugBufferResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &MaximumCommit);
    uc_reg_write(uc, UC_X86_REG_DL, &UseEventPair);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateQueryDebugBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyQueryDebugBuffer(
    IN  PRTL_DEBUG_INFORMATION  Buffer  );

*/
void EmuApi::EmuRtlDestroyQueryDebugBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_DEBUG_INFORMATION Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    RTL_DEBUG_INFORMATION stBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }


    NTSTATUS RtlDestroyQueryDebugBufferResult = RtlDestroyQueryDebugBuffer((PRTL_DEBUG_INFORMATION)&stBuffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyQueryDebugBufferResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyQueryDebugBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryProcessDebugInformation(
    IN     HANDLE                  UniqueProcessId  ,
    IN     ULONG                   Flags            ,
    INOUT  PRTL_DEBUG_INFORMATION  Buffer           );

*/
void EmuApi::EmuRtlQueryProcessDebugInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE UniqueProcessId{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UniqueProcessId);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PRTL_DEBUG_INFORMATION Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    RTL_DEBUG_INFORMATION stBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }


    NTSTATUS RtlQueryProcessDebugInformationResult = RtlQueryProcessDebugInformation((HANDLE)UniqueProcessId,(ULONG)Flags,(PRTL_DEBUG_INFORMATION)&stBuffer);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryProcessDebugInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &UniqueProcessId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryProcessDebugInformation\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlUniform(
      PULONG  Seed  );

*/
void EmuApi::EmuRtlUniform(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Seed{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Seed);

    ULONG rlSeed{};

    if(Seed != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Seed, &rlSeed, sizeof(rlSeed));
    }


    ULONG RtlUniformResult = RtlUniform((PULONG)&rlSeed);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUniformResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Seed);

    if(Seed != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Seed, &rlSeed, sizeof(rlSeed));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUniform\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlComputeImportTableHash(
    IN   HANDLE  hFile                    ,
    OUT  PCHAR   Hash                     ,
    IN   ULONG   ImportTableHashRevision  );

*/
void EmuApi::EmuRtlComputeImportTableHash(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE hFile{};
    uc_reg_read(uc, UC_X86_REG_RCX, &hFile);

    PCHAR Hash{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Hash);

    std::string rlaHash;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Hash, rlaHash)) { printf("Error when read Hash in RtlComputeImportTableHash"); _CrtDbgBreak(); }

    ULONG ImportTableHashRevision{};
    uc_reg_read(uc, UC_X86_REG_R8D, &ImportTableHashRevision);


    NTSTATUS RtlComputeImportTableHashResult = RtlComputeImportTableHash((HANDLE)hFile,(PCHAR)rlaHash.data(),(ULONG)ImportTableHashRevision);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlComputeImportTableHashResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &hFile);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Hash, rlaHash)) { printf("Error when read Hash in RtlComputeImportTableHash"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &ImportTableHashRevision);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlComputeImportTableHash\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIntegerToChar(
      ULONG  Value         ,
      ULONG  Base          ,
      LONG   OutputLength  ,
      PSZ    String        );

*/
void EmuApi::EmuRtlIntegerToChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Value{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Value);

    ULONG Base{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Base);

    LONG OutputLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &OutputLength);

    PSZ String{};
    uc_reg_read(uc, UC_X86_REG_R9, &String);

    std::string rlaString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)String, rlaString)) { printf("Error when read String in RtlIntegerToChar"); _CrtDbgBreak(); }


    NTSTATUS RtlIntegerToCharResult = RtlIntegerToChar((ULONG)Value,(ULONG)Base,(LONG)OutputLength,(PSZ)rlaString.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIntegerToCharResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Value);
    uc_reg_write(uc, UC_X86_REG_EDX, &Base);
    uc_reg_write(uc, UC_X86_REG_R8D, &OutputLength);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)String, rlaString)) { printf("Error when read String in RtlIntegerToChar"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIntegerToChar\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLargeIntegerToChar(
       PLARGE_INTEGER  Value         ,
       ULONG           Base          ,
    ,  LONG            OutputLength  ,
       PSZ             String        );

*/
void EmuApi::EmuRtlLargeIntegerToChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER Value{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Value);

    LARGE_INTEGER rlValue{};

    if(Value != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Value, &rlValue, sizeof(rlValue));
    }

    ULONG Base{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Base);

    LONG OutputLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &OutputLength);

    PSZ String{};
    uc_reg_read(uc, UC_X86_REG_R9, &String);

    std::string rlaString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)String, rlaString)) { printf("Error when read String in RtlLargeIntegerToChar"); _CrtDbgBreak(); }


    NTSTATUS RtlLargeIntegerToCharResult = RtlLargeIntegerToChar((PLARGE_INTEGER)&rlValue,(ULONG)Base,(LONG)OutputLength,(PSZ)rlaString.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLargeIntegerToCharResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Value);

    if(Value != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Value, &rlValue, sizeof(rlValue));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Base);
    uc_reg_write(uc, UC_X86_REG_R8D, &OutputLength);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)String, rlaString)) { printf("Error when read String in RtlLargeIntegerToChar"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLargeIntegerToChar\n";
    #endif

    return;
}


/*
PSTR
__cdecl
RtlIpv4AddressToStringA(
    IN   const struct in_addr *  Addr  ,
    OUT  PSTR                    S     );

*/
void EmuApi::EmuRtlIpv4AddressToStringA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Addr);

    IN_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }

    PSTR S{};
    uc_reg_read(uc, UC_X86_REG_RDX, &S);

    std::string rlaS;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv4AddressToStringA"); _CrtDbgBreak(); }


    PSTR RtlIpv4AddressToStringAResult = RtlIpv4AddressToStringA((const struct in_addr *)&stAddr,(PSTR)rlaS.data());


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlIpv4AddressToStringAResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv4AddressToStringA"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4AddressToStringA\n";
    #endif

    return;
}


/*
PSTR
__cdecl
RtlIpv6AddressToStringA(
    IN   const struct in6_addr *  Addr  ,
    OUT  PSTR                     S     );

*/
void EmuApi::EmuRtlIpv6AddressToStringA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN6_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Addr);

    IN6_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }

    PSTR S{};
    uc_reg_read(uc, UC_X86_REG_RDX, &S);

    std::string rlaS;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv6AddressToStringA"); _CrtDbgBreak(); }


    PSTR RtlIpv6AddressToStringAResult = RtlIpv6AddressToStringA((const struct in6_addr *)&stAddr,(PSTR)rlaS.data());


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlIpv6AddressToStringAResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv6AddressToStringA"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6AddressToStringA\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv4AddressToStringExA(
    IN     const struct in_addr *  Address              ,
    IN     USHORT                  Port                 ,
    OUT    PSTR                    AddressString        ,
    INOUT  PULONG                  AddressStringLength  );

*/
void EmuApi::EmuRtlIpv4AddressToStringExA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Address);

    IN_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    USHORT Port{};
    uc_reg_read(uc, UC_X86_REG_DX, &Port);

    PSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_R8, &AddressString);

    std::string rlaAddressString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv4AddressToStringExA"); _CrtDbgBreak(); }

    PULONG AddressStringLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &AddressStringLength);

    ULONG rlAddressStringLength{};

    if(AddressStringLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }


    NTSTATUS RtlIpv4AddressToStringExAResult = RtlIpv4AddressToStringExA((const struct in_addr *)&stAddress,(USHORT)Port,(PSTR)rlaAddressString.data(),(PULONG)&rlAddressStringLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv4AddressToStringExAResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_DX, &Port);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv4AddressToStringExA"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &AddressStringLength);

    if(AddressStringLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4AddressToStringExA\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv6AddressToStringExA(
    IN     const struct in6_addr *  Address              ,
    IN     ULONG                    ScopeId              ,
    IN     USHORT                   Port                 ,
    OUT    PSTR                     AddressString        ,
    INOUT  PULONG                   AddressStringLength  );

*/
void EmuApi::EmuRtlIpv6AddressToStringExA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN6_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Address);

    IN6_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    ULONG ScopeId{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ScopeId);

    USHORT Port{};
    uc_reg_read(uc, UC_X86_REG_R8W, &Port);

    PSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_R9, &AddressString);

    std::string rlaAddressString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv6AddressToStringExA"); _CrtDbgBreak(); }

    PULONG AddressStringLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AddressStringLength, sizeof(AddressStringLength));

    ULONG rlAddressStringLength{};

    if(AddressStringLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }


    NTSTATUS RtlIpv6AddressToStringExAResult = RtlIpv6AddressToStringExA((const struct in6_addr *)&stAddress,(ULONG)ScopeId,(USHORT)Port,(PSTR)rlaAddressString.data(),(PULONG)&rlAddressStringLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv6AddressToStringExAResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &ScopeId);
    uc_reg_write(uc, UC_X86_REG_R8W, &Port);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv6AddressToStringExA"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AddressStringLength, sizeof(AddressStringLength));

    if(AddressStringLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6AddressToStringExA\n";
    #endif

    return;
}


/*
PWSTR
__cdecl
RtlIpv4AddressToStringW(
    IN   const struct in_addr *  Addr  ,
    OUT  PWSTR                   S     );

*/
void EmuApi::EmuRtlIpv4AddressToStringW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Addr);

    IN_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }

    PWSTR S{};
    uc_reg_read(uc, UC_X86_REG_RDX, &S);

    std::wstring rlwS;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv4AddressToStringW"); _CrtDbgBreak(); }


    PWSTR RtlIpv4AddressToStringWResult = RtlIpv4AddressToStringW((const struct in_addr *)&stAddr,(PWSTR)rlwS.data());


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlIpv4AddressToStringWResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv4AddressToStringW"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4AddressToStringW\n";
    #endif

    return;
}


/*
PWSTR
__cdecl
RtlIpv6AddressToStringW(
    IN   const struct in6_addr *  Addr  ,
    OUT  PWSTR                    S     );

*/
void EmuApi::EmuRtlIpv6AddressToStringW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN6_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Addr);

    IN6_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }

    PWSTR S{};
    uc_reg_read(uc, UC_X86_REG_RDX, &S);

    std::wstring rlwS;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv6AddressToStringW"); _CrtDbgBreak(); }


    PWSTR RtlIpv6AddressToStringWResult = RtlIpv6AddressToStringW((const struct in6_addr *)&stAddr,(PWSTR)rlwS.data());


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlIpv6AddressToStringWResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv6AddressToStringW"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6AddressToStringW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv4AddressToStringExW(
    IN     const struct in_addr *  Address              ,
    IN     USHORT                  Port                 ,
    OUT    PWSTR                   AddressString        ,
    INOUT  PULONG                  AddressStringLength  );

*/
void EmuApi::EmuRtlIpv4AddressToStringExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Address);

    IN_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    USHORT Port{};
    uc_reg_read(uc, UC_X86_REG_DX, &Port);

    PWSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_R8, &AddressString);

    std::wstring rlwAddressString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv4AddressToStringExW"); _CrtDbgBreak(); }

    PULONG AddressStringLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &AddressStringLength);

    ULONG rlAddressStringLength{};

    if(AddressStringLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }


    NTSTATUS RtlIpv4AddressToStringExWResult = RtlIpv4AddressToStringExW((const struct in_addr *)&stAddress,(USHORT)Port,(PWSTR)rlwAddressString.data(),(PULONG)&rlAddressStringLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv4AddressToStringExWResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_DX, &Port);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv4AddressToStringExW"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &AddressStringLength);

    if(AddressStringLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4AddressToStringExW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv6AddressToStringExW(
    IN     const struct in6_addr *  Address              ,
    IN     ULONG                    ScopeId              ,
    IN     USHORT                   Port                 ,
    OUT    PWSTR                    AddressString        ,
    INOUT  PULONG                   AddressStringLength  );

*/
void EmuApi::EmuRtlIpv6AddressToStringExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIN6_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Address);

    IN6_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    ULONG ScopeId{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ScopeId);

    USHORT Port{};
    uc_reg_read(uc, UC_X86_REG_R8W, &Port);

    PWSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_R9, &AddressString);

    std::wstring rlwAddressString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv6AddressToStringExW"); _CrtDbgBreak(); }

    PULONG AddressStringLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AddressStringLength, sizeof(AddressStringLength));

    ULONG rlAddressStringLength{};

    if(AddressStringLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }


    NTSTATUS RtlIpv6AddressToStringExWResult = RtlIpv6AddressToStringExW((const struct in6_addr *)&stAddress,(ULONG)ScopeId,(USHORT)Port,(PWSTR)rlwAddressString.data(),(PULONG)&rlAddressStringLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv6AddressToStringExWResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &ScopeId);
    uc_reg_write(uc, UC_X86_REG_R8W, &Port);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv6AddressToStringExW"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AddressStringLength, sizeof(AddressStringLength));

    if(AddressStringLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AddressStringLength, &rlAddressStringLength, sizeof(rlAddressStringLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6AddressToStringExW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv4StringToAddressA(
    IN   PCSTR             S           ,
    IN   BOOLEAN           Strict      ,
    OUT  PCSTR *           Terminator  ,
    OUT  struct in_addr *  Addr        );

*/
void EmuApi::EmuRtlIpv4StringToAddressA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTR S{};
    uc_reg_read(uc, UC_X86_REG_RCX, &S);

    std::string rlaS;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv4StringToAddressA"); _CrtDbgBreak(); }

    BOOLEAN Strict{};
    uc_reg_read(uc, UC_X86_REG_DL, &Strict);

    PSTR Terminator{};
    uc_reg_read(uc, UC_X86_REG_R8, &Terminator);

    PSTR dpTerminator{};

    if(Terminator != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Terminator, &dpTerminator, sizeof(dpTerminator));
    }

    std::string rlaTerminator;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Terminator, rlaTerminator)) { printf("Error when read Terminator in RtlIpv4StringToAddressA"); _CrtDbgBreak(); }

    PIN_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_R9, &Addr);

    IN_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }


    NTSTATUS RtlIpv4StringToAddressAResult = RtlIpv4StringToAddressA((PCSTR)rlaS.data(),(BOOLEAN)Strict,(PCSTR *)rlaTerminator.data(),(struct in_addr *)&stAddr);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv4StringToAddressAResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv4StringToAddressA"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_DL, &Strict);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Terminator, rlaTerminator)) { printf("Error when read Terminator in RtlIpv4StringToAddressA"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4StringToAddressA\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv6StringToAddressA(
    IN   PCSTR              S           ,
    OUT  PCSTR *            Terminator  ,
    OUT  struct in6_addr *  Addr        );

*/
void EmuApi::EmuRtlIpv6StringToAddressA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTR S{};
    uc_reg_read(uc, UC_X86_REG_RCX, &S);

    std::string rlaS;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv6StringToAddressA"); _CrtDbgBreak(); }

    PSTR Terminator{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Terminator);

    PSTR dpTerminator{};

    if(Terminator != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Terminator, &dpTerminator, sizeof(dpTerminator));
    }

    std::string rlaTerminator;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Terminator, rlaTerminator)) { printf("Error when read Terminator in RtlIpv6StringToAddressA"); _CrtDbgBreak(); }

    PIN6_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_R8, &Addr);

    IN6_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }


    NTSTATUS RtlIpv6StringToAddressAResult = RtlIpv6StringToAddressA((PCSTR)rlaS.data(),(PCSTR *)rlaTerminator.data(),(struct in6_addr *)&stAddr);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv6StringToAddressAResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)S, rlaS)) { printf("Error when read S in RtlIpv6StringToAddressA"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Terminator, rlaTerminator)) { printf("Error when read Terminator in RtlIpv6StringToAddressA"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6StringToAddressA\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv4StringToAddressExA(
    IN   PCSTR             AddressString  ,
    IN   BOOLEAN           Strict         ,
    OUT  struct in_addr *  Address        ,
    OUT  PUSHORT           Port           );

*/
void EmuApi::EmuRtlIpv4StringToAddressExA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AddressString);

    std::string rlaAddressString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv4StringToAddressExA"); _CrtDbgBreak(); }

    BOOLEAN Strict{};
    uc_reg_read(uc, UC_X86_REG_DL, &Strict);

    PIN_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_R8, &Address);

    IN_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    PUSHORT Port{};
    uc_reg_read(uc, UC_X86_REG_R9, &Port);

    USHORT rlPort{};

    if(Port != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }


    NTSTATUS RtlIpv4StringToAddressExAResult = RtlIpv4StringToAddressExA((PCSTR)rlaAddressString.data(),(BOOLEAN)Strict,(struct in_addr *)&stAddress,(PUSHORT)&rlPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv4StringToAddressExAResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv4StringToAddressExA"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_DL, &Strict);
    uc_reg_write(uc, UC_X86_REG_R8, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Port);

    if(Port != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4StringToAddressExA\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv6StringToAddressExA(
    IN   PCSTR              AddressString  ,
    OUT  struct in6_addr *  Address        ,
    OUT  PULONG             ScopeId        ,
    OUT  PUSHORT            Port           );

*/
void EmuApi::EmuRtlIpv6StringToAddressExA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AddressString);

    std::string rlaAddressString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv6StringToAddressExA"); _CrtDbgBreak(); }

    PIN6_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Address);

    IN6_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    PULONG ScopeId{};
    uc_reg_read(uc, UC_X86_REG_R8, &ScopeId);

    ULONG rlScopeId{};

    if(ScopeId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ScopeId, &rlScopeId, sizeof(rlScopeId));
    }

    PUSHORT Port{};
    uc_reg_read(uc, UC_X86_REG_R9, &Port);

    USHORT rlPort{};

    if(Port != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }


    NTSTATUS RtlIpv6StringToAddressExAResult = RtlIpv6StringToAddressExA((PCSTR)rlaAddressString.data(),(struct in6_addr *)&stAddress,(PULONG)&rlScopeId,(PUSHORT)&rlPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv6StringToAddressExAResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)AddressString, rlaAddressString)) { printf("Error when read AddressString in RtlIpv6StringToAddressExA"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ScopeId);

    if(ScopeId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ScopeId, &rlScopeId, sizeof(rlScopeId));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Port);

    if(Port != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6StringToAddressExA\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv4StringToAddressW(
    IN   PCWSTR            S           ,
    IN   BOOLEAN           Strict      ,
    OUT  LPCWSTR *         Terminator  ,
    OUT  struct in_addr *  Addr        );

*/
void EmuApi::EmuRtlIpv4StringToAddressW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR S{};
    uc_reg_read(uc, UC_X86_REG_RCX, &S);

    std::wstring rlwS;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv4StringToAddressW"); _CrtDbgBreak(); }

    BOOLEAN Strict{};
    uc_reg_read(uc, UC_X86_REG_DL, &Strict);

    LPWSTR Terminator{};
    uc_reg_read(uc, UC_X86_REG_R8, &Terminator);

    LPWSTR dpTerminator{};

    if(Terminator != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Terminator, &dpTerminator, sizeof(dpTerminator));
    }

    std::wstring rlwTerminator;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Terminator, rlwTerminator)) { printf("Error when read Terminator in RtlIpv4StringToAddressW"); _CrtDbgBreak(); }

    PIN_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_R9, &Addr);

    IN_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }


    NTSTATUS RtlIpv4StringToAddressWResult = RtlIpv4StringToAddressW((PCWSTR)rlwS.data(),(BOOLEAN)Strict,(LPCWSTR *)rlwTerminator.data(),(struct in_addr *)&stAddr);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv4StringToAddressWResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv4StringToAddressW"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_DL, &Strict);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Terminator, rlwTerminator)) { printf("Error when read Terminator in RtlIpv4StringToAddressW"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4StringToAddressW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv6StringToAddressW(
    IN   PCWSTR             S           ,
    OUT  PCWSTR *           Terminator  ,
    OUT  struct in6_addr *  Addr        );

*/
void EmuApi::EmuRtlIpv6StringToAddressW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR S{};
    uc_reg_read(uc, UC_X86_REG_RCX, &S);

    std::wstring rlwS;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv6StringToAddressW"); _CrtDbgBreak(); }

    PWSTR Terminator{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Terminator);

    PWSTR dpTerminator{};

    if(Terminator != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Terminator, &dpTerminator, sizeof(dpTerminator));
    }

    std::wstring rlwTerminator;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Terminator, rlwTerminator)) { printf("Error when read Terminator in RtlIpv6StringToAddressW"); _CrtDbgBreak(); }

    PIN6_ADDR Addr{};
    uc_reg_read(uc, UC_X86_REG_R8, &Addr);

    IN6_ADDR stAddr{};

    if(Addr != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }


    NTSTATUS RtlIpv6StringToAddressWResult = RtlIpv6StringToAddressW((PCWSTR)rlwS.data(),(PCWSTR *)rlwTerminator.data(),(struct in6_addr *)&stAddr);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv6StringToAddressWResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)S, rlwS)) { printf("Error when read S in RtlIpv6StringToAddressW"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Terminator, rlwTerminator)) { printf("Error when read Terminator in RtlIpv6StringToAddressW"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &Addr);

    if(Addr != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Addr, &stAddr, sizeof(stAddr));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6StringToAddressW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv4StringToAddressExW(
    IN   PCWSTR            AddressString  ,
    IN   BOOLEAN           Strict         ,
    OUT  struct in_addr *  Address        ,
    OUT  PUSHORT           Port           );

*/
void EmuApi::EmuRtlIpv4StringToAddressExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AddressString);

    std::wstring rlwAddressString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv4StringToAddressExW"); _CrtDbgBreak(); }

    BOOLEAN Strict{};
    uc_reg_read(uc, UC_X86_REG_DL, &Strict);

    PIN_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_R8, &Address);

    IN_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    PUSHORT Port{};
    uc_reg_read(uc, UC_X86_REG_R9, &Port);

    USHORT rlPort{};

    if(Port != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }


    NTSTATUS RtlIpv4StringToAddressExWResult = RtlIpv4StringToAddressExW((PCWSTR)rlwAddressString.data(),(BOOLEAN)Strict,(struct in_addr *)&stAddress,(PUSHORT)&rlPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv4StringToAddressExWResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv4StringToAddressExW"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_DL, &Strict);
    uc_reg_write(uc, UC_X86_REG_R8, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Port);

    if(Port != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv4StringToAddressExW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIpv6StringToAddressExW(
    IN   PCWSTR             AddressString  ,
    OUT  struct in6_addr *  Address        ,
    OUT  PULONG             ScopeId        ,
    OUT  PUSHORT            Port           );

*/
void EmuApi::EmuRtlIpv6StringToAddressExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AddressString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AddressString);

    std::wstring rlwAddressString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv6StringToAddressExW"); _CrtDbgBreak(); }

    PIN6_ADDR Address{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Address);

    IN6_ADDR stAddress{};

    if(Address != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }

    PULONG ScopeId{};
    uc_reg_read(uc, UC_X86_REG_R8, &ScopeId);

    ULONG rlScopeId{};

    if(ScopeId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ScopeId, &rlScopeId, sizeof(rlScopeId));
    }

    PUSHORT Port{};
    uc_reg_read(uc, UC_X86_REG_R9, &Port);

    USHORT rlPort{};

    if(Port != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }


    NTSTATUS RtlIpv6StringToAddressExWResult = RtlIpv6StringToAddressExW((PCWSTR)rlwAddressString.data(),(struct in6_addr *)&stAddress,(PULONG)&rlScopeId,(PUSHORT)&rlPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIpv6StringToAddressExWResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AddressString, rlwAddressString)) { printf("Error when read AddressString in RtlIpv6StringToAddressExW"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &Address);

    if(Address != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Address, &stAddress, sizeof(stAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ScopeId);

    if(ScopeId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ScopeId, &rlScopeId, sizeof(rlScopeId));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Port);

    if(Port != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Port, &rlPort, sizeof(rlPort));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIpv6StringToAddressExW\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlIntegerToUnicodeString(
      ULONG            Value   ,
      ULONG            Base    ,
      PUNICODE_STRING  String  );

*/
void EmuApi::EmuRtlIntegerToUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Value{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Value);

    ULONG Base{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Base);

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_R8, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlIntegerToUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    NTSTATUS RtlIntegerToUnicodeStringResult = RtlIntegerToUnicodeString((ULONG)Value,(ULONG)Base,(PUNICODE_STRING)&stString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIntegerToUnicodeStringResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Value);
    uc_reg_write(uc, UC_X86_REG_EDX, &Base);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlIntegerToUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIntegerToUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlInt64ToUnicodeString(
    IN      ULONGLONG        Value   ,
    IN      ULONG            Base    ,
    ,INOUT  PUNICODE_STRING  String  );

*/
void EmuApi::EmuRtlInt64ToUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONGLONG Value{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Value);

    ULONG Base{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Base);

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_R8, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlInt64ToUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    NTSTATUS RtlInt64ToUnicodeStringResult = RtlInt64ToUnicodeString((ULONGLONG)Value,(ULONG)Base,(PUNICODE_STRING)&stString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlInt64ToUnicodeStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Value);
    uc_reg_write(uc, UC_X86_REG_EDX, &Base);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlInt64ToUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInt64ToUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeStringToInteger(
      PCUNICODE_STRING  String  ,
      ULONG             Base    ,
      PULONG            Value   );

*/
void EmuApi::EmuRtlUnicodeStringToInteger(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlUnicodeStringToInteger"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();

    ULONG Base{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Base);

    PULONG Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    ULONG rlValue{};

    if(Value != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Value, &rlValue, sizeof(rlValue));
    }


    NTSTATUS RtlUnicodeStringToIntegerResult = RtlUnicodeStringToInteger((PUNICODE_STRING)&stString,(ULONG)Base,(PULONG)&rlValue);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeStringToIntegerResult);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlUnicodeStringToInteger"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &Base);
    uc_reg_write(uc, UC_X86_REG_R8, &Value);

    if(Value != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Value, &rlValue, sizeof(rlValue));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeStringToInteger\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitString(
      PSTRING  DestinationString  ,
      PCSZ     SourceString       );

*/
void EmuApi::EmuRtlInitString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PSZ SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::string rlaSourceString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlInitString"); _CrtDbgBreak(); }


    RtlInitString((PSTRING)&rlDestinationString,(PCSZ)rlaSourceString.data());


    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlInitString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitAnsiString(
      PANSI_STRING  DestinationString  ,
      PCSZ          SourceString       );

*/
void EmuApi::EmuRtlInitAnsiString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PANSI_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PSZ SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::string rlaSourceString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlInitAnsiString"); _CrtDbgBreak(); }


    RtlInitAnsiString((PANSI_STRING)&rlDestinationString,(PCSZ)rlaSourceString.data());


    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlInitAnsiString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitAnsiString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlInitUnicodeString(
      PUNICODE_STRING  DestinationString  ,
      PCWSTR           SourceString       );

*/
void EmuApi::EmuRtlInitUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlInitUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PWSTR SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString, rlwSourceString)) { printf("Error when read SourceString in RtlInitUnicodeString"); _CrtDbgBreak(); }


    RtlInitUnicodeString((PUNICODE_STRING)&stDestinationString,(PCWSTR)rlwSourceString.data());

    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlInitUnicodeString"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString, rlwSourceString)) { printf("Error when read SourceString in RtlInitUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlInitUnicodeStringEx(
      PUNICODE_STRING  DestinationString  ,
      PCWSTR           SourceString       );

*/
void EmuApi::EmuRtlInitUnicodeStringEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlInitUnicodeStringEx"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PWSTR SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString, rlwSourceString)) { printf("Error when read SourceString in RtlInitUnicodeStringEx"); _CrtDbgBreak(); }


    NTSTATUS RtlInitUnicodeStringExResult = RtlInitUnicodeStringEx((PUNICODE_STRING)&stDestinationString,(PCWSTR)rlwSourceString.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlInitUnicodeStringExResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlInitUnicodeStringEx"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString, rlwSourceString)) { printf("Error when read SourceString in RtlInitUnicodeStringEx"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitUnicodeStringEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlInitAnsiStringEx(
    OUT  PANSI_STRING  DestinationString  ,
    IN   PCSZ          SourceString       );

*/
void EmuApi::EmuRtlInitAnsiStringEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PANSI_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PSZ SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::string rlaSourceString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlInitAnsiStringEx"); _CrtDbgBreak(); }


    NTSTATUS RtlInitAnsiStringExResult = RtlInitAnsiStringEx((PANSI_STRING)&rlDestinationString,(PCSZ)rlaSourceString.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlInitAnsiStringExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlInitAnsiStringEx"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitAnsiStringEx\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlCreateUnicodeString(
    OUT  PUNICODE_STRING  DestinationString  ,
    IN   PCWSTR           SourceString       );

*/
void EmuApi::EmuRtlCreateUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlCreateUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PWSTR SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString, rlwSourceString)) { printf("Error when read SourceString in RtlCreateUnicodeString"); _CrtDbgBreak(); }


    BOOLEAN RtlCreateUnicodeStringResult = RtlCreateUnicodeString((PUNICODE_STRING)&stDestinationString,(PCWSTR)rlwSourceString.data());


    uc_reg_write(uc, UC_X86_REG_AL, &RtlCreateUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlCreateUnicodeString"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString, rlwSourceString)) { printf("Error when read SourceString in RtlCreateUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateUnicodeString\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlEqualDomainName(
    IN  PCUNICODE_STRING  String1  ,
    IN  PCUNICODE_STRING  String2  );

*/
void EmuApi::EmuRtlEqualDomainName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    std::wstring rlwString1;

    USHORT rlLengthString1;

    USHORT rlMaxLengthString1;
    uc_mem_read(uc, (DWORD_PTR)String1, &rlLengthString1, sizeof(rlLengthString1));
    uc_mem_read(uc, (DWORD_PTR)String1+16, &rlMaxLengthString1, sizeof(rlMaxLengthString1));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String1+64, rlwString1, true, rlLengthString1)) { printf("Error when read String1 in RtlEqualDomainName"); _CrtDbgBreak(); }

    UNICODE_STRING stString1{};
    stString1.Length = rlLengthString1;
    stString1.MaximumLength = rlMaxLengthString1;
    stString1.Buffer = rlwString1.data();

    PUNICODE_STRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    std::wstring rlwString2;

    USHORT rlLengthString2;

    USHORT rlMaxLengthString2;
    uc_mem_read(uc, (DWORD_PTR)String2, &rlLengthString2, sizeof(rlLengthString2));
    uc_mem_read(uc, (DWORD_PTR)String2+16, &rlMaxLengthString2, sizeof(rlMaxLengthString2));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String2+64, rlwString2, true, rlLengthString2)) { printf("Error when read String2 in RtlEqualDomainName"); _CrtDbgBreak(); }

    UNICODE_STRING stString2{};
    stString2.Length = rlLengthString2;
    stString2.MaximumLength = rlMaxLengthString2;
    stString2.Buffer = rlwString2.data();


    BOOLEAN RtlEqualDomainNameResult = RtlEqualDomainName((PUNICODE_STRING)&stString1,(PUNICODE_STRING)&stString2);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlEqualDomainNameResult);
    uc_mem_write(uc, (DWORD_PTR)String1, &stString1.Length, sizeof(stString1.Length));
    uc_mem_write(uc, (DWORD_PTR)String1+16, &stString1.MaximumLength, sizeof(stString1.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String1+64, stString1.Buffer, true, stString1.Length)) { printf("Error when read String1 in RtlEqualDomainName"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)String2, &stString2.Length, sizeof(stString2.Length));
    uc_mem_write(uc, (DWORD_PTR)String2+16, &stString2.MaximumLength, sizeof(stString2.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String2+64, stString2.Buffer, true, stString2.Length)) { printf("Error when read String2 in RtlEqualDomainName"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEqualDomainName\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlEqualComputerName(
    IN  PCUNICODE_STRING  String1  ,
    IN  PCUNICODE_STRING  String2  );

*/
void EmuApi::EmuRtlEqualComputerName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    std::wstring rlwString1;

    USHORT rlLengthString1;

    USHORT rlMaxLengthString1;
    uc_mem_read(uc, (DWORD_PTR)String1, &rlLengthString1, sizeof(rlLengthString1));
    uc_mem_read(uc, (DWORD_PTR)String1+16, &rlMaxLengthString1, sizeof(rlMaxLengthString1));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String1+64, rlwString1, true, rlLengthString1)) { printf("Error when read String1 in RtlEqualComputerName"); _CrtDbgBreak(); }

    UNICODE_STRING stString1{};
    stString1.Length = rlLengthString1;
    stString1.MaximumLength = rlMaxLengthString1;
    stString1.Buffer = rlwString1.data();

    PUNICODE_STRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    std::wstring rlwString2;

    USHORT rlLengthString2;

    USHORT rlMaxLengthString2;
    uc_mem_read(uc, (DWORD_PTR)String2, &rlLengthString2, sizeof(rlLengthString2));
    uc_mem_read(uc, (DWORD_PTR)String2+16, &rlMaxLengthString2, sizeof(rlMaxLengthString2));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String2+64, rlwString2, true, rlLengthString2)) { printf("Error when read String2 in RtlEqualComputerName"); _CrtDbgBreak(); }

    UNICODE_STRING stString2{};
    stString2.Length = rlLengthString2;
    stString2.MaximumLength = rlMaxLengthString2;
    stString2.Buffer = rlwString2.data();


    BOOLEAN RtlEqualComputerNameResult = RtlEqualComputerName((PUNICODE_STRING)&stString1,(PUNICODE_STRING)&stString2);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlEqualComputerNameResult);
    uc_mem_write(uc, (DWORD_PTR)String1, &stString1.Length, sizeof(stString1.Length));
    uc_mem_write(uc, (DWORD_PTR)String1+16, &stString1.MaximumLength, sizeof(stString1.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String1+64, stString1.Buffer, true, stString1.Length)) { printf("Error when read String1 in RtlEqualComputerName"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)String2, &stString2.Length, sizeof(stString2.Length));
    uc_mem_write(uc, (DWORD_PTR)String2+16, &stString2.MaximumLength, sizeof(stString2.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String2+64, stString2.Buffer, true, stString2.Length)) { printf("Error when read String2 in RtlEqualComputerName"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEqualComputerName\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDnsHostNameToComputerName(
    OUT  PUNICODE_STRING   ComputerNameString          ,
    IN   PUNICODE_STRING   DnsHostNameString           ,
    IN   BOOLEAN           AllocateComputerNameString  );

*/
void EmuApi::EmuRtlDnsHostNameToComputerName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING ComputerNameString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ComputerNameString);

    std::wstring rlwComputerNameString;

    USHORT rlLengthComputerNameString;

    USHORT rlMaxLengthComputerNameString;
    uc_mem_read(uc, (DWORD_PTR)ComputerNameString, &rlLengthComputerNameString, sizeof(rlLengthComputerNameString));
    uc_mem_read(uc, (DWORD_PTR)ComputerNameString+16, &rlMaxLengthComputerNameString, sizeof(rlMaxLengthComputerNameString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ComputerNameString+64, rlwComputerNameString, true, rlLengthComputerNameString)) { printf("Error when read ComputerNameString in RtlDnsHostNameToComputerName"); _CrtDbgBreak(); }

    UNICODE_STRING stComputerNameString{};
    stComputerNameString.Length = rlLengthComputerNameString;
    stComputerNameString.MaximumLength = rlMaxLengthComputerNameString;
    stComputerNameString.Buffer = rlwComputerNameString.data();

    PUNICODE_STRING DnsHostNameString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DnsHostNameString);

    std::wstring rlwDnsHostNameString;

    USHORT rlLengthDnsHostNameString;

    USHORT rlMaxLengthDnsHostNameString;
    uc_mem_read(uc, (DWORD_PTR)DnsHostNameString, &rlLengthDnsHostNameString, sizeof(rlLengthDnsHostNameString));
    uc_mem_read(uc, (DWORD_PTR)DnsHostNameString+16, &rlMaxLengthDnsHostNameString, sizeof(rlMaxLengthDnsHostNameString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DnsHostNameString+64, rlwDnsHostNameString, true, rlLengthDnsHostNameString)) { printf("Error when read DnsHostNameString in RtlDnsHostNameToComputerName"); _CrtDbgBreak(); }

    UNICODE_STRING stDnsHostNameString{};
    stDnsHostNameString.Length = rlLengthDnsHostNameString;
    stDnsHostNameString.MaximumLength = rlMaxLengthDnsHostNameString;
    stDnsHostNameString.Buffer = rlwDnsHostNameString.data();

    BOOLEAN AllocateComputerNameString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateComputerNameString);


    NTSTATUS RtlDnsHostNameToComputerNameResult = RtlDnsHostNameToComputerName((PUNICODE_STRING)&stComputerNameString,(PUNICODE_STRING)&stDnsHostNameString,(BOOLEAN)AllocateComputerNameString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDnsHostNameToComputerNameResult);
    uc_mem_write(uc, (DWORD_PTR)ComputerNameString, &stComputerNameString.Length, sizeof(stComputerNameString.Length));
    uc_mem_write(uc, (DWORD_PTR)ComputerNameString+16, &stComputerNameString.MaximumLength, sizeof(stComputerNameString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ComputerNameString+64, stComputerNameString.Buffer, true, stComputerNameString.Length)) { printf("Error when read ComputerNameString in RtlDnsHostNameToComputerName"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)DnsHostNameString, &stDnsHostNameString.Length, sizeof(stDnsHostNameString.Length));
    uc_mem_write(uc, (DWORD_PTR)DnsHostNameString+16, &stDnsHostNameString.MaximumLength, sizeof(stDnsHostNameString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DnsHostNameString+64, stDnsHostNameString.Buffer, true, stDnsHostNameString.Length)) { printf("Error when read DnsHostNameString in RtlDnsHostNameToComputerName"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateComputerNameString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDnsHostNameToComputerName\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlCreateUnicodeStringFromAsciiz(
    OUT  PUNICODE_STRING  DestinationString  ,
    IN   PCSZ             SourceString       );

*/
void EmuApi::EmuRtlCreateUnicodeStringFromAsciiz(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlCreateUnicodeStringFromAsciiz"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PSZ SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::string rlaSourceString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlCreateUnicodeStringFromAsciiz"); _CrtDbgBreak(); }


    BOOLEAN RtlCreateUnicodeStringFromAsciizResult = RtlCreateUnicodeStringFromAsciiz((PUNICODE_STRING)&stDestinationString,(PCSZ)rlaSourceString.data());


    uc_reg_write(uc, UC_X86_REG_AL, &RtlCreateUnicodeStringFromAsciizResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlCreateUnicodeStringFromAsciiz"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)SourceString, rlaSourceString)) { printf("Error when read SourceString in RtlCreateUnicodeStringFromAsciiz"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateUnicodeStringFromAsciiz\n";
    #endif

    return;
}


/*
void
__cdecl
RtlCopyString(
      PSTRING         DestinationString  ,
      PSTRING         SourceString       );

*/
void EmuApi::EmuRtlCopyString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PSTRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    STRING rlSourceString{};

    if(SourceString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }


    RtlCopyString((PSTRING)&rlDestinationString,(PSTRING)&rlSourceString);


    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceString);

    if(SourceString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopyString\n";
    #endif

    return;
}


/*
CHAR
__cdecl
RtlUpperChar(
      CHAR  Character  );

*/
void EmuApi::EmuRtlUpperChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    CHAR Character{};
    uc_reg_read(uc, UC_X86_REG_CL, &Character);


    CHAR RtlUpperCharResult = RtlUpperChar((CHAR)Character);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlUpperCharResult);
    uc_reg_write(uc, UC_X86_REG_CL, &Character);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpperChar\n";
    #endif

    return;
}


/*
LONG
__cdecl
RtlCompareString(
      STRING *        String1          ,
      STRING *        String2          ,
      BOOLEAN         CaseInSensitive  );

*/
void EmuApi::EmuRtlCompareString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    STRING rlString1{};

    if(String1 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)String1, &rlString1, sizeof(rlString1));
    }

    PSTRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    STRING rlString2{};

    if(String2 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)String2, &rlString2, sizeof(rlString2));
    }

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CaseInSensitive);


    LONG RtlCompareStringResult = RtlCompareString((STRING *)&rlString1,(STRING *)&rlString2,(BOOLEAN)CaseInSensitive);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCompareStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &String1);

    if(String1 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)String1, &rlString1, sizeof(rlString1));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &String2);

    if(String2 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)String2, &rlString2, sizeof(rlString2));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &CaseInSensitive);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCompareString\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlEqualString(
      const STRING *  String1          ,
      const STRING *  String2          ,
      BOOLEAN         CaseInSensitive  );

*/
void EmuApi::EmuRtlEqualString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    STRING rlString1{};

    if(String1 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)String1, &rlString1, sizeof(rlString1));
    }

    PSTRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    STRING rlString2{};

    if(String2 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)String2, &rlString2, sizeof(rlString2));
    }

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CaseInSensitive);


    BOOLEAN RtlEqualStringResult = RtlEqualString((STRING *)&rlString1,(STRING *)&rlString2,(BOOLEAN)CaseInSensitive);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlEqualStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &String1);

    if(String1 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)String1, &rlString1, sizeof(rlString1));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &String2);

    if(String2 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)String2, &rlString2, sizeof(rlString2));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &CaseInSensitive);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEqualString\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlPrefixString(
      const STRING *  String1          ,
      const STRING *  String2          ,
      BOOLEAN         CaseInSensitive  );

*/
void EmuApi::EmuRtlPrefixString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    STRING rlString1{};

    if(String1 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)String1, &rlString1, sizeof(rlString1));
    }

    PSTRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    STRING rlString2{};

    if(String2 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)String2, &rlString2, sizeof(rlString2));
    }

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CaseInSensitive);


    BOOLEAN RtlPrefixStringResult = RtlPrefixString((STRING *)&rlString1,(STRING *)&rlString2,(BOOLEAN)CaseInSensitive);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlPrefixStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &String1);

    if(String1 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)String1, &rlString1, sizeof(rlString1));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &String2);

    if(String2 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)String2, &rlString2, sizeof(rlString2));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &CaseInSensitive);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlPrefixString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlUpperString(
      PSTRING         DestinationString  ,
      const STRING *  SourceString       );

*/
void EmuApi::EmuRtlUpperString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PSTRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    STRING rlSourceString{};

    if(SourceString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }


    RtlUpperString((PSTRING)&rlDestinationString,(const STRING *)&rlSourceString);


    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceString);

    if(SourceString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpperString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAppendAsciizToString(
      PSTRING  Destination  ,
      PCSZ     Source       );

*/
void EmuApi::EmuRtlAppendAsciizToString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING Destination{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Destination);

    STRING rlDestination{};

    if(Destination != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Destination, &rlDestination, sizeof(rlDestination));
    }

    PSZ Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    std::string rlaSource;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Source, rlaSource)) { printf("Error when read Source in RtlAppendAsciizToString"); _CrtDbgBreak(); }


    NTSTATUS RtlAppendAsciizToStringResult = RtlAppendAsciizToString((PSTRING)&rlDestination,(PCSZ)rlaSource.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAppendAsciizToStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Destination);

    if(Destination != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Destination, &rlDestination, sizeof(rlDestination));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Source, rlaSource)) { printf("Error when read Source in RtlAppendAsciizToString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAppendAsciizToString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAppendStringToString(
      PSTRING         Destination  ,
      const STRING *  Source       );

*/
void EmuApi::EmuRtlAppendStringToString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSTRING Destination{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Destination);

    STRING rlDestination{};

    if(Destination != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Destination, &rlDestination, sizeof(rlDestination));
    }

    PSTRING Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    STRING rlSource{};

    if(Source != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Source, &rlSource, sizeof(rlSource));
    }


    NTSTATUS RtlAppendStringToStringResult = RtlAppendStringToString((PSTRING)&rlDestination,(STRING *)&rlSource);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAppendStringToStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Destination);

    if(Destination != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Destination, &rlDestination, sizeof(rlDestination));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Source);

    if(Source != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Source, &rlSource, sizeof(rlSource));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAppendStringToString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAnsiStringToUnicodeString(
      PUNICODE_STRING  DestinationString          ,
      PCANSI_STRING    SourceString               ,
      BOOLEAN          AllocateDestinationString  );

*/
void EmuApi::EmuRtlAnsiStringToUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlAnsiStringToUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PCANSI_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    STRING rlSourceString{};

    if(SourceString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlAnsiStringToUnicodeStringResult = RtlAnsiStringToUnicodeString((PUNICODE_STRING)&stDestinationString,(PCANSI_STRING)&rlSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAnsiStringToUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlAnsiStringToUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceString);

    if(SourceString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAnsiStringToUnicodeString\n";
    #endif

    return;
}


/*
WCHAR
__cdecl
RtlAnsiCharToUnicodeChar(
      PUCHAR *  SourceCharacter  );

*/
void EmuApi::EmuRtlAnsiCharToUnicodeChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUCHAR * SourceCharacter{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SourceCharacter);

    PUCHAR * dpSourceCharacter{};

    if(SourceCharacter != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceCharacter, &dpSourceCharacter, sizeof(dpSourceCharacter));
    }

    UCHAR rlSourceCharacter{};

    if(dpSourceCharacter != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpSourceCharacter, &rlSourceCharacter, sizeof(rlSourceCharacter));
    }


    WCHAR RtlAnsiCharToUnicodeCharResult = RtlAnsiCharToUnicodeChar((PUCHAR *)&rlSourceCharacter);


    uc_reg_write(uc, UC_X86_REG_AX, &RtlAnsiCharToUnicodeCharResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SourceCharacter);

    if(SourceCharacter != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceCharacter, &dpSourceCharacter, sizeof(dpSourceCharacter));
    }

    if(dpSourceCharacter != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpSourceCharacter, &rlSourceCharacter, sizeof(rlSourceCharacter));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAnsiCharToUnicodeChar\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeStringToAnsiString(
      PANSI_STRING      DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUnicodeStringToAnsiString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PANSI_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUnicodeStringToAnsiString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUnicodeStringToAnsiStringResult = RtlUnicodeStringToAnsiString((PANSI_STRING)&rlDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeStringToAnsiStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUnicodeStringToAnsiString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeStringToAnsiString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeStringToAnsiString(
      PANSI_STRING      DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUpcaseUnicodeStringToAnsiString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PANSI_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUpcaseUnicodeStringToAnsiString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUpcaseUnicodeStringToAnsiStringResult = RtlUpcaseUnicodeStringToAnsiString((PANSI_STRING)&rlDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeStringToAnsiStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUpcaseUnicodeStringToAnsiString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeStringToAnsiString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlOemStringToUnicodeString(
      PUNICODE_STRING  DestinationString          ,
      PCOEM_STRING     SourceString               ,
      BOOLEAN          AllocateDestinationString  );

*/
void EmuApi::EmuRtlOemStringToUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlOemStringToUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    STRING * SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    STRING rlSourceString{};

    if(SourceString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlOemStringToUnicodeStringResult = RtlOemStringToUnicodeString((PUNICODE_STRING)&stDestinationString,(POEM_STRING)&rlSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlOemStringToUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlOemStringToUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceString);

    if(SourceString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlOemStringToUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeStringToOemString(
      POEM_STRING       DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUnicodeStringToOemString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POEM_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUnicodeStringToOemString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUnicodeStringToOemStringResult = RtlUnicodeStringToOemString((POEM_STRING)&rlDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeStringToOemStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUnicodeStringToOemString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeStringToOemString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeStringToOemString(
      POEM_STRING       DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUpcaseUnicodeStringToOemString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POEM_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUpcaseUnicodeStringToOemString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUpcaseUnicodeStringToOemStringResult = RtlUpcaseUnicodeStringToOemString((POEM_STRING)&rlDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeStringToOemStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUpcaseUnicodeStringToOemString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeStringToOemString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlOemStringToCountedUnicodeString(
      PUNICODE_STRING  DestinationString          ,
      PCOEM_STRING     SourceString               ,
      BOOLEAN          AllocateDestinationString  );

*/
void EmuApi::EmuRtlOemStringToCountedUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlOemStringToCountedUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    STRING * SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    STRING rlSourceString{};

    if(SourceString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlOemStringToCountedUnicodeStringResult = RtlOemStringToCountedUnicodeString((PUNICODE_STRING)&stDestinationString,(PCOEM_STRING)&rlSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlOemStringToCountedUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlOemStringToCountedUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceString);

    if(SourceString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceString, &rlSourceString, sizeof(rlSourceString));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlOemStringToCountedUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeStringToCountedOemString(
      POEM_STRING       DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUnicodeStringToCountedOemString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POEM_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUnicodeStringToCountedOemString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUnicodeStringToCountedOemStringResult = RtlUnicodeStringToCountedOemString((POEM_STRING)&rlDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeStringToCountedOemStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUnicodeStringToCountedOemString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeStringToCountedOemString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeStringToCountedOemString(
      POEM_STRING       DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUpcaseUnicodeStringToCountedOemString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POEM_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    STRING rlDestinationString{};

    if(DestinationString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUpcaseUnicodeStringToCountedOemString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUpcaseUnicodeStringToCountedOemStringResult = RtlUpcaseUnicodeStringToCountedOemString((POEM_STRING)&rlDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeStringToCountedOemStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationString);

    if(DestinationString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationString, &rlDestinationString, sizeof(rlDestinationString));
    }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUpcaseUnicodeStringToCountedOemString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeStringToCountedOemString\n";
    #endif

    return;
}


/*
LONG
__cdecl
RtlCompareUnicodeString(
      PCUNICODE_STRING  String1          ,
      PCUNICODE_STRING  String2          ,
      BOOLEAN           CaseInSensitive  );

*/
void EmuApi::EmuRtlCompareUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    std::wstring rlwString1;

    USHORT rlLengthString1;

    USHORT rlMaxLengthString1;
    uc_mem_read(uc, (DWORD_PTR)String1, &rlLengthString1, sizeof(rlLengthString1));
    uc_mem_read(uc, (DWORD_PTR)String1+16, &rlMaxLengthString1, sizeof(rlMaxLengthString1));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String1+64, rlwString1, true, rlLengthString1)) { printf("Error when read String1 in RtlCompareUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString1{};
    stString1.Length = rlLengthString1;
    stString1.MaximumLength = rlMaxLengthString1;
    stString1.Buffer = rlwString1.data();

    PUNICODE_STRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    std::wstring rlwString2;

    USHORT rlLengthString2;

    USHORT rlMaxLengthString2;
    uc_mem_read(uc, (DWORD_PTR)String2, &rlLengthString2, sizeof(rlLengthString2));
    uc_mem_read(uc, (DWORD_PTR)String2+16, &rlMaxLengthString2, sizeof(rlMaxLengthString2));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String2+64, rlwString2, true, rlLengthString2)) { printf("Error when read String2 in RtlCompareUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString2{};
    stString2.Length = rlLengthString2;
    stString2.MaximumLength = rlMaxLengthString2;
    stString2.Buffer = rlwString2.data();

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CaseInSensitive);


    LONG RtlCompareUnicodeStringResult = RtlCompareUnicodeString((PUNICODE_STRING)&stString1,(PUNICODE_STRING)&stString2,(BOOLEAN)CaseInSensitive);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCompareUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)String1, &stString1.Length, sizeof(stString1.Length));
    uc_mem_write(uc, (DWORD_PTR)String1+16, &stString1.MaximumLength, sizeof(stString1.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String1+64, stString1.Buffer, true, stString1.Length)) { printf("Error when read String1 in RtlCompareUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)String2, &stString2.Length, sizeof(stString2.Length));
    uc_mem_write(uc, (DWORD_PTR)String2+16, &stString2.MaximumLength, sizeof(stString2.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String2+64, stString2.Buffer, true, stString2.Length)) { printf("Error when read String2 in RtlCompareUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &CaseInSensitive);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCompareUnicodeString\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlEqualUnicodeString(
      PCUNICODE_STRING  String1          ,
      PCUNICODE_STRING  String2          ,
      BOOLEAN           CaseInSensitive  );

*/
void EmuApi::EmuRtlEqualUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    std::wstring rlwString1;

    USHORT rlLengthString1;

    USHORT rlMaxLengthString1;
    uc_mem_read(uc, (DWORD_PTR)String1, &rlLengthString1, sizeof(rlLengthString1));
    uc_mem_read(uc, (DWORD_PTR)String1+16, &rlMaxLengthString1, sizeof(rlMaxLengthString1));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String1+64, rlwString1, true, rlLengthString1)) { printf("Error when read String1 in RtlEqualUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString1{};
    stString1.Length = rlLengthString1;
    stString1.MaximumLength = rlMaxLengthString1;
    stString1.Buffer = rlwString1.data();

    PUNICODE_STRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    std::wstring rlwString2;

    USHORT rlLengthString2;

    USHORT rlMaxLengthString2;
    uc_mem_read(uc, (DWORD_PTR)String2, &rlLengthString2, sizeof(rlLengthString2));
    uc_mem_read(uc, (DWORD_PTR)String2+16, &rlMaxLengthString2, sizeof(rlMaxLengthString2));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String2+64, rlwString2, true, rlLengthString2)) { printf("Error when read String2 in RtlEqualUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString2{};
    stString2.Length = rlLengthString2;
    stString2.MaximumLength = rlMaxLengthString2;
    stString2.Buffer = rlwString2.data();

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CaseInSensitive);


    BOOLEAN RtlEqualUnicodeStringResult = RtlEqualUnicodeString((PUNICODE_STRING)&stString1,(PUNICODE_STRING)&stString2,(BOOLEAN)CaseInSensitive);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlEqualUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)String1, &stString1.Length, sizeof(stString1.Length));
    uc_mem_write(uc, (DWORD_PTR)String1+16, &stString1.MaximumLength, sizeof(stString1.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String1+64, stString1.Buffer, true, stString1.Length)) { printf("Error when read String1 in RtlEqualUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)String2, &stString2.Length, sizeof(stString2.Length));
    uc_mem_write(uc, (DWORD_PTR)String2+16, &stString2.MaximumLength, sizeof(stString2.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String2+64, stString2.Buffer, true, stString2.Length)) { printf("Error when read String2 in RtlEqualUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &CaseInSensitive);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEqualUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlHashUnicodeString(
    IN   const UNICODE_STRING *  String           ,
    IN   BOOLEAN                 CaseInSensitive  ,
    IN   ULONG                   HashAlgorithm    ,
    OUT  PULONG                  HashValue        );

*/
void EmuApi::EmuRtlHashUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlHashUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_DL, &CaseInSensitive);

    ULONG HashAlgorithm{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HashAlgorithm);

    PULONG HashValue{};
    uc_reg_read(uc, UC_X86_REG_R9, &HashValue);

    ULONG rlHashValue{};

    if(HashValue != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HashValue, &rlHashValue, sizeof(rlHashValue));
    }


    NTSTATUS RtlHashUnicodeStringResult = RtlHashUnicodeString((UNICODE_STRING *)&stString,(BOOLEAN)CaseInSensitive,(ULONG)HashAlgorithm,(PULONG)&rlHashValue);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlHashUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlHashUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_DL, &CaseInSensitive);
    uc_reg_write(uc, UC_X86_REG_R8D, &HashAlgorithm);
    uc_reg_write(uc, UC_X86_REG_R9, &HashValue);

    if(HashValue != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HashValue, &rlHashValue, sizeof(rlHashValue));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlHashUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlValidateUnicodeString(
    IN  ULONG                   Flags   ,
    IN  const UNICODE_STRING *  String  );

*/
void EmuApi::EmuRtlValidateUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlValidateUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    NTSTATUS RtlValidateUnicodeStringResult = RtlValidateUnicodeString((ULONG)Flags,(UNICODE_STRING *)&stString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlValidateUnicodeStringResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlValidateUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlValidateUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDuplicateUnicodeString(
    IN   ULONG                   Flags      ,
    IN   const UNICODE_STRING *  StringIn   ,
    OUT  UNICODE_STRING *        StringOut  );

*/
void EmuApi::EmuRtlDuplicateUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PUNICODE_STRING StringIn{};
    uc_reg_read(uc, UC_X86_REG_RDX, &StringIn);

    std::wstring rlwStringIn;

    USHORT rlLengthStringIn;

    USHORT rlMaxLengthStringIn;
    uc_mem_read(uc, (DWORD_PTR)StringIn, &rlLengthStringIn, sizeof(rlLengthStringIn));
    uc_mem_read(uc, (DWORD_PTR)StringIn+16, &rlMaxLengthStringIn, sizeof(rlMaxLengthStringIn));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)StringIn+64, rlwStringIn, true, rlLengthStringIn)) { printf("Error when read StringIn in RtlDuplicateUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stStringIn{};
    stStringIn.Length = rlLengthStringIn;
    stStringIn.MaximumLength = rlMaxLengthStringIn;
    stStringIn.Buffer = rlwStringIn.data();

    PUNICODE_STRING StringOut{};
    uc_reg_read(uc, UC_X86_REG_R8, &StringOut);

    std::wstring rlwStringOut;

    USHORT rlLengthStringOut;

    USHORT rlMaxLengthStringOut;
    uc_mem_read(uc, (DWORD_PTR)StringOut, &rlLengthStringOut, sizeof(rlLengthStringOut));
    uc_mem_read(uc, (DWORD_PTR)StringOut+16, &rlMaxLengthStringOut, sizeof(rlMaxLengthStringOut));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)StringOut+64, rlwStringOut, true, rlLengthStringOut)) { printf("Error when read StringOut in RtlDuplicateUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stStringOut{};
    stStringOut.Length = rlLengthStringOut;
    stStringOut.MaximumLength = rlMaxLengthStringOut;
    stStringOut.Buffer = rlwStringOut.data();


    NTSTATUS RtlDuplicateUnicodeStringResult = RtlDuplicateUnicodeString((ULONG)Flags,(UNICODE_STRING *)&stStringIn,(UNICODE_STRING *)&stStringOut);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDuplicateUnicodeStringResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_mem_write(uc, (DWORD_PTR)StringIn, &stStringIn.Length, sizeof(stStringIn.Length));
    uc_mem_write(uc, (DWORD_PTR)StringIn+16, &stStringIn.MaximumLength, sizeof(stStringIn.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)StringIn+64, stStringIn.Buffer, true, stStringIn.Length)) { printf("Error when read StringIn in RtlDuplicateUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)StringOut, &stStringOut.Length, sizeof(stStringOut.Length));
    uc_mem_write(uc, (DWORD_PTR)StringOut+16, &stStringOut.MaximumLength, sizeof(stStringOut.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)StringOut+64, stStringOut.Buffer, true, stStringOut.Length)) { printf("Error when read StringOut in RtlDuplicateUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDuplicateUnicodeString\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlPrefixUnicodeString(
    IN  PCUNICODE_STRING  String1          ,
    IN  PCUNICODE_STRING  String2          ,
    IN  BOOLEAN           CaseInSensitive  );

*/
void EmuApi::EmuRtlPrefixUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String1);

    std::wstring rlwString1;

    USHORT rlLengthString1;

    USHORT rlMaxLengthString1;
    uc_mem_read(uc, (DWORD_PTR)String1, &rlLengthString1, sizeof(rlLengthString1));
    uc_mem_read(uc, (DWORD_PTR)String1+16, &rlMaxLengthString1, sizeof(rlMaxLengthString1));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String1+64, rlwString1, true, rlLengthString1)) { printf("Error when read String1 in RtlPrefixUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString1{};
    stString1.Length = rlLengthString1;
    stString1.MaximumLength = rlMaxLengthString1;
    stString1.Buffer = rlwString1.data();

    PUNICODE_STRING String2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String2);

    std::wstring rlwString2;

    USHORT rlLengthString2;

    USHORT rlMaxLengthString2;
    uc_mem_read(uc, (DWORD_PTR)String2, &rlLengthString2, sizeof(rlLengthString2));
    uc_mem_read(uc, (DWORD_PTR)String2+16, &rlMaxLengthString2, sizeof(rlMaxLengthString2));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String2+64, rlwString2, true, rlLengthString2)) { printf("Error when read String2 in RtlPrefixUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString2{};
    stString2.Length = rlLengthString2;
    stString2.MaximumLength = rlMaxLengthString2;
    stString2.Buffer = rlwString2.data();

    BOOLEAN CaseInSensitive{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CaseInSensitive);


    BOOLEAN RtlPrefixUnicodeStringResult = RtlPrefixUnicodeString((PUNICODE_STRING)&stString1,(PUNICODE_STRING)&stString2,(BOOLEAN)CaseInSensitive);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlPrefixUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)String1, &stString1.Length, sizeof(stString1.Length));
    uc_mem_write(uc, (DWORD_PTR)String1+16, &stString1.MaximumLength, sizeof(stString1.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String1+64, stString1.Buffer, true, stString1.Length)) { printf("Error when read String1 in RtlPrefixUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)String2, &stString2.Length, sizeof(stString2.Length));
    uc_mem_write(uc, (DWORD_PTR)String2+16, &stString2.MaximumLength, sizeof(stString2.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String2+64, stString2.Buffer, true, stString2.Length)) { printf("Error when read String2 in RtlPrefixUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &CaseInSensitive);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlPrefixUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeString(
      PUNICODE_STRING   DestinationString          ,
      PCUNICODE_STRING  SourceString               ,
      BOOLEAN           AllocateDestinationString  );

*/
void EmuApi::EmuRtlUpcaseUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlUpcaseUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlUpcaseUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlUpcaseUnicodeStringResult = RtlUpcaseUnicodeString((PUNICODE_STRING)&stDestinationString,(PUNICODE_STRING)&stSourceString,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlUpcaseUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlUpcaseUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlFindCharInUnicodeString(
    IN   ULONG             Flags                     ,
    IN   PCUNICODE_STRING  StringToSearch            ,
    IN   PCUNICODE_STRING  CharSet                   ,
    OUT  USHORT *          NonInclusivePrefixLength  );

*/
void EmuApi::EmuRtlFindCharInUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PUNICODE_STRING StringToSearch{};
    uc_reg_read(uc, UC_X86_REG_RDX, &StringToSearch);

    std::wstring rlwStringToSearch;

    USHORT rlLengthStringToSearch;

    USHORT rlMaxLengthStringToSearch;
    uc_mem_read(uc, (DWORD_PTR)StringToSearch, &rlLengthStringToSearch, sizeof(rlLengthStringToSearch));
    uc_mem_read(uc, (DWORD_PTR)StringToSearch+16, &rlMaxLengthStringToSearch, sizeof(rlMaxLengthStringToSearch));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)StringToSearch+64, rlwStringToSearch, true, rlLengthStringToSearch)) { printf("Error when read StringToSearch in RtlFindCharInUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stStringToSearch{};
    stStringToSearch.Length = rlLengthStringToSearch;
    stStringToSearch.MaximumLength = rlMaxLengthStringToSearch;
    stStringToSearch.Buffer = rlwStringToSearch.data();

    PUNICODE_STRING CharSet{};
    uc_reg_read(uc, UC_X86_REG_R8, &CharSet);

    std::wstring rlwCharSet;

    USHORT rlLengthCharSet;

    USHORT rlMaxLengthCharSet;
    uc_mem_read(uc, (DWORD_PTR)CharSet, &rlLengthCharSet, sizeof(rlLengthCharSet));
    uc_mem_read(uc, (DWORD_PTR)CharSet+16, &rlMaxLengthCharSet, sizeof(rlMaxLengthCharSet));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)CharSet+64, rlwCharSet, true, rlLengthCharSet)) { printf("Error when read CharSet in RtlFindCharInUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stCharSet{};
    stCharSet.Length = rlLengthCharSet;
    stCharSet.MaximumLength = rlMaxLengthCharSet;
    stCharSet.Buffer = rlwCharSet.data();

    PUSHORT NonInclusivePrefixLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &NonInclusivePrefixLength);

    USHORT rlNonInclusivePrefixLength{};

    if(NonInclusivePrefixLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NonInclusivePrefixLength, &rlNonInclusivePrefixLength, sizeof(rlNonInclusivePrefixLength));
    }


    NTSTATUS RtlFindCharInUnicodeStringResult = RtlFindCharInUnicodeString((ULONG)Flags,(PUNICODE_STRING)&stStringToSearch,(PUNICODE_STRING)&stCharSet,(USHORT *)&rlNonInclusivePrefixLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindCharInUnicodeStringResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_mem_write(uc, (DWORD_PTR)StringToSearch, &stStringToSearch.Length, sizeof(stStringToSearch.Length));
    uc_mem_write(uc, (DWORD_PTR)StringToSearch+16, &stStringToSearch.MaximumLength, sizeof(stStringToSearch.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)StringToSearch+64, stStringToSearch.Buffer, true, stStringToSearch.Length)) { printf("Error when read StringToSearch in RtlFindCharInUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)CharSet, &stCharSet.Length, sizeof(stCharSet.Length));
    uc_mem_write(uc, (DWORD_PTR)CharSet+16, &stCharSet.MaximumLength, sizeof(stCharSet.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)CharSet+64, stCharSet.Buffer, true, stCharSet.Length)) { printf("Error when read CharSet in RtlFindCharInUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &NonInclusivePrefixLength);

    if(NonInclusivePrefixLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NonInclusivePrefixLength, &rlNonInclusivePrefixLength, sizeof(rlNonInclusivePrefixLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindCharInUnicodeString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlCopyUnicodeString(
      PUNICODE_STRING   DestinationString  ,
      PCUNICODE_STRING  SourceString       );

*/
void EmuApi::EmuRtlCopyUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DestinationString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationString);

    std::wstring rlwDestinationString;

    USHORT rlLengthDestinationString;

    USHORT rlMaxLengthDestinationString;
    uc_mem_read(uc, (DWORD_PTR)DestinationString, &rlLengthDestinationString, sizeof(rlLengthDestinationString));
    uc_mem_read(uc, (DWORD_PTR)DestinationString+16, &rlMaxLengthDestinationString, sizeof(rlMaxLengthDestinationString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, rlwDestinationString, true, rlLengthDestinationString)) { printf("Error when read DestinationString in RtlCopyUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestinationString{};
    stDestinationString.Length = rlLengthDestinationString;
    stDestinationString.MaximumLength = rlMaxLengthDestinationString;
    stDestinationString.Buffer = rlwDestinationString.data();

    PUNICODE_STRING SourceString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceString);

    std::wstring rlwSourceString;

    USHORT rlLengthSourceString;

    USHORT rlMaxLengthSourceString;
    uc_mem_read(uc, (DWORD_PTR)SourceString, &rlLengthSourceString, sizeof(rlLengthSourceString));
    uc_mem_read(uc, (DWORD_PTR)SourceString+16, &rlMaxLengthSourceString, sizeof(rlMaxLengthSourceString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, rlwSourceString, true, rlLengthSourceString)) { printf("Error when read SourceString in RtlCopyUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stSourceString{};
    stSourceString.Length = rlLengthSourceString;
    stSourceString.MaximumLength = rlMaxLengthSourceString;
    stSourceString.Buffer = rlwSourceString.data();


    RtlCopyUnicodeString((PUNICODE_STRING)&stDestinationString,(PCUNICODE_STRING)&stSourceString);


    uc_mem_write(uc, (DWORD_PTR)DestinationString, &stDestinationString.Length, sizeof(stDestinationString.Length));
    uc_mem_write(uc, (DWORD_PTR)DestinationString+16, &stDestinationString.MaximumLength, sizeof(stDestinationString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DestinationString+64, stDestinationString.Buffer, true, stDestinationString.Length)) { printf("Error when read DestinationString in RtlCopyUnicodeString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SourceString, &stSourceString.Length, sizeof(stSourceString.Length));
    uc_mem_write(uc, (DWORD_PTR)SourceString+16, &stSourceString.MaximumLength, sizeof(stSourceString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SourceString+64, stSourceString.Buffer, true, stSourceString.Length)) { printf("Error when read SourceString in RtlCopyUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopyUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAppendUnicodeStringToString(
      PUNICODE_STRING   Destination  ,
      PCUNICODE_STRING  Source       );

*/
void EmuApi::EmuRtlAppendUnicodeStringToString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING Destination{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Destination);

    std::wstring rlwDestination;

    USHORT rlLengthDestination;

    USHORT rlMaxLengthDestination;
    uc_mem_read(uc, (DWORD_PTR)Destination, &rlLengthDestination, sizeof(rlLengthDestination));
    uc_mem_read(uc, (DWORD_PTR)Destination+16, &rlMaxLengthDestination, sizeof(rlMaxLengthDestination));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Destination+64, rlwDestination, true, rlLengthDestination)) { printf("Error when read Destination in RtlAppendUnicodeStringToString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestination{};
    stDestination.Length = rlLengthDestination;
    stDestination.MaximumLength = rlMaxLengthDestination;
    stDestination.Buffer = rlwDestination.data();

    PUNICODE_STRING Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    std::wstring rlwSource;

    USHORT rlLengthSource;

    USHORT rlMaxLengthSource;
    uc_mem_read(uc, (DWORD_PTR)Source, &rlLengthSource, sizeof(rlLengthSource));
    uc_mem_read(uc, (DWORD_PTR)Source+16, &rlMaxLengthSource, sizeof(rlMaxLengthSource));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Source+64, rlwSource, true, rlLengthSource)) { printf("Error when read Source in RtlAppendUnicodeStringToString"); _CrtDbgBreak(); }

    UNICODE_STRING stSource{};
    stSource.Length = rlLengthSource;
    stSource.MaximumLength = rlMaxLengthSource;
    stSource.Buffer = rlwSource.data();


    NTSTATUS RtlAppendUnicodeStringToStringResult = RtlAppendUnicodeStringToString((PUNICODE_STRING)&stDestination,(PCUNICODE_STRING)&stSource);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAppendUnicodeStringToStringResult);
    uc_mem_write(uc, (DWORD_PTR)Destination, &stDestination.Length, sizeof(stDestination.Length));
    uc_mem_write(uc, (DWORD_PTR)Destination+16, &stDestination.MaximumLength, sizeof(stDestination.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Destination+64, stDestination.Buffer, true, stDestination.Length)) { printf("Error when read Destination in RtlAppendUnicodeStringToString"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)Source, &stSource.Length, sizeof(stSource.Length));
    uc_mem_write(uc, (DWORD_PTR)Source+16, &stSource.MaximumLength, sizeof(stSource.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Source+64, stSource.Buffer, true, stSource.Length)) { printf("Error when read Source in RtlAppendUnicodeStringToString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAppendUnicodeStringToString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAppendUnicodeToString(
      PUNICODE_STRING  Destination  ,
      PCWSTR           Source       );

*/
void EmuApi::EmuRtlAppendUnicodeToString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING Destination{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Destination);

    std::wstring rlwDestination;

    USHORT rlLengthDestination;

    USHORT rlMaxLengthDestination;
    uc_mem_read(uc, (DWORD_PTR)Destination, &rlLengthDestination, sizeof(rlLengthDestination));
    uc_mem_read(uc, (DWORD_PTR)Destination+16, &rlMaxLengthDestination, sizeof(rlMaxLengthDestination));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Destination+64, rlwDestination, true, rlLengthDestination)) { printf("Error when read Destination in RtlAppendUnicodeToString"); _CrtDbgBreak(); }

    UNICODE_STRING stDestination{};
    stDestination.Length = rlLengthDestination;
    stDestination.MaximumLength = rlMaxLengthDestination;
    stDestination.Buffer = rlwDestination.data();

    PWSTR Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    std::wstring rlwSource;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Source, rlwSource)) { printf("Error when read Source in RtlAppendUnicodeToString"); _CrtDbgBreak(); }


    NTSTATUS RtlAppendUnicodeToStringResult = RtlAppendUnicodeToString((PUNICODE_STRING)&stDestination,(PCWSTR)rlwSource.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAppendUnicodeToStringResult);
    uc_mem_write(uc, (DWORD_PTR)Destination, &stDestination.Length, sizeof(stDestination.Length));
    uc_mem_write(uc, (DWORD_PTR)Destination+16, &stDestination.MaximumLength, sizeof(stDestination.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Destination+64, stDestination.Buffer, true, stDestination.Length)) { printf("Error when read Destination in RtlAppendUnicodeToString"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Source, rlwSource)) { printf("Error when read Source in RtlAppendUnicodeToString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAppendUnicodeToString\n";
    #endif

    return;
}


/*
WCHAR
__cdecl
RtlUpcaseUnicodeChar(
      WCHAR  SourceCharacter  );

*/
void EmuApi::EmuRtlUpcaseUnicodeChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    WCHAR SourceCharacter{};
    uc_reg_read(uc, UC_X86_REG_CX, &SourceCharacter);


    WCHAR RtlUpcaseUnicodeCharResult = RtlUpcaseUnicodeChar((WCHAR)SourceCharacter);


    uc_reg_write(uc, UC_X86_REG_AX, &RtlUpcaseUnicodeCharResult);
    uc_reg_write(uc, UC_X86_REG_CX, &SourceCharacter);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeChar\n";
    #endif

    return;
}


/*
WCHAR
__cdecl
RtlDowncaseUnicodeChar(
      WCHAR  SourceCharacter  );

*/
void EmuApi::EmuRtlDowncaseUnicodeChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    WCHAR SourceCharacter{};
    uc_reg_read(uc, UC_X86_REG_CX, &SourceCharacter);


    WCHAR RtlDowncaseUnicodeCharResult = RtlDowncaseUnicodeChar((WCHAR)SourceCharacter);


    uc_reg_write(uc, UC_X86_REG_AX, &RtlDowncaseUnicodeCharResult);
    uc_reg_write(uc, UC_X86_REG_CX, &SourceCharacter);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDowncaseUnicodeChar\n";
    #endif

    return;
}


/*
void
__cdecl
RtlFreeUnicodeString(
      PUNICODE_STRING  UnicodeString  );

*/
void EmuApi::EmuRtlFreeUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UnicodeString);

    std::wstring rlwUnicodeString;

    USHORT rlLengthUnicodeString;

    USHORT rlMaxLengthUnicodeString;
    uc_mem_read(uc, (DWORD_PTR)UnicodeString, &rlLengthUnicodeString, sizeof(rlLengthUnicodeString));
    uc_mem_read(uc, (DWORD_PTR)UnicodeString+16, &rlMaxLengthUnicodeString, sizeof(rlMaxLengthUnicodeString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString+64, rlwUnicodeString, true, rlLengthUnicodeString)) { printf("Error when read UnicodeString in RtlFreeUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stUnicodeString{};
    stUnicodeString.Length = rlLengthUnicodeString;
    stUnicodeString.MaximumLength = rlMaxLengthUnicodeString;
    stUnicodeString.Buffer = rlwUnicodeString.data();


    RtlFreeUnicodeString((PUNICODE_STRING)&stUnicodeString);


    uc_mem_write(uc, (DWORD_PTR)UnicodeString, &stUnicodeString.Length, sizeof(stUnicodeString.Length));
    uc_mem_write(uc, (DWORD_PTR)UnicodeString+16, &stUnicodeString.MaximumLength, sizeof(stUnicodeString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString+64, stUnicodeString.Buffer, true, stUnicodeString.Length)) { printf("Error when read UnicodeString in RtlFreeUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeUnicodeString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlFreeAnsiString(
      PANSI_STRING  AnsiString  );

*/
void EmuApi::EmuRtlFreeAnsiString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PANSI_STRING AnsiString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AnsiString);

    STRING rlAnsiString{};

    if(AnsiString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AnsiString, &rlAnsiString, sizeof(rlAnsiString));
    }


    RtlFreeAnsiString((PANSI_STRING)&rlAnsiString);


    uc_reg_write(uc, UC_X86_REG_RCX, &AnsiString);

    if(AnsiString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AnsiString, &rlAnsiString, sizeof(rlAnsiString));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeAnsiString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlFreeOemString(
      POEM_STRING  OemString  );

*/
void EmuApi::EmuRtlFreeOemString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POEM_STRING OemString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &OemString);

    STRING rlOemString{};

    if(OemString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OemString, &rlOemString, sizeof(rlOemString));
    }


    RtlFreeOemString((POEM_STRING)&rlOemString);


    uc_reg_write(uc, UC_X86_REG_RCX, &OemString);

    if(OemString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OemString, &rlOemString, sizeof(rlOemString));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeOemString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlMultiByteToUnicodeN(
    OUT          PWCH    UnicodeString            ,
    IN           ULONG   MaxBytesInUnicodeString  ,
    OUTOPTIONAL  PULONG  BytesInUnicodeString     ,
    IN           PCSTR   MultiByteString          ,
    IN           ULONG   BytesInMultiByteString   );

*/
void EmuApi::EmuRtlMultiByteToUnicodeN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlMultiByteToUnicodeN"); _CrtDbgBreak(); }

    ULONG MaxBytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInUnicodeString);

    PULONG BytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInUnicodeString);

    ULONG rlBytesInUnicodeString{};

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }

    PSTR MultiByteString{};
    uc_reg_read(uc, UC_X86_REG_R9, &MultiByteString);

    std::string rlaMultiByteString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlMultiByteToUnicodeN"); _CrtDbgBreak(); }

    ULONG BytesInMultiByteString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInMultiByteString, sizeof(BytesInMultiByteString));


    NTSTATUS RtlMultiByteToUnicodeNResult = RtlMultiByteToUnicodeN((PWCH)rlwUnicodeString.data(),(ULONG)MaxBytesInUnicodeString,(PULONG)&rlBytesInUnicodeString,(PCSTR)rlaMultiByteString.data(),(ULONG)BytesInMultiByteString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlMultiByteToUnicodeNResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlMultiByteToUnicodeN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInUnicodeString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInUnicodeString);

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlMultiByteToUnicodeN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInMultiByteString, sizeof(BytesInMultiByteString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlMultiByteToUnicodeN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlMultiByteToUnicodeSize(
      PULONG  BytesInUnicodeString    ,
      PCSTR   MultiByteString         ,
      ULONG   BytesInMultiByteString  );

*/
void EmuApi::EmuRtlMultiByteToUnicodeSize(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG BytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BytesInUnicodeString);

    ULONG rlBytesInUnicodeString{};

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }

    PSTR MultiByteString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &MultiByteString);

    std::string rlaMultiByteString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlMultiByteToUnicodeSize"); _CrtDbgBreak(); }

    ULONG BytesInMultiByteString{};
    uc_reg_read(uc, UC_X86_REG_R8D, &BytesInMultiByteString);


    NTSTATUS RtlMultiByteToUnicodeSizeResult = RtlMultiByteToUnicodeSize((PULONG)&rlBytesInUnicodeString,(PCSTR)rlaMultiByteString.data(),(ULONG)BytesInMultiByteString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlMultiByteToUnicodeSizeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BytesInUnicodeString);

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlMultiByteToUnicodeSize"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &BytesInMultiByteString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlMultiByteToUnicodeSize\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeToMultiByteSize(
    OUT  PULONG  BytesInMultiByteString  ,
    IN   PWCH    UnicodeString           ,
    IN   ULONG   BytesInUnicodeString    );

*/
void EmuApi::EmuRtlUnicodeToMultiByteSize(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG BytesInMultiByteString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BytesInMultiByteString);

    ULONG rlBytesInMultiByteString{};

    if(BytesInMultiByteString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInMultiByteString, &rlBytesInMultiByteString, sizeof(rlBytesInMultiByteString));
    }

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToMultiByteSize"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R8D, &BytesInUnicodeString);


    NTSTATUS RtlUnicodeToMultiByteSizeResult = RtlUnicodeToMultiByteSize((PULONG)&rlBytesInMultiByteString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeToMultiByteSizeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BytesInMultiByteString);

    if(BytesInMultiByteString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInMultiByteString, &rlBytesInMultiByteString, sizeof(rlBytesInMultiByteString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToMultiByteSize"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &BytesInUnicodeString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeToMultiByteSize\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeToMultiByteN(
    OUT          PCHAR   MultiByteString            ,
    IN           ULONG   MaxBytesInMultiByteString  ,
    OUTOPTIONAL  PULONG  BytesInMultiByteString     ,
    IN           PWCH    UnicodeString              ,
    IN           ULONG   BytesInUnicodeString       );

*/
void EmuApi::EmuRtlUnicodeToMultiByteN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR MultiByteString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MultiByteString);

    std::string rlaMultiByteString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlUnicodeToMultiByteN"); _CrtDbgBreak(); }

    ULONG MaxBytesInMultiByteString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInMultiByteString);

    PULONG BytesInMultiByteString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInMultiByteString);

    ULONG rlBytesInMultiByteString{};

    if(BytesInMultiByteString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInMultiByteString, &rlBytesInMultiByteString, sizeof(rlBytesInMultiByteString));
    }

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R9, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToMultiByteN"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));


    NTSTATUS RtlUnicodeToMultiByteNResult = RtlUnicodeToMultiByteN((PCHAR)rlaMultiByteString.data(),(ULONG)MaxBytesInMultiByteString,(PULONG)&rlBytesInMultiByteString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeToMultiByteNResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlUnicodeToMultiByteN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInMultiByteString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInMultiByteString);

    if(BytesInMultiByteString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInMultiByteString, &rlBytesInMultiByteString, sizeof(rlBytesInMultiByteString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToMultiByteN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeToMultiByteN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeToMultiByteN(
    OUT          PCHAR   MultiByteString            ,
    IN           ULONG   MaxBytesInMultiByteString  ,
    OUTOPTIONAL  PULONG  BytesInMultiByteString     ,
    IN           PWCH    UnicodeString              ,
    IN           ULONG   BytesInUnicodeString       );

*/
void EmuApi::EmuRtlUpcaseUnicodeToMultiByteN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR MultiByteString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MultiByteString);

    std::string rlaMultiByteString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlUpcaseUnicodeToMultiByteN"); _CrtDbgBreak(); }

    ULONG MaxBytesInMultiByteString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInMultiByteString);

    PULONG BytesInMultiByteString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInMultiByteString);

    ULONG rlBytesInMultiByteString{};

    if(BytesInMultiByteString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInMultiByteString, &rlBytesInMultiByteString, sizeof(rlBytesInMultiByteString));
    }

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R9, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUpcaseUnicodeToMultiByteN"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));


    NTSTATUS RtlUpcaseUnicodeToMultiByteNResult = RtlUpcaseUnicodeToMultiByteN((PCHAR)rlaMultiByteString.data(),(ULONG)MaxBytesInMultiByteString,(PULONG)&rlBytesInMultiByteString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeToMultiByteNResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlUpcaseUnicodeToMultiByteN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInMultiByteString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInMultiByteString);

    if(BytesInMultiByteString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInMultiByteString, &rlBytesInMultiByteString, sizeof(rlBytesInMultiByteString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUpcaseUnicodeToMultiByteN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeToMultiByteN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlOemToUnicodeN(
    OUT          PWSTR   UnicodeString            ,
    IN           ULONG   MaxBytesInUnicodeString  ,
    OUTOPTIONAL  PULONG  BytesInUnicodeString     ,
    IN           PCH     OemString                ,
    IN           ULONG   BytesInOemString         );

*/
void EmuApi::EmuRtlOemToUnicodeN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlOemToUnicodeN"); _CrtDbgBreak(); }

    ULONG MaxBytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInUnicodeString);

    PULONG BytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInUnicodeString);

    ULONG rlBytesInUnicodeString{};

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }

    PCH OemString{};
    uc_reg_read(uc, UC_X86_REG_R9, &OemString);

    std::string rlaOemString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)OemString, rlaOemString)) { printf("Error when read OemString in RtlOemToUnicodeN"); _CrtDbgBreak(); }

    ULONG BytesInOemString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInOemString, sizeof(BytesInOemString));


    NTSTATUS RtlOemToUnicodeNResult = RtlOemToUnicodeN((PWSTR)rlwUnicodeString.data(),(ULONG)MaxBytesInUnicodeString,(PULONG)&rlBytesInUnicodeString,(PCH)rlaOemString.data(),(ULONG)BytesInOemString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlOemToUnicodeNResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlOemToUnicodeN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInUnicodeString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInUnicodeString);

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)OemString, rlaOemString)) { printf("Error when read OemString in RtlOemToUnicodeN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInOemString, sizeof(BytesInOemString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlOemToUnicodeN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeToOemN(
    OUT          PCHAR   OemString             ,
    IN           ULONG   MaxBytesInOemString   ,
    OUTOPTIONAL  PULONG  BytesInOemString      ,
    IN           PWCH    UnicodeString         ,
    IN           ULONG   BytesInUnicodeString  );

*/
void EmuApi::EmuRtlUnicodeToOemN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR OemString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &OemString);

    std::string rlaOemString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)OemString, rlaOemString)) { printf("Error when read OemString in RtlUnicodeToOemN"); _CrtDbgBreak(); }

    ULONG MaxBytesInOemString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInOemString);

    PULONG BytesInOemString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInOemString);

    ULONG rlBytesInOemString{};

    if(BytesInOemString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInOemString, &rlBytesInOemString, sizeof(rlBytesInOemString));
    }

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R9, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToOemN"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));


    NTSTATUS RtlUnicodeToOemNResult = RtlUnicodeToOemN((PCHAR)rlaOemString.data(),(ULONG)MaxBytesInOemString,(PULONG)&rlBytesInOemString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeToOemNResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)OemString, rlaOemString)) { printf("Error when read OemString in RtlUnicodeToOemN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInOemString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInOemString);

    if(BytesInOemString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInOemString, &rlBytesInOemString, sizeof(rlBytesInOemString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToOemN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeToOemN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeToOemN(
    OUT          PCHAR   OemString             ,
    IN           ULONG   MaxBytesInOemString   ,
    OUTOPTIONAL  PULONG  BytesInOemString      ,
    IN           PWCH    UnicodeString         ,
    IN           ULONG   BytesInUnicodeString  );

*/
void EmuApi::EmuRtlUpcaseUnicodeToOemN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR OemString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &OemString);

    std::string rlaOemString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)OemString, rlaOemString)) { printf("Error when read OemString in RtlUpcaseUnicodeToOemN"); _CrtDbgBreak(); }

    ULONG MaxBytesInOemString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInOemString);

    PULONG BytesInOemString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInOemString);

    ULONG rlBytesInOemString{};

    if(BytesInOemString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInOemString, &rlBytesInOemString, sizeof(rlBytesInOemString));
    }

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R9, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUpcaseUnicodeToOemN"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));


    NTSTATUS RtlUpcaseUnicodeToOemNResult = RtlUpcaseUnicodeToOemN((PCHAR)rlaOemString.data(),(ULONG)MaxBytesInOemString,(PULONG)&rlBytesInOemString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeToOemNResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)OemString, rlaOemString)) { printf("Error when read OemString in RtlUpcaseUnicodeToOemN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInOemString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInOemString);

    if(BytesInOemString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInOemString, &rlBytesInOemString, sizeof(rlBytesInOemString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUpcaseUnicodeToOemN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeToOemN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlConsoleMultiByteToUnicodeN(
    OUT          PWCH    UnicodeString            ,
    IN           ULONG   MaxBytesInUnicodeString  ,
    OUTOPTIONAL  PULONG  BytesInUnicodeString     ,
    ,IN          PCH     MultiByteString          ,
    IN           ULONG   BytesInMultiByteString   ,
    OUT          PULONG  pdwSpecialChar           );

*/
void EmuApi::EmuRtlConsoleMultiByteToUnicodeN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlConsoleMultiByteToUnicodeN"); _CrtDbgBreak(); }

    ULONG MaxBytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaxBytesInUnicodeString);

    PULONG BytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R8, &BytesInUnicodeString);

    ULONG rlBytesInUnicodeString{};

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }

    PCH MultiByteString{};
    uc_reg_read(uc, UC_X86_REG_R9, &MultiByteString);

    std::string rlaMultiByteString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlConsoleMultiByteToUnicodeN"); _CrtDbgBreak(); }

    ULONG BytesInMultiByteString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BytesInMultiByteString, sizeof(BytesInMultiByteString));

    PULONG pdwSpecialChar{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &pdwSpecialChar, sizeof(pdwSpecialChar));

    ULONG rlpdwSpecialChar{};

    if(pdwSpecialChar != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pdwSpecialChar, &rlpdwSpecialChar, sizeof(rlpdwSpecialChar));
    }


    NTSTATUS RtlConsoleMultiByteToUnicodeNResult = RtlConsoleMultiByteToUnicodeN((PWCH)rlwUnicodeString.data(),(ULONG)MaxBytesInUnicodeString,(PULONG)&rlBytesInUnicodeString,(PCH)rlaMultiByteString.data(),(ULONG)BytesInMultiByteString,(PULONG)&rlpdwSpecialChar);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlConsoleMultiByteToUnicodeNResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlConsoleMultiByteToUnicodeN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaxBytesInUnicodeString);
    uc_reg_write(uc, UC_X86_REG_R8, &BytesInUnicodeString);

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)MultiByteString, rlaMultiByteString)) { printf("Error when read MultiByteString in RtlConsoleMultiByteToUnicodeN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInMultiByteString, sizeof(BytesInMultiByteString));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &pdwSpecialChar, sizeof(pdwSpecialChar));

    if(pdwSpecialChar != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pdwSpecialChar, &rlpdwSpecialChar, sizeof(rlpdwSpecialChar));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlConsoleMultiByteToUnicodeN\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlIsTextUnicode(
                           const void *  Buffer  ,
    INCONSTVOID*Buffer,IN  ULONG         Size    ,
    INOUT                  PULONG        Result  );

*/
void EmuApi::EmuRtlIsTextUnicode(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    ULONG Size{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Size);

    PULONG Result{};
    uc_reg_read(uc, UC_X86_REG_R8, &Result);

    ULONG rlResult{};

    if(Result != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }


    BOOLEAN RtlIsTextUnicodeResult = RtlIsTextUnicode((PVOID)&Buffer,(ULONG)Size,(PULONG)&rlResult);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlIsTextUnicodeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_EDX, &Size);
    uc_reg_write(uc, UC_X86_REG_R8, &Result);

    if(Result != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsTextUnicode\n";
    #endif

    return;
}







/*
NTSTATUS
__cdecl
RtlGUIDFromString(
    IN   PUNICODE_STRING  GuidString  ,
    OUT  GUID *           Guid        );

*/
void EmuApi::EmuRtlGUIDFromString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING GuidString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &GuidString);

    std::wstring rlwGuidString;

    USHORT rlLengthGuidString;

    USHORT rlMaxLengthGuidString;
    uc_mem_read(uc, (DWORD_PTR)GuidString, &rlLengthGuidString, sizeof(rlLengthGuidString));
    uc_mem_read(uc, (DWORD_PTR)GuidString+16, &rlMaxLengthGuidString, sizeof(rlMaxLengthGuidString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)GuidString+64, rlwGuidString, true, rlLengthGuidString)) { printf("Error when read GuidString in RtlGUIDFromString"); _CrtDbgBreak(); }

    UNICODE_STRING stGuidString{};
    stGuidString.Length = rlLengthGuidString;
    stGuidString.MaximumLength = rlMaxLengthGuidString;
    stGuidString.Buffer = rlwGuidString.data();

    GUID * Guid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Guid);

    GUID stGuid{};

    if(Guid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Guid, &stGuid, sizeof(stGuid));
    }


    NTSTATUS RtlGUIDFromStringResult = RtlGUIDFromString((PUNICODE_STRING)&stGuidString,(GUID *)&stGuid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGUIDFromStringResult);
    uc_mem_write(uc, (DWORD_PTR)GuidString, &stGuidString.Length, sizeof(stGuidString.Length));
    uc_mem_write(uc, (DWORD_PTR)GuidString+16, &stGuidString.MaximumLength, sizeof(stGuidString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)GuidString+64, stGuidString.Buffer, true, stGuidString.Length)) { printf("Error when read GuidString in RtlGUIDFromString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &Guid);

    if(Guid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Guid, &stGuid, sizeof(stGuid));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGUIDFromString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlGenerate8dot3Name(
      PUNICODE_STRING         Name                     ,
      BOOLEAN                 AllowExtendedCharacters  ,
      PGENERATE_NAME_CONTEXT  Context                  ,
      PUNICODE_STRING         Name8dot3                );

*/
void EmuApi::EmuRtlGenerate8dot3Name(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING Name{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Name);

    std::wstring rlwName;

    USHORT rlLengthName;

    USHORT rlMaxLengthName;
    uc_mem_read(uc, (DWORD_PTR)Name, &rlLengthName, sizeof(rlLengthName));
    uc_mem_read(uc, (DWORD_PTR)Name+16, &rlMaxLengthName, sizeof(rlMaxLengthName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Name+64, rlwName, true, rlLengthName)) { printf("Error when read Name in RtlGenerate8dot3Name"); _CrtDbgBreak(); }

    UNICODE_STRING stName{};
    stName.Length = rlLengthName;
    stName.MaximumLength = rlMaxLengthName;
    stName.Buffer = rlwName.data();

    BOOLEAN AllowExtendedCharacters{};
    uc_reg_read(uc, UC_X86_REG_DL, &AllowExtendedCharacters);

    PGENERATE_NAME_CONTEXT Context{};
    uc_reg_read(uc, UC_X86_REG_R8, &Context);

    GENERATE_NAME_CONTEXT rlContext{};

    if(Context != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Context, &rlContext, sizeof(rlContext));
    }

    PUNICODE_STRING Name8dot3{};
    uc_reg_read(uc, UC_X86_REG_R9, &Name8dot3);

    std::wstring rlwName8dot3;

    USHORT rlLengthName8dot3;

    USHORT rlMaxLengthName8dot3;
    uc_mem_read(uc, (DWORD_PTR)Name8dot3, &rlLengthName8dot3, sizeof(rlLengthName8dot3));
    uc_mem_read(uc, (DWORD_PTR)Name8dot3+16, &rlMaxLengthName8dot3, sizeof(rlMaxLengthName8dot3));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Name8dot3+64, rlwName8dot3, true, rlLengthName8dot3)) { printf("Error when read Name8dot3 in RtlGenerate8dot3Name"); _CrtDbgBreak(); }

    UNICODE_STRING stName8dot3{};
    stName8dot3.Length = rlLengthName8dot3;
    stName8dot3.MaximumLength = rlMaxLengthName8dot3;
    stName8dot3.Buffer = rlwName8dot3.data();


    RtlGenerate8dot3Name((PUNICODE_STRING)&stName,(BOOLEAN)AllowExtendedCharacters,(PGENERATE_NAME_CONTEXT)&rlContext,(PUNICODE_STRING)&stName8dot3);


    uc_mem_write(uc, (DWORD_PTR)Name, &stName.Length, sizeof(stName.Length));
    uc_mem_write(uc, (DWORD_PTR)Name+16, &stName.MaximumLength, sizeof(stName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Name+64, stName.Buffer, true, stName.Length)) { printf("Error when read Name in RtlGenerate8dot3Name"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_DL, &AllowExtendedCharacters);
    uc_reg_write(uc, UC_X86_REG_R8, &Context);

    if(Context != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Context, &rlContext, sizeof(rlContext));
    }
    uc_mem_write(uc, (DWORD_PTR)Name8dot3, &stName8dot3.Length, sizeof(stName8dot3.Length));
    uc_mem_write(uc, (DWORD_PTR)Name8dot3+16, &stName8dot3.MaximumLength, sizeof(stName8dot3.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Name8dot3+64, stName8dot3.Buffer, true, stName8dot3.Length)) { printf("Error when read Name8dot3 in RtlGenerate8dot3Name"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGenerate8dot3Name\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitializeContext(
      HANDLE    Process    ,
      PCONTEXT  Context    ,
      PVOID     Parameter  ,
      PVOID     InitialPc  ,
      PVOID     InitialSp  );

*/
void EmuApi::EmuRtlInitializeContext(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Process{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Process);

    PCONTEXT Context{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Context);

    CONTEXT stContext{};

    if(Context != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Context, &stContext, sizeof(stContext));
    }

    PVOID Parameter{};
    uc_reg_read(uc, UC_X86_REG_R8, &Parameter);

    PVOID InitialPc{};
    uc_reg_read(uc, UC_X86_REG_R9, &InitialPc);

    PVOID InitialSp{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &InitialSp, sizeof(InitialSp));


    RtlInitializeContext((HANDLE)Process,(PCONTEXT)&stContext,(PVOID)&Parameter,(PVOID)&InitialPc,(PVOID)&InitialSp);


    uc_reg_write(uc, UC_X86_REG_RCX, &Process);
    uc_reg_write(uc, UC_X86_REG_RDX, &Context);

    if(Context != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Context, &stContext, sizeof(stContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Parameter);
    uc_reg_write(uc, UC_X86_REG_R9, &InitialPc);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &InitialSp, sizeof(InitialSp));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeContext\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlRemoteCall(
      HANDLE      Process           ,
      HANDLE      Thread            ,
      PVOID       CallSite          ,
      ULONG       ArgumentCount     ,
      PULONG_PTR  Arguments         ,
      BOOLEAN     PassContext       ,
      BOOLEAN     AlreadySuspended  );

*/
void EmuApi::EmuRtlRemoteCall(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Process{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Process);

    HANDLE Thread{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Thread);

    PVOID CallSite{};
    uc_reg_read(uc, UC_X86_REG_R8, &CallSite);

    ULONG ArgumentCount{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ArgumentCount);

    PULONG_PTR Arguments{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Arguments, sizeof(Arguments));

    unsigned long long rlArguments{};

    if(Arguments != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Arguments, &rlArguments, sizeof(rlArguments));
    }

    BOOLEAN PassContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PassContext, sizeof(PassContext));

    BOOLEAN AlreadySuspended{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &AlreadySuspended, sizeof(AlreadySuspended));


    NTSTATUS RtlRemoteCallResult = RtlRemoteCall((HANDLE)Process,(HANDLE)Thread,(PVOID)&CallSite,(ULONG)ArgumentCount,(PULONG_PTR)&rlArguments,(BOOLEAN)PassContext,(BOOLEAN)AlreadySuspended);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlRemoteCallResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Process);
    uc_reg_write(uc, UC_X86_REG_RDX, &Thread);
    uc_reg_write(uc, UC_X86_REG_R8, &CallSite);
    uc_reg_write(uc, UC_X86_REG_R9D, &ArgumentCount);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Arguments, sizeof(Arguments));

    if(Arguments != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Arguments, &rlArguments, sizeof(rlArguments));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PassContext, sizeof(PassContext));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &AlreadySuspended, sizeof(AlreadySuspended));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRemoteCall\n";
    #endif

    return;
}


/*
void
__cdecl
RtlAcquirePebLock(VOID);

*/
void EmuApi::EmuRtlAcquirePebLock(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    RtlAcquirePebLock();


    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAcquirePebLock\n";
    #endif

    return;
}


/*
void
__cdecl
RtlReleasePebLock(VOID);

*/
void EmuApi::EmuRtlReleasePebLock(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    RtlReleasePebLock();


    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlReleasePebLock\n";
    #endif

    return;
}

/*
NTSTATUS
__cdecl
RtlSetProcessIsCritical(
    IN   BOOLEAN   NewValue   ,
    OUT  PBOOLEAN  OldValue   ,
    ,IN  BOOLEAN   CheckFlag  );

*/
void EmuApi::EmuRtlSetProcessIsCritical(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN NewValue{};
    uc_reg_read(uc, UC_X86_REG_CL, &NewValue);

    PBOOLEAN OldValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &OldValue);

    BOOLEAN rlOldValue{};

    if(OldValue != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldValue, &rlOldValue, sizeof(rlOldValue));
    }

    BOOLEAN CheckFlag{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CheckFlag);


    NTSTATUS RtlSetProcessIsCriticalResult = RtlSetProcessIsCritical((BOOLEAN)NewValue,(PBOOLEAN)&rlOldValue,(BOOLEAN)CheckFlag);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetProcessIsCriticalResult);
    uc_reg_write(uc, UC_X86_REG_CL, &NewValue);
    uc_reg_write(uc, UC_X86_REG_RDX, &OldValue);

    if(OldValue != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldValue, &rlOldValue, sizeof(rlOldValue));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &CheckFlag);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetProcessIsCritical\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetThreadIsCritical(
    IN   BOOLEAN   NewValue   ,
    OUT  PBOOLEAN  OldValue   ,
    ,IN  BOOLEAN   CheckFlag  );

*/
void EmuApi::EmuRtlSetThreadIsCritical(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN NewValue{};
    uc_reg_read(uc, UC_X86_REG_CL, &NewValue);

    PBOOLEAN OldValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &OldValue);

    BOOLEAN rlOldValue{};

    if(OldValue != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldValue, &rlOldValue, sizeof(rlOldValue));
    }

    BOOLEAN CheckFlag{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CheckFlag);


    NTSTATUS RtlSetThreadIsCriticalResult = RtlSetThreadIsCritical((BOOLEAN)NewValue,(PBOOLEAN)&rlOldValue,(BOOLEAN)CheckFlag);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetThreadIsCriticalResult);
    uc_reg_write(uc, UC_X86_REG_CL, &NewValue);
    uc_reg_write(uc, UC_X86_REG_RDX, &OldValue);

    if(OldValue != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldValue, &rlOldValue, sizeof(rlOldValue));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &CheckFlag);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetThreadIsCritical\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateEnvironment(
      BOOLEAN  CloneCurrentEnvironment  ,
      PVOID *  Environment              );

*/
void EmuApi::EmuRtlCreateEnvironment(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN CloneCurrentEnvironment{};
    uc_reg_read(uc, UC_X86_REG_CL, &CloneCurrentEnvironment);

    PVOID * Environment{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Environment);

    PVOID * dpEnvironment{};

    if(Environment != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Environment, &dpEnvironment, sizeof(dpEnvironment));
    }


    NTSTATUS RtlCreateEnvironmentResult = RtlCreateEnvironment((BOOLEAN)CloneCurrentEnvironment,(PVOID *)&dpEnvironment);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateEnvironmentResult);
    uc_reg_write(uc, UC_X86_REG_CL, &CloneCurrentEnvironment);
    uc_reg_write(uc, UC_X86_REG_RDX, &Environment);

    if(Environment != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Environment, &dpEnvironment, sizeof(dpEnvironment));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateEnvironment\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyEnvironment(
      PVOID  Environment  );

*/
void EmuApi::EmuRtlDestroyEnvironment(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Environment{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Environment);


    NTSTATUS RtlDestroyEnvironmentResult = RtlDestroyEnvironment((PVOID)&Environment);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyEnvironmentResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Environment);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyEnvironment\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetCurrentEnvironment(
      PVOID    Environment          ,
      PVOID *  PreviousEnvironment  );

*/
void EmuApi::EmuRtlSetCurrentEnvironment(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Environment{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Environment);

    PVOID * PreviousEnvironment{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousEnvironment);

    PVOID * dpPreviousEnvironment{};

    if(PreviousEnvironment != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousEnvironment, &dpPreviousEnvironment, sizeof(dpPreviousEnvironment));
    }


    NTSTATUS RtlSetCurrentEnvironmentResult = RtlSetCurrentEnvironment((PVOID)&Environment,(PVOID *)&dpPreviousEnvironment);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetCurrentEnvironmentResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Environment);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousEnvironment);

    if(PreviousEnvironment != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousEnvironment, &dpPreviousEnvironment, sizeof(dpPreviousEnvironment));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetCurrentEnvironment\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetEnvironmentVariable(
      PVOID *           Environment  ,
      PCUNICODE_STRING  Name         ,
      PCUNICODE_STRING  Value        );

*/
void EmuApi::EmuRtlSetEnvironmentVariable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * Environment{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Environment);

    PVOID * dpEnvironment{};

    if(Environment != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Environment, &dpEnvironment, sizeof(dpEnvironment));
    }

    PUNICODE_STRING Name{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Name);

    std::wstring rlwName;

    USHORT rlLengthName;

    USHORT rlMaxLengthName;
    uc_mem_read(uc, (DWORD_PTR)Name, &rlLengthName, sizeof(rlLengthName));
    uc_mem_read(uc, (DWORD_PTR)Name+16, &rlMaxLengthName, sizeof(rlMaxLengthName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Name+64, rlwName, true, rlLengthName)) { printf("Error when read Name in RtlSetEnvironmentVariable"); _CrtDbgBreak(); }

    UNICODE_STRING stName{};
    stName.Length = rlLengthName;
    stName.MaximumLength = rlMaxLengthName;
    stName.Buffer = rlwName.data();

    PUNICODE_STRING Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    std::wstring rlwValue;

    USHORT rlLengthValue;

    USHORT rlMaxLengthValue;
    uc_mem_read(uc, (DWORD_PTR)Value, &rlLengthValue, sizeof(rlLengthValue));
    uc_mem_read(uc, (DWORD_PTR)Value+16, &rlMaxLengthValue, sizeof(rlMaxLengthValue));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Value+64, rlwValue, true, rlLengthValue)) { printf("Error when read Value in RtlSetEnvironmentVariable"); _CrtDbgBreak(); }

    UNICODE_STRING stValue{};
    stValue.Length = rlLengthValue;
    stValue.MaximumLength = rlMaxLengthValue;
    stValue.Buffer = rlwValue.data();


    NTSTATUS RtlSetEnvironmentVariableResult = RtlSetEnvironmentVariable((PVOID *)&dpEnvironment,(PUNICODE_STRING)&stName,(PUNICODE_STRING)&stValue);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetEnvironmentVariableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Environment);

    if(Environment != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Environment, &dpEnvironment, sizeof(dpEnvironment));
    }
    uc_mem_write(uc, (DWORD_PTR)Name, &stName.Length, sizeof(stName.Length));
    uc_mem_write(uc, (DWORD_PTR)Name+16, &stName.MaximumLength, sizeof(stName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Name+64, stName.Buffer, true, stName.Length)) { printf("Error when read Name in RtlSetEnvironmentVariable"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)Value, &stValue.Length, sizeof(stValue.Length));
    uc_mem_write(uc, (DWORD_PTR)Value+16, &stValue.MaximumLength, sizeof(stValue.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Value+64, stValue.Buffer, true, stValue.Length)) { printf("Error when read Value in RtlSetEnvironmentVariable"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetEnvironmentVariable\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlIsDosDeviceName_U(
    IN  PWSTR  DosFileName  );

*/
void EmuApi::EmuRtlIsDosDeviceName_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR DosFileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DosFileName);

    std::wstring rlwDosFileName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DosFileName, rlwDosFileName)) { printf("Error when read DosFileName in RtlIsDosDeviceName_U"); _CrtDbgBreak(); }


    ULONG RtlIsDosDeviceName_UResult = RtlIsDosDeviceName_U((PWSTR)rlwDosFileName.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIsDosDeviceName_UResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DosFileName, rlwDosFileName)) { printf("Error when read DosFileName in RtlIsDosDeviceName_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsDosDeviceName_U\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryEnvironmentVariable_U(
      PVOID             Environment  ,
      PCUNICODE_STRING  Name         ,
      PUNICODE_STRING   Value        );

*/
void EmuApi::EmuRtlQueryEnvironmentVariable_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Environment{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Environment);

    PUNICODE_STRING Name{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Name);

    std::wstring rlwName;

    USHORT rlLengthName;

    USHORT rlMaxLengthName;
    uc_mem_read(uc, (DWORD_PTR)Name, &rlLengthName, sizeof(rlLengthName));
    uc_mem_read(uc, (DWORD_PTR)Name+16, &rlMaxLengthName, sizeof(rlMaxLengthName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Name+64, rlwName, true, rlLengthName)) { printf("Error when read Name in RtlQueryEnvironmentVariable_U"); _CrtDbgBreak(); }

    UNICODE_STRING stName{};
    stName.Length = rlLengthName;
    stName.MaximumLength = rlMaxLengthName;
    stName.Buffer = rlwName.data();

    PUNICODE_STRING Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    std::wstring rlwValue;

    USHORT rlLengthValue;

    USHORT rlMaxLengthValue;
    uc_mem_read(uc, (DWORD_PTR)Value, &rlLengthValue, sizeof(rlLengthValue));
    uc_mem_read(uc, (DWORD_PTR)Value+16, &rlMaxLengthValue, sizeof(rlMaxLengthValue));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Value+64, rlwValue, true, rlLengthValue)) { printf("Error when read Value in RtlQueryEnvironmentVariable_U"); _CrtDbgBreak(); }

    UNICODE_STRING stValue{};
    stValue.Length = rlLengthValue;
    stValue.MaximumLength = rlMaxLengthValue;
    stValue.Buffer = rlwValue.data();


    NTSTATUS RtlQueryEnvironmentVariable_UResult = RtlQueryEnvironmentVariable_U((PVOID)&Environment,(PUNICODE_STRING)&stName,(PUNICODE_STRING)&stValue);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryEnvironmentVariable_UResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Environment);
    uc_mem_write(uc, (DWORD_PTR)Name, &stName.Length, sizeof(stName.Length));
    uc_mem_write(uc, (DWORD_PTR)Name+16, &stName.MaximumLength, sizeof(stName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Name+64, stName.Buffer, true, stName.Length)) { printf("Error when read Name in RtlQueryEnvironmentVariable_U"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)Value, &stValue.Length, sizeof(stValue.Length));
    uc_mem_write(uc, (DWORD_PTR)Value+16, &stValue.MaximumLength, sizeof(stValue.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Value+64, stValue.Buffer, true, stValue.Length)) { printf("Error when read Value in RtlQueryEnvironmentVariable_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryEnvironmentVariable_U\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlExpandEnvironmentStrings_U(
    IN   PVOID             Environment     ,
    ,IN  PCUNICODE_STRING  Source          ,
    OUT  PUNICODE_STRING   Destination     ,
    OUT  PULONG            ReturnedLength  );

*/
void EmuApi::EmuRtlExpandEnvironmentStrings_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Environment{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Environment);

    PUNICODE_STRING Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    std::wstring rlwSource;

    USHORT rlLengthSource;

    USHORT rlMaxLengthSource;
    uc_mem_read(uc, (DWORD_PTR)Source, &rlLengthSource, sizeof(rlLengthSource));
    uc_mem_read(uc, (DWORD_PTR)Source+16, &rlMaxLengthSource, sizeof(rlMaxLengthSource));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Source+64, rlwSource, true, rlLengthSource)) { printf("Error when read Source in RtlExpandEnvironmentStrings_U"); _CrtDbgBreak(); }

    UNICODE_STRING stSource{};
    stSource.Length = rlLengthSource;
    stSource.MaximumLength = rlMaxLengthSource;
    stSource.Buffer = rlwSource.data();

    PUNICODE_STRING Destination{};
    uc_reg_read(uc, UC_X86_REG_R8, &Destination);

    std::wstring rlwDestination;

    USHORT rlLengthDestination;

    USHORT rlMaxLengthDestination;
    uc_mem_read(uc, (DWORD_PTR)Destination, &rlLengthDestination, sizeof(rlLengthDestination));
    uc_mem_read(uc, (DWORD_PTR)Destination+16, &rlMaxLengthDestination, sizeof(rlMaxLengthDestination));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Destination+64, rlwDestination, true, rlLengthDestination)) { printf("Error when read Destination in RtlExpandEnvironmentStrings_U"); _CrtDbgBreak(); }

    UNICODE_STRING stDestination{};
    stDestination.Length = rlLengthDestination;
    stDestination.MaximumLength = rlMaxLengthDestination;
    stDestination.Buffer = rlwDestination.data();

    PULONG ReturnedLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReturnedLength);

    ULONG rlReturnedLength{};

    if(ReturnedLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnedLength, &rlReturnedLength, sizeof(rlReturnedLength));
    }


    NTSTATUS RtlExpandEnvironmentStrings_UResult = RtlExpandEnvironmentStrings_U((PVOID)&Environment,(PUNICODE_STRING)&stSource,(PUNICODE_STRING)&stDestination,(PULONG)&rlReturnedLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlExpandEnvironmentStrings_UResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Environment);
    uc_mem_write(uc, (DWORD_PTR)Source, &stSource.Length, sizeof(stSource.Length));
    uc_mem_write(uc, (DWORD_PTR)Source+16, &stSource.MaximumLength, sizeof(stSource.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Source+64, stSource.Buffer, true, stSource.Length)) { printf("Error when read Source in RtlExpandEnvironmentStrings_U"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)Destination, &stDestination.Length, sizeof(stDestination.Length));
    uc_mem_write(uc, (DWORD_PTR)Destination+16, &stDestination.MaximumLength, sizeof(stDestination.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Destination+64, stDestination.Buffer, true, stDestination.Length)) { printf("Error when read Destination in RtlExpandEnvironmentStrings_U"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &ReturnedLength);

    if(ReturnedLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnedLength, &rlReturnedLength, sizeof(rlReturnedLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlExpandEnvironmentStrings_U\n";
    #endif

    return;
}


/*
void
__cdecl
PfxInitialize(
      PPREFIX_TABLE  PrefixTable  );

*/
void EmuApi::EmuPfxInitialize(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PPREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }


    PfxInitialize((PPREFIX_TABLE)&rlPrefixTable);


    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuPfxInitialize\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
PfxInsertPrefix(
      PPREFIX_TABLE        PrefixTable       ,
      PSTRING              Prefix            ,
      PPREFIX_TABLE_ENTRY  PrefixTableEntry  );

*/
void EmuApi::EmuPfxInsertPrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PPREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    PSTRING Prefix{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Prefix);

    STRING rlPrefix{};

    if(Prefix != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Prefix, &rlPrefix, sizeof(rlPrefix));
    }

    PPREFIX_TABLE_ENTRY PrefixTableEntry{};
    uc_reg_read(uc, UC_X86_REG_R8, &PrefixTableEntry);

    PREFIX_TABLE_ENTRY rlPrefixTableEntry{};

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }


    BOOLEAN PfxInsertPrefixResult = PfxInsertPrefix((PPREFIX_TABLE)&rlPrefixTable,(PSTRING)&rlPrefix,(PPREFIX_TABLE_ENTRY)&rlPrefixTableEntry);


    uc_reg_write(uc, UC_X86_REG_AL, &PfxInsertPrefixResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Prefix);

    if(Prefix != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Prefix, &rlPrefix, sizeof(rlPrefix));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &PrefixTableEntry);

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuPfxInsertPrefix\n";
    #endif

    return;
}


/*
void
__cdecl
PfxRemovePrefix(
      PPREFIX_TABLE        PrefixTable       ,
      PPREFIX_TABLE_ENTRY  PrefixTableEntry  );

*/
void EmuApi::EmuPfxRemovePrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PPREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    PPREFIX_TABLE_ENTRY PrefixTableEntry{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PrefixTableEntry);

    PREFIX_TABLE_ENTRY rlPrefixTableEntry{};

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }


    PfxRemovePrefix((PPREFIX_TABLE)&rlPrefixTable,(PPREFIX_TABLE_ENTRY)&rlPrefixTableEntry);


    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PrefixTableEntry);

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuPfxRemovePrefix\n";
    #endif

    return;
}


/*
PPREFIX_TABLE_ENTRY
__cdecl
PfxFindPrefix(
      PPREFIX_TABLE  PrefixTable  ,
      PSTRING        FullName     );

*/
void EmuApi::EmuPfxFindPrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PPREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    PSTRING FullName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FullName);

    STRING rlFullName{};

    if(FullName != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FullName, &rlFullName, sizeof(rlFullName));
    }


    PPREFIX_TABLE_ENTRY PfxFindPrefixResult = PfxFindPrefix((PPREFIX_TABLE)&rlPrefixTable,(PSTRING)&rlFullName);


    uc_reg_write(uc, UC_X86_REG_RAX, &PfxFindPrefixResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &FullName);

    if(FullName != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FullName, &rlFullName, sizeof(rlFullName));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuPfxFindPrefix\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitializeUnicodePrefix(
      PUNICODE_PREFIX_TABLE  PrefixTable  );

*/
void EmuApi::EmuRtlInitializeUnicodePrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_PREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    UNICODE_PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }


    RtlInitializeUnicodePrefix((PUNICODE_PREFIX_TABLE)&rlPrefixTable);


    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeUnicodePrefix\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlInsertUnicodePrefix(
      PUNICODE_PREFIX_TABLE        PrefixTable       ,
      PUNICODE_STRING              Prefix            ,
      PUNICODE_PREFIX_TABLE_ENTRY  PrefixTableEntry  );

*/
void EmuApi::EmuRtlInsertUnicodePrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_PREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    UNICODE_PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    PUNICODE_STRING Prefix{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Prefix);

    std::wstring rlwPrefix;

    USHORT rlLengthPrefix;

    USHORT rlMaxLengthPrefix;
    uc_mem_read(uc, (DWORD_PTR)Prefix, &rlLengthPrefix, sizeof(rlLengthPrefix));
    uc_mem_read(uc, (DWORD_PTR)Prefix+16, &rlMaxLengthPrefix, sizeof(rlMaxLengthPrefix));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Prefix+64, rlwPrefix, true, rlLengthPrefix)) { printf("Error when read Prefix in RtlInsertUnicodePrefix"); _CrtDbgBreak(); }

    UNICODE_STRING stPrefix{};
    stPrefix.Length = rlLengthPrefix;
    stPrefix.MaximumLength = rlMaxLengthPrefix;
    stPrefix.Buffer = rlwPrefix.data();

    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry{};
    uc_reg_read(uc, UC_X86_REG_R8, &PrefixTableEntry);

    UNICODE_PREFIX_TABLE_ENTRY rlPrefixTableEntry{};

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }


    BOOLEAN RtlInsertUnicodePrefixResult = RtlInsertUnicodePrefix((PUNICODE_PREFIX_TABLE)&rlPrefixTable,(PUNICODE_STRING)&stPrefix,(PUNICODE_PREFIX_TABLE_ENTRY)&rlPrefixTableEntry);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlInsertUnicodePrefixResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_mem_write(uc, (DWORD_PTR)Prefix, &stPrefix.Length, sizeof(stPrefix.Length));
    uc_mem_write(uc, (DWORD_PTR)Prefix+16, &stPrefix.MaximumLength, sizeof(stPrefix.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Prefix+64, stPrefix.Buffer, true, stPrefix.Length)) { printf("Error when read Prefix in RtlInsertUnicodePrefix"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &PrefixTableEntry);

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInsertUnicodePrefix\n";
    #endif

    return;
}


/*
void
__cdecl
RtlRemoveUnicodePrefix(
      PUNICODE_PREFIX_TABLE        PrefixTable       ,
      PUNICODE_PREFIX_TABLE_ENTRY  PrefixTableEntry  );

*/
void EmuApi::EmuRtlRemoveUnicodePrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_PREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    UNICODE_PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PrefixTableEntry);

    UNICODE_PREFIX_TABLE_ENTRY rlPrefixTableEntry{};

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }


    RtlRemoveUnicodePrefix((PUNICODE_PREFIX_TABLE)&rlPrefixTable,(PUNICODE_PREFIX_TABLE_ENTRY)&rlPrefixTableEntry);


    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PrefixTableEntry);

    if(PrefixTableEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTableEntry, &rlPrefixTableEntry, sizeof(rlPrefixTableEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRemoveUnicodePrefix\n";
    #endif

    return;
}


/*
PUNICODE_PREFIX_TABLE_ENTRY
__cdecl
RtlFindUnicodePrefix(
      PUNICODE_PREFIX_TABLE  PrefixTable           ,
      PUNICODE_STRING        FullName              ,
      ULONG                  CaseInsensitiveIndex  );

*/
void EmuApi::EmuRtlFindUnicodePrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_PREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    UNICODE_PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    PUNICODE_STRING FullName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FullName);

    std::wstring rlwFullName;

    USHORT rlLengthFullName;

    USHORT rlMaxLengthFullName;
    uc_mem_read(uc, (DWORD_PTR)FullName, &rlLengthFullName, sizeof(rlLengthFullName));
    uc_mem_read(uc, (DWORD_PTR)FullName+16, &rlMaxLengthFullName, sizeof(rlMaxLengthFullName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)FullName+64, rlwFullName, true, rlLengthFullName)) { printf("Error when read FullName in RtlFindUnicodePrefix"); _CrtDbgBreak(); }

    UNICODE_STRING stFullName{};
    stFullName.Length = rlLengthFullName;
    stFullName.MaximumLength = rlMaxLengthFullName;
    stFullName.Buffer = rlwFullName.data();

    ULONG CaseInsensitiveIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &CaseInsensitiveIndex);


    PUNICODE_PREFIX_TABLE_ENTRY RtlFindUnicodePrefixResult = RtlFindUnicodePrefix((PUNICODE_PREFIX_TABLE)&rlPrefixTable,(PUNICODE_STRING)&stFullName,(ULONG)CaseInsensitiveIndex);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlFindUnicodePrefixResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_mem_write(uc, (DWORD_PTR)FullName, &stFullName.Length, sizeof(stFullName.Length));
    uc_mem_write(uc, (DWORD_PTR)FullName+16, &stFullName.MaximumLength, sizeof(stFullName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)FullName+64, stFullName.Buffer, true, stFullName.Length)) { printf("Error when read FullName in RtlFindUnicodePrefix"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &CaseInsensitiveIndex);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindUnicodePrefix\n";
    #endif

    return;
}


/*
PUNICODE_PREFIX_TABLE_ENTRY
__cdecl
RtlNextUnicodePrefix(
      PUNICODE_PREFIX_TABLE  PrefixTable  ,
      BOOLEAN                Restart      );

*/
void EmuApi::EmuRtlNextUnicodePrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_PREFIX_TABLE PrefixTable{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PrefixTable);

    UNICODE_PREFIX_TABLE rlPrefixTable{};

    if(PrefixTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }

    BOOLEAN Restart{};
    uc_reg_read(uc, UC_X86_REG_DL, &Restart);


    PUNICODE_PREFIX_TABLE_ENTRY RtlNextUnicodePrefixResult = RtlNextUnicodePrefix((PUNICODE_PREFIX_TABLE)&rlPrefixTable,(BOOLEAN)Restart);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlNextUnicodePrefixResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PrefixTable);

    if(PrefixTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrefixTable, &rlPrefixTable, sizeof(rlPrefixTable));
    }
    uc_reg_write(uc, UC_X86_REG_DL, &Restart);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNextUnicodePrefix\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetCompressionWorkSpaceSize(
    IN   USHORT  CompressionFormatAndEngine     ,
    OUT  PULONG  CompressBufferWorkSpaceSize    ,
    OUT  PULONG  CompressFragmentWorkSpaceSize  );

*/
void EmuApi::EmuRtlGetCompressionWorkSpaceSize(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT CompressionFormatAndEngine{};
    uc_reg_read(uc, UC_X86_REG_CX, &CompressionFormatAndEngine);

    PULONG CompressBufferWorkSpaceSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CompressBufferWorkSpaceSize);

    ULONG rlCompressBufferWorkSpaceSize{};

    if(CompressBufferWorkSpaceSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressBufferWorkSpaceSize, &rlCompressBufferWorkSpaceSize, sizeof(rlCompressBufferWorkSpaceSize));
    }

    PULONG CompressFragmentWorkSpaceSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &CompressFragmentWorkSpaceSize);

    ULONG rlCompressFragmentWorkSpaceSize{};

    if(CompressFragmentWorkSpaceSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressFragmentWorkSpaceSize, &rlCompressFragmentWorkSpaceSize, sizeof(rlCompressFragmentWorkSpaceSize));
    }


    NTSTATUS RtlGetCompressionWorkSpaceSizeResult = RtlGetCompressionWorkSpaceSize((USHORT)CompressionFormatAndEngine,(PULONG)&rlCompressBufferWorkSpaceSize,(PULONG)&rlCompressFragmentWorkSpaceSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetCompressionWorkSpaceSizeResult);
    uc_reg_write(uc, UC_X86_REG_CX, &CompressionFormatAndEngine);
    uc_reg_write(uc, UC_X86_REG_RDX, &CompressBufferWorkSpaceSize);

    if(CompressBufferWorkSpaceSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressBufferWorkSpaceSize, &rlCompressBufferWorkSpaceSize, sizeof(rlCompressBufferWorkSpaceSize));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &CompressFragmentWorkSpaceSize);

    if(CompressFragmentWorkSpaceSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressFragmentWorkSpaceSize, &rlCompressFragmentWorkSpaceSize, sizeof(rlCompressFragmentWorkSpaceSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCompressionWorkSpaceSize\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCompressBuffer(
    IN   USHORT  CompressionFormatAndEngine  ,
    IN   PUCHAR  UncompressedBuffer          ,
    IN   ULONG   UncompressedBufferSize      ,
    OUT  PUCHAR  CompressedBuffer            ,
    IN   ULONG   CompressedBufferSize        ,
    IN   ULONG   UncompressedChunkSize       ,
    OUT  PULONG  FinalCompressedSize         ,
    IN   PVOID   WorkSpace                   );

*/
void EmuApi::EmuRtlCompressBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT CompressionFormatAndEngine{};
    uc_reg_read(uc, UC_X86_REG_CX, &CompressionFormatAndEngine);

    PUCHAR UncompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UncompressedBuffer);

    UCHAR rlUncompressedBuffer{};

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }

    ULONG UncompressedBufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &UncompressedBufferSize);

    PUCHAR CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &CompressedBuffer);

    UCHAR rlCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    ULONG CompressedBufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CompressedBufferSize, sizeof(CompressedBufferSize));

    ULONG UncompressedChunkSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &UncompressedChunkSize, sizeof(UncompressedChunkSize));

    PULONG FinalCompressedSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &FinalCompressedSize, sizeof(FinalCompressedSize));

    ULONG rlFinalCompressedSize{};

    if(FinalCompressedSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FinalCompressedSize, &rlFinalCompressedSize, sizeof(rlFinalCompressedSize));
    }

    PVOID WorkSpace{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &WorkSpace, sizeof(WorkSpace));


    NTSTATUS RtlCompressBufferResult = RtlCompressBuffer((USHORT)CompressionFormatAndEngine,(PUCHAR)&rlUncompressedBuffer,(ULONG)UncompressedBufferSize,(PUCHAR)&rlCompressedBuffer,(ULONG)CompressedBufferSize,(ULONG)UncompressedChunkSize,(PULONG)&rlFinalCompressedSize,(PVOID)&WorkSpace);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCompressBufferResult);
    uc_reg_write(uc, UC_X86_REG_CX, &CompressionFormatAndEngine);
    uc_reg_write(uc, UC_X86_REG_RDX, &UncompressedBuffer);

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &UncompressedBufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CompressedBufferSize, sizeof(CompressedBufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &UncompressedChunkSize, sizeof(UncompressedChunkSize));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &FinalCompressedSize, sizeof(FinalCompressedSize));

    if(FinalCompressedSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FinalCompressedSize, &rlFinalCompressedSize, sizeof(rlFinalCompressedSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &WorkSpace, sizeof(WorkSpace));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCompressBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDecompressBuffer(
    IN   USHORT  CompressionFormat       ,
    OUT  PUCHAR  UncompressedBuffer      ,
    IN   ULONG   UncompressedBufferSize  ,
    IN   PUCHAR  CompressedBuffer        ,
    IN   ULONG   CompressedBufferSize    ,
    OUT  PULONG  FinalUncompressedSize   );

*/
void EmuApi::EmuRtlDecompressBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT CompressionFormat{};
    uc_reg_read(uc, UC_X86_REG_CX, &CompressionFormat);

    PUCHAR UncompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UncompressedBuffer);

    UCHAR rlUncompressedBuffer{};

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }

    ULONG UncompressedBufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &UncompressedBufferSize);

    PUCHAR CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &CompressedBuffer);

    UCHAR rlCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    ULONG CompressedBufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CompressedBufferSize, sizeof(CompressedBufferSize));

    PULONG FinalUncompressedSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FinalUncompressedSize, sizeof(FinalUncompressedSize));

    ULONG rlFinalUncompressedSize{};

    if(FinalUncompressedSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FinalUncompressedSize, &rlFinalUncompressedSize, sizeof(rlFinalUncompressedSize));
    }


    NTSTATUS RtlDecompressBufferResult = RtlDecompressBuffer((USHORT)CompressionFormat,(PUCHAR)&rlUncompressedBuffer,(ULONG)UncompressedBufferSize,(PUCHAR)&rlCompressedBuffer,(ULONG)CompressedBufferSize,(PULONG)&rlFinalUncompressedSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDecompressBufferResult);
    uc_reg_write(uc, UC_X86_REG_CX, &CompressionFormat);
    uc_reg_write(uc, UC_X86_REG_RDX, &UncompressedBuffer);

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &UncompressedBufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CompressedBufferSize, sizeof(CompressedBufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FinalUncompressedSize, sizeof(FinalUncompressedSize));

    if(FinalUncompressedSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FinalUncompressedSize, &rlFinalUncompressedSize, sizeof(rlFinalUncompressedSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDecompressBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDecompressFragment(
    IN   USHORT  CompressionFormat         ,
    OUT  PUCHAR  UncompressedFragment      ,
    IN   ULONG   UncompressedFragmentSize  ,
    IN   PUCHAR  CompressedBuffer          ,
    IN   ULONG   CompressedBufferSize      ,
    IN   ULONG   FragmentOffset            ,
    OUT  PULONG  FinalUncompressedSize     ,
    IN   PVOID   WorkSpace                 );

*/
void EmuApi::EmuRtlDecompressFragment(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT CompressionFormat{};
    uc_reg_read(uc, UC_X86_REG_CX, &CompressionFormat);

    PUCHAR UncompressedFragment{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UncompressedFragment);

    UCHAR rlUncompressedFragment{};

    if(UncompressedFragment != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UncompressedFragment, &rlUncompressedFragment, sizeof(rlUncompressedFragment));
    }

    ULONG UncompressedFragmentSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &UncompressedFragmentSize);

    PUCHAR CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &CompressedBuffer);

    UCHAR rlCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    ULONG CompressedBufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CompressedBufferSize, sizeof(CompressedBufferSize));

    ULONG FragmentOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FragmentOffset, sizeof(FragmentOffset));

    PULONG FinalUncompressedSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &FinalUncompressedSize, sizeof(FinalUncompressedSize));

    ULONG rlFinalUncompressedSize{};

    if(FinalUncompressedSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FinalUncompressedSize, &rlFinalUncompressedSize, sizeof(rlFinalUncompressedSize));
    }

    PVOID WorkSpace{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &WorkSpace, sizeof(WorkSpace));


    NTSTATUS RtlDecompressFragmentResult = RtlDecompressFragment((USHORT)CompressionFormat,(PUCHAR)&rlUncompressedFragment,(ULONG)UncompressedFragmentSize,(PUCHAR)&rlCompressedBuffer,(ULONG)CompressedBufferSize,(ULONG)FragmentOffset,(PULONG)&rlFinalUncompressedSize,(PVOID)&WorkSpace);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDecompressFragmentResult);
    uc_reg_write(uc, UC_X86_REG_CX, &CompressionFormat);
    uc_reg_write(uc, UC_X86_REG_RDX, &UncompressedFragment);

    if(UncompressedFragment != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UncompressedFragment, &rlUncompressedFragment, sizeof(rlUncompressedFragment));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &UncompressedFragmentSize);
    uc_reg_write(uc, UC_X86_REG_R9, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CompressedBufferSize, sizeof(CompressedBufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FragmentOffset, sizeof(FragmentOffset));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &FinalUncompressedSize, sizeof(FinalUncompressedSize));

    if(FinalUncompressedSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FinalUncompressedSize, &rlFinalUncompressedSize, sizeof(rlFinalUncompressedSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &WorkSpace, sizeof(WorkSpace));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDecompressFragment\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDescribeChunk(
    IN     USHORT    CompressionFormat           ,
    INOUT  PUCHAR *  CompressedBuffer            ,
    IN     PUCHAR    EndOfCompressedBufferPlus1  ,
    OUT    PUCHAR *  ChunkBuffer                 ,
    OUT    PULONG    ChunkSize                   );

*/
void EmuApi::EmuRtlDescribeChunk(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT CompressionFormat{};
    uc_reg_read(uc, UC_X86_REG_CX, &CompressionFormat);

    PUCHAR * CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CompressedBuffer);

    PUCHAR * dpCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &dpCompressedBuffer, sizeof(dpCompressedBuffer));
    }

    UCHAR rlCompressedBuffer{};

    if(dpCompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpCompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    PUCHAR EndOfCompressedBufferPlus1{};
    uc_reg_read(uc, UC_X86_REG_R8, &EndOfCompressedBufferPlus1);

    UCHAR rlEndOfCompressedBufferPlus1{};

    if(EndOfCompressedBufferPlus1 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EndOfCompressedBufferPlus1, &rlEndOfCompressedBufferPlus1, sizeof(rlEndOfCompressedBufferPlus1));
    }

    PUCHAR * ChunkBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &ChunkBuffer);

    PUCHAR * dpChunkBuffer{};

    if(ChunkBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ChunkBuffer, &dpChunkBuffer, sizeof(dpChunkBuffer));
    }

    UCHAR rlChunkBuffer{};

    if(dpChunkBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpChunkBuffer, &rlChunkBuffer, sizeof(rlChunkBuffer));
    }

    PULONG ChunkSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ChunkSize, sizeof(ChunkSize));

    ULONG rlChunkSize{};

    if(ChunkSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ChunkSize, &rlChunkSize, sizeof(rlChunkSize));
    }


    NTSTATUS RtlDescribeChunkResult = RtlDescribeChunk((USHORT)CompressionFormat,(PUCHAR *)&rlCompressedBuffer,(PUCHAR)&rlEndOfCompressedBufferPlus1,(PUCHAR *)&rlChunkBuffer,(PULONG)&rlChunkSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDescribeChunkResult);
    uc_reg_write(uc, UC_X86_REG_CX, &CompressionFormat);
    uc_reg_write(uc, UC_X86_REG_RDX, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &dpCompressedBuffer, sizeof(dpCompressedBuffer));
    }

    if(dpCompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpCompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &EndOfCompressedBufferPlus1);

    if(EndOfCompressedBufferPlus1 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EndOfCompressedBufferPlus1, &rlEndOfCompressedBufferPlus1, sizeof(rlEndOfCompressedBufferPlus1));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ChunkBuffer);

    if(ChunkBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ChunkBuffer, &dpChunkBuffer, sizeof(dpChunkBuffer));
    }

    if(dpChunkBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpChunkBuffer, &rlChunkBuffer, sizeof(rlChunkBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ChunkSize, sizeof(ChunkSize));

    if(ChunkSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ChunkSize, &rlChunkSize, sizeof(rlChunkSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDescribeChunk\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlReserveChunk(
    IN     USHORT    CompressionFormat           ,
    INOUT  PUCHAR *  CompressedBuffer            ,
    IN     PUCHAR    EndOfCompressedBufferPlus1  ,
    OUT    PUCHAR *  ChunkBuffer                 ,
    IN     ULONG     ChunkSize                   );

*/
void EmuApi::EmuRtlReserveChunk(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT CompressionFormat{};
    uc_reg_read(uc, UC_X86_REG_CX, &CompressionFormat);

    PUCHAR * CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CompressedBuffer);

    PUCHAR * dpCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &dpCompressedBuffer, sizeof(dpCompressedBuffer));
    }

    UCHAR rlCompressedBuffer{};

    if(dpCompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpCompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    PUCHAR EndOfCompressedBufferPlus1{};
    uc_reg_read(uc, UC_X86_REG_R8, &EndOfCompressedBufferPlus1);

    UCHAR rlEndOfCompressedBufferPlus1{};

    if(EndOfCompressedBufferPlus1 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EndOfCompressedBufferPlus1, &rlEndOfCompressedBufferPlus1, sizeof(rlEndOfCompressedBufferPlus1));
    }

    PUCHAR * ChunkBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &ChunkBuffer);

    PUCHAR * dpChunkBuffer{};

    if(ChunkBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ChunkBuffer, &dpChunkBuffer, sizeof(dpChunkBuffer));
    }

    UCHAR rlChunkBuffer{};

    if(dpChunkBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpChunkBuffer, &rlChunkBuffer, sizeof(rlChunkBuffer));
    }

    ULONG ChunkSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ChunkSize, sizeof(ChunkSize));


    NTSTATUS RtlReserveChunkResult = RtlReserveChunk((USHORT)CompressionFormat,(PUCHAR *)&rlCompressedBuffer,(PUCHAR)&rlEndOfCompressedBufferPlus1,(PUCHAR *)&rlChunkBuffer,(ULONG)ChunkSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlReserveChunkResult);
    uc_reg_write(uc, UC_X86_REG_CX, &CompressionFormat);
    uc_reg_write(uc, UC_X86_REG_RDX, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &dpCompressedBuffer, sizeof(dpCompressedBuffer));
    }

    if(dpCompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpCompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &EndOfCompressedBufferPlus1);

    if(EndOfCompressedBufferPlus1 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EndOfCompressedBufferPlus1, &rlEndOfCompressedBufferPlus1, sizeof(rlEndOfCompressedBufferPlus1));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ChunkBuffer);

    if(ChunkBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ChunkBuffer, &dpChunkBuffer, sizeof(dpChunkBuffer));
    }

    if(dpChunkBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpChunkBuffer, &rlChunkBuffer, sizeof(rlChunkBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ChunkSize, sizeof(ChunkSize));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlReserveChunk\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDecompressChunks(
    OUT  PUCHAR                 UncompressedBuffer      ,
    IN   ULONG                  UncompressedBufferSize  ,
    IN   PUCHAR                 CompressedBuffer        ,
    IN   ULONG                  CompressedBufferSize    ,
    IN   PUCHAR                 CompressedTail          ,
    IN   ULONG                  CompressedTailSize      ,
    IN   PCOMPRESSED_DATA_INFO  CompressedDataInfo      );

*/
void EmuApi::EmuRtlDecompressChunks(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUCHAR UncompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UncompressedBuffer);

    UCHAR rlUncompressedBuffer{};

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }

    ULONG UncompressedBufferSize{};
    uc_reg_read(uc, UC_X86_REG_EDX, &UncompressedBufferSize);

    PUCHAR CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &CompressedBuffer);

    UCHAR rlCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    ULONG CompressedBufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9D, &CompressedBufferSize);

    PUCHAR CompressedTail{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CompressedTail, sizeof(CompressedTail));

    UCHAR rlCompressedTail{};

    if(CompressedTail != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedTail, &rlCompressedTail, sizeof(rlCompressedTail));
    }

    ULONG CompressedTailSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CompressedTailSize, sizeof(CompressedTailSize));

    PCOMPRESSED_DATA_INFO CompressedDataInfo{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &CompressedDataInfo, sizeof(CompressedDataInfo));

    COMPRESSED_DATA_INFO rlCompressedDataInfo{};

    if(CompressedDataInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedDataInfo, &rlCompressedDataInfo, sizeof(rlCompressedDataInfo));
    }


    NTSTATUS RtlDecompressChunksResult = RtlDecompressChunks((PUCHAR)&rlUncompressedBuffer,(ULONG)UncompressedBufferSize,(PUCHAR)&rlCompressedBuffer,(ULONG)CompressedBufferSize,(PUCHAR)&rlCompressedTail,(ULONG)CompressedTailSize,(PCOMPRESSED_DATA_INFO)&rlCompressedDataInfo);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDecompressChunksResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &UncompressedBuffer);

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &UncompressedBufferSize);
    uc_reg_write(uc, UC_X86_REG_R8, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &CompressedBufferSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CompressedTail, sizeof(CompressedTail));

    if(CompressedTail != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedTail, &rlCompressedTail, sizeof(rlCompressedTail));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &CompressedTailSize, sizeof(CompressedTailSize));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &CompressedDataInfo, sizeof(CompressedDataInfo));

    if(CompressedDataInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedDataInfo, &rlCompressedDataInfo, sizeof(rlCompressedDataInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDecompressChunks\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCompressChunks(
    IN     PUCHAR                 UncompressedBuffer        ,
    IN     ULONG                  UncompressedBufferSize    ,
    OUT    PUCHAR                 CompressedBuffer          ,
    IN     ULONG                  CompressedBufferSize      ,
    INOUT  PCOMPRESSED_DATA_INFO  CompressedDataInfo        ,
    IN     ULONG                  CompressedDataInfoLength  ,
    IN     PVOID                  WorkSpace                 );

*/
void EmuApi::EmuRtlCompressChunks(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUCHAR UncompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UncompressedBuffer);

    UCHAR rlUncompressedBuffer{};

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }

    ULONG UncompressedBufferSize{};
    uc_reg_read(uc, UC_X86_REG_EDX, &UncompressedBufferSize);

    PUCHAR CompressedBuffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &CompressedBuffer);

    UCHAR rlCompressedBuffer{};

    if(CompressedBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }

    ULONG CompressedBufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9D, &CompressedBufferSize);

    PCOMPRESSED_DATA_INFO CompressedDataInfo{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CompressedDataInfo, sizeof(CompressedDataInfo));

    COMPRESSED_DATA_INFO rlCompressedDataInfo{};

    if(CompressedDataInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CompressedDataInfo, &rlCompressedDataInfo, sizeof(rlCompressedDataInfo));
    }

    ULONG CompressedDataInfoLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CompressedDataInfoLength, sizeof(CompressedDataInfoLength));

    PVOID WorkSpace{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &WorkSpace, sizeof(WorkSpace));


    NTSTATUS RtlCompressChunksResult = RtlCompressChunks((PUCHAR)&rlUncompressedBuffer,(ULONG)UncompressedBufferSize,(PUCHAR)&rlCompressedBuffer,(ULONG)CompressedBufferSize,(PCOMPRESSED_DATA_INFO)&rlCompressedDataInfo,(ULONG)CompressedDataInfoLength,(PVOID)&WorkSpace);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCompressChunksResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &UncompressedBuffer);

    if(UncompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UncompressedBuffer, &rlUncompressedBuffer, sizeof(rlUncompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &UncompressedBufferSize);
    uc_reg_write(uc, UC_X86_REG_R8, &CompressedBuffer);

    if(CompressedBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedBuffer, &rlCompressedBuffer, sizeof(rlCompressedBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &CompressedBufferSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CompressedDataInfo, sizeof(CompressedDataInfo));

    if(CompressedDataInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CompressedDataInfo, &rlCompressedDataInfo, sizeof(rlCompressedDataInfo));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &CompressedDataInfoLength, sizeof(CompressedDataInfoLength));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &WorkSpace, sizeof(WorkSpace));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCompressChunks\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateProcessParameters(
      PRTL_USER_PROCESS_PARAMETERS *  ProcessParameters  ,
      PUNICODE_STRING                 ImagePathName      ,
      PUNICODE_STRING                 DllPath            ,
      PUNICODE_STRING                 CurrentDirectory   ,
      PUNICODE_STRING                 CommandLine        ,
      PVOID                           Environment        ,
      PUNICODE_STRING                 WindowTitle        ,
      PUNICODE_STRING                 DesktopInfo        ,
      PUNICODE_STRING                 ShellInfo          ,
      PUNICODE_STRING                 RuntimeData        );

*/
void EmuApi::EmuRtlCreateProcessParameters(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_USER_PROCESS_PARAMETERS * ProcessParameters{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessParameters);

    PRTL_USER_PROCESS_PARAMETERS * dpProcessParameters{};

    if(ProcessParameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessParameters, &dpProcessParameters, sizeof(dpProcessParameters));
    }

    RTL_USER_PROCESS_PARAMETERS stProcessParameters{};

    if(dpProcessParameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }

    PUNICODE_STRING ImagePathName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ImagePathName);

    std::wstring rlwImagePathName;

    USHORT rlLengthImagePathName;

    USHORT rlMaxLengthImagePathName;
    uc_mem_read(uc, (DWORD_PTR)ImagePathName, &rlLengthImagePathName, sizeof(rlLengthImagePathName));
    uc_mem_read(uc, (DWORD_PTR)ImagePathName+16, &rlMaxLengthImagePathName, sizeof(rlMaxLengthImagePathName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ImagePathName+64, rlwImagePathName, true, rlLengthImagePathName)) { printf("Error when read ImagePathName in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stImagePathName{};
    stImagePathName.Length = rlLengthImagePathName;
    stImagePathName.MaximumLength = rlMaxLengthImagePathName;
    stImagePathName.Buffer = rlwImagePathName.data();

    PUNICODE_STRING DllPath{};
    uc_reg_read(uc, UC_X86_REG_R8, &DllPath);

    std::wstring rlwDllPath;

    USHORT rlLengthDllPath;

    USHORT rlMaxLengthDllPath;
    uc_mem_read(uc, (DWORD_PTR)DllPath, &rlLengthDllPath, sizeof(rlLengthDllPath));
    uc_mem_read(uc, (DWORD_PTR)DllPath+16, &rlMaxLengthDllPath, sizeof(rlMaxLengthDllPath));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllPath+64, rlwDllPath, true, rlLengthDllPath)) { printf("Error when read DllPath in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stDllPath{};
    stDllPath.Length = rlLengthDllPath;
    stDllPath.MaximumLength = rlMaxLengthDllPath;
    stDllPath.Buffer = rlwDllPath.data();

    PUNICODE_STRING CurrentDirectory{};
    uc_reg_read(uc, UC_X86_REG_R9, &CurrentDirectory);

    std::wstring rlwCurrentDirectory;

    USHORT rlLengthCurrentDirectory;

    USHORT rlMaxLengthCurrentDirectory;
    uc_mem_read(uc, (DWORD_PTR)CurrentDirectory, &rlLengthCurrentDirectory, sizeof(rlLengthCurrentDirectory));
    uc_mem_read(uc, (DWORD_PTR)CurrentDirectory+16, &rlMaxLengthCurrentDirectory, sizeof(rlMaxLengthCurrentDirectory));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)CurrentDirectory+64, rlwCurrentDirectory, true, rlLengthCurrentDirectory)) { printf("Error when read CurrentDirectory in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stCurrentDirectory{};
    stCurrentDirectory.Length = rlLengthCurrentDirectory;
    stCurrentDirectory.MaximumLength = rlMaxLengthCurrentDirectory;
    stCurrentDirectory.Buffer = rlwCurrentDirectory.data();

    PUNICODE_STRING CommandLine{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CommandLine, sizeof(CommandLine));

    std::wstring rlwCommandLine;

    USHORT rlLengthCommandLine;

    USHORT rlMaxLengthCommandLine;
    uc_mem_read(uc, (DWORD_PTR)CommandLine, &rlLengthCommandLine, sizeof(rlLengthCommandLine));
    uc_mem_read(uc, (DWORD_PTR)CommandLine+16, &rlMaxLengthCommandLine, sizeof(rlMaxLengthCommandLine));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)CommandLine+64, rlwCommandLine, true, rlLengthCommandLine)) { printf("Error when read CommandLine in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stCommandLine{};
    stCommandLine.Length = rlLengthCommandLine;
    stCommandLine.MaximumLength = rlMaxLengthCommandLine;
    stCommandLine.Buffer = rlwCommandLine.data();

    PVOID Environment{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Environment, sizeof(Environment));

    PUNICODE_STRING WindowTitle{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &WindowTitle, sizeof(WindowTitle));

    std::wstring rlwWindowTitle;

    USHORT rlLengthWindowTitle;

    USHORT rlMaxLengthWindowTitle;
    uc_mem_read(uc, (DWORD_PTR)WindowTitle, &rlLengthWindowTitle, sizeof(rlLengthWindowTitle));
    uc_mem_read(uc, (DWORD_PTR)WindowTitle+16, &rlMaxLengthWindowTitle, sizeof(rlMaxLengthWindowTitle));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)WindowTitle+64, rlwWindowTitle, true, rlLengthWindowTitle)) { printf("Error when read WindowTitle in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stWindowTitle{};
    stWindowTitle.Length = rlLengthWindowTitle;
    stWindowTitle.MaximumLength = rlMaxLengthWindowTitle;
    stWindowTitle.Buffer = rlwWindowTitle.data();

    PUNICODE_STRING DesktopInfo{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &DesktopInfo, sizeof(DesktopInfo));

    std::wstring rlwDesktopInfo;

    USHORT rlLengthDesktopInfo;

    USHORT rlMaxLengthDesktopInfo;
    uc_mem_read(uc, (DWORD_PTR)DesktopInfo, &rlLengthDesktopInfo, sizeof(rlLengthDesktopInfo));
    uc_mem_read(uc, (DWORD_PTR)DesktopInfo+16, &rlMaxLengthDesktopInfo, sizeof(rlMaxLengthDesktopInfo));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DesktopInfo+64, rlwDesktopInfo, true, rlLengthDesktopInfo)) { printf("Error when read DesktopInfo in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stDesktopInfo{};
    stDesktopInfo.Length = rlLengthDesktopInfo;
    stDesktopInfo.MaximumLength = rlMaxLengthDesktopInfo;
    stDesktopInfo.Buffer = rlwDesktopInfo.data();

    PUNICODE_STRING ShellInfo{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ShellInfo, sizeof(ShellInfo));

    std::wstring rlwShellInfo;

    USHORT rlLengthShellInfo;

    USHORT rlMaxLengthShellInfo;
    uc_mem_read(uc, (DWORD_PTR)ShellInfo, &rlLengthShellInfo, sizeof(rlLengthShellInfo));
    uc_mem_read(uc, (DWORD_PTR)ShellInfo+16, &rlMaxLengthShellInfo, sizeof(rlMaxLengthShellInfo));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ShellInfo+64, rlwShellInfo, true, rlLengthShellInfo)) { printf("Error when read ShellInfo in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stShellInfo{};
    stShellInfo.Length = rlLengthShellInfo;
    stShellInfo.MaximumLength = rlMaxLengthShellInfo;
    stShellInfo.Buffer = rlwShellInfo.data();

    PUNICODE_STRING RuntimeData{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &RuntimeData, sizeof(RuntimeData));

    std::wstring rlwRuntimeData;

    USHORT rlLengthRuntimeData;

    USHORT rlMaxLengthRuntimeData;
    uc_mem_read(uc, (DWORD_PTR)RuntimeData, &rlLengthRuntimeData, sizeof(rlLengthRuntimeData));
    uc_mem_read(uc, (DWORD_PTR)RuntimeData+16, &rlMaxLengthRuntimeData, sizeof(rlMaxLengthRuntimeData));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)RuntimeData+64, rlwRuntimeData, true, rlLengthRuntimeData)) { printf("Error when read RuntimeData in RtlCreateProcessParameters"); _CrtDbgBreak(); }

    UNICODE_STRING stRuntimeData{};
    stRuntimeData.Length = rlLengthRuntimeData;
    stRuntimeData.MaximumLength = rlMaxLengthRuntimeData;
    stRuntimeData.Buffer = rlwRuntimeData.data();


    NTSTATUS RtlCreateProcessParametersResult = RtlCreateProcessParameters((PRTL_USER_PROCESS_PARAMETERS *)&stProcessParameters,(PUNICODE_STRING)&stImagePathName,(PUNICODE_STRING)&stDllPath,(PUNICODE_STRING)&stCurrentDirectory,(PUNICODE_STRING)&stCommandLine,(PVOID)&Environment,(PUNICODE_STRING)&stWindowTitle,(PUNICODE_STRING)&stDesktopInfo,(PUNICODE_STRING)&stShellInfo,(PUNICODE_STRING)&stRuntimeData);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateProcessParametersResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessParameters);

    if(ProcessParameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessParameters, &dpProcessParameters, sizeof(dpProcessParameters));
    }

    if(dpProcessParameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }
    uc_mem_write(uc, (DWORD_PTR)ImagePathName, &stImagePathName.Length, sizeof(stImagePathName.Length));
    uc_mem_write(uc, (DWORD_PTR)ImagePathName+16, &stImagePathName.MaximumLength, sizeof(stImagePathName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ImagePathName+64, stImagePathName.Buffer, true, stImagePathName.Length)) { printf("Error when read ImagePathName in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)DllPath, &stDllPath.Length, sizeof(stDllPath.Length));
    uc_mem_write(uc, (DWORD_PTR)DllPath+16, &stDllPath.MaximumLength, sizeof(stDllPath.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllPath+64, stDllPath.Buffer, true, stDllPath.Length)) { printf("Error when read DllPath in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)CurrentDirectory, &stCurrentDirectory.Length, sizeof(stCurrentDirectory.Length));
    uc_mem_write(uc, (DWORD_PTR)CurrentDirectory+16, &stCurrentDirectory.MaximumLength, sizeof(stCurrentDirectory.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)CurrentDirectory+64, stCurrentDirectory.Buffer, true, stCurrentDirectory.Length)) { printf("Error when read CurrentDirectory in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)CommandLine, &stCommandLine.Length, sizeof(stCommandLine.Length));
    uc_mem_write(uc, (DWORD_PTR)CommandLine+16, &stCommandLine.MaximumLength, sizeof(stCommandLine.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)CommandLine+64, stCommandLine.Buffer, true, stCommandLine.Length)) { printf("Error when read CommandLine in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Environment, sizeof(Environment));
    uc_mem_write(uc, (DWORD_PTR)WindowTitle, &stWindowTitle.Length, sizeof(stWindowTitle.Length));
    uc_mem_write(uc, (DWORD_PTR)WindowTitle+16, &stWindowTitle.MaximumLength, sizeof(stWindowTitle.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)WindowTitle+64, stWindowTitle.Buffer, true, stWindowTitle.Length)) { printf("Error when read WindowTitle in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)DesktopInfo, &stDesktopInfo.Length, sizeof(stDesktopInfo.Length));
    uc_mem_write(uc, (DWORD_PTR)DesktopInfo+16, &stDesktopInfo.MaximumLength, sizeof(stDesktopInfo.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DesktopInfo+64, stDesktopInfo.Buffer, true, stDesktopInfo.Length)) { printf("Error when read DesktopInfo in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ShellInfo, &stShellInfo.Length, sizeof(stShellInfo.Length));
    uc_mem_write(uc, (DWORD_PTR)ShellInfo+16, &stShellInfo.MaximumLength, sizeof(stShellInfo.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ShellInfo+64, stShellInfo.Buffer, true, stShellInfo.Length)) { printf("Error when read ShellInfo in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)RuntimeData, &stRuntimeData.Length, sizeof(stRuntimeData.Length));
    uc_mem_write(uc, (DWORD_PTR)RuntimeData+16, &stRuntimeData.MaximumLength, sizeof(stRuntimeData.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)RuntimeData+64, stRuntimeData.Buffer, true, stRuntimeData.Length)) { printf("Error when read RuntimeData in RtlCreateProcessParameters"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateProcessParameters\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDestroyProcessParameters(
      PRTL_USER_PROCESS_PARAMETERS  ProcessParameters  );

*/
void EmuApi::EmuRtlDestroyProcessParameters(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_USER_PROCESS_PARAMETERS ProcessParameters{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessParameters);

    RTL_USER_PROCESS_PARAMETERS stProcessParameters{};

    if(ProcessParameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }


    NTSTATUS RtlDestroyProcessParametersResult = RtlDestroyProcessParameters((PRTL_USER_PROCESS_PARAMETERS)&stProcessParameters);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDestroyProcessParametersResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessParameters);

    if(ProcessParameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDestroyProcessParameters\n";
    #endif

    return;
}


/*
PRTL_USER_PROCESS_PARAMETERS
__cdecl
RtlNormalizeProcessParams(
      PRTL_USER_PROCESS_PARAMETERS  ProcessParameters  );

*/
void EmuApi::EmuRtlNormalizeProcessParams(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_USER_PROCESS_PARAMETERS ProcessParameters{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessParameters);

    RTL_USER_PROCESS_PARAMETERS stProcessParameters{};

    if(ProcessParameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }


    PRTL_USER_PROCESS_PARAMETERS RtlNormalizeProcessParamsResult = RtlNormalizeProcessParams((PRTL_USER_PROCESS_PARAMETERS)&stProcessParameters);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlNormalizeProcessParamsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessParameters);

    if(ProcessParameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNormalizeProcessParams\n";
    #endif

    return;
}


/*
PRTL_USER_PROCESS_PARAMETERS
__cdecl
RtlDeNormalizeProcessParams(
      PRTL_USER_PROCESS_PARAMETERS  ProcessParameters  );

*/
void EmuApi::EmuRtlDeNormalizeProcessParams(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_USER_PROCESS_PARAMETERS ProcessParameters{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessParameters);

    RTL_USER_PROCESS_PARAMETERS stProcessParameters{};

    if(ProcessParameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }


    PRTL_USER_PROCESS_PARAMETERS RtlDeNormalizeProcessParamsResult = RtlDeNormalizeProcessParams((PRTL_USER_PROCESS_PARAMETERS)&stProcessParameters);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlDeNormalizeProcessParamsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessParameters);

    if(ProcessParameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeNormalizeProcessParams\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateUserProcess(
      PUNICODE_STRING                NtImagePathName            ,
      ULONG                          Attributes                 ,
      PRTL_USER_PROCESS_PARAMETERS   ProcessParameters          ,
      PSECURITY_DESCRIPTOR           ProcessSecurityDescriptor  ,
      PSECURITY_DESCRIPTOR           ThreadSecurityDescriptor   ,
      HANDLE                         ParentProcess              ,
      BOOLEAN                        InheritHandles             ,
      HANDLE                         DebugPort                  ,
      HANDLE                         ExceptionPort              ,
      PRTL_USER_PROCESS_INFORMATION  ProcessInformation         );

*/
void EmuApi::EmuRtlCreateUserProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING NtImagePathName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NtImagePathName);

    std::wstring rlwNtImagePathName;

    USHORT rlLengthNtImagePathName;

    USHORT rlMaxLengthNtImagePathName;
    uc_mem_read(uc, (DWORD_PTR)NtImagePathName, &rlLengthNtImagePathName, sizeof(rlLengthNtImagePathName));
    uc_mem_read(uc, (DWORD_PTR)NtImagePathName+16, &rlMaxLengthNtImagePathName, sizeof(rlMaxLengthNtImagePathName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)NtImagePathName+64, rlwNtImagePathName, true, rlLengthNtImagePathName)) { printf("Error when read NtImagePathName in RtlCreateUserProcess"); _CrtDbgBreak(); }

    UNICODE_STRING stNtImagePathName{};
    stNtImagePathName.Length = rlLengthNtImagePathName;
    stNtImagePathName.MaximumLength = rlMaxLengthNtImagePathName;
    stNtImagePathName.Buffer = rlwNtImagePathName.data();

    ULONG Attributes{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Attributes);

    PRTL_USER_PROCESS_PARAMETERS ProcessParameters{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProcessParameters);

    RTL_USER_PROCESS_PARAMETERS stProcessParameters{};

    if(ProcessParameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }

    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProcessSecurityDescriptor);

    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ThreadSecurityDescriptor, sizeof(ThreadSecurityDescriptor));

    HANDLE ParentProcess{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ParentProcess, sizeof(ParentProcess));

    BOOLEAN InheritHandles{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InheritHandles, sizeof(InheritHandles));

    HANDLE DebugPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &DebugPort, sizeof(DebugPort));

    HANDLE ExceptionPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ExceptionPort, sizeof(ExceptionPort));

    PRTL_USER_PROCESS_INFORMATION ProcessInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ProcessInformation, sizeof(ProcessInformation));

    RTL_USER_PROCESS_INFORMATION stProcessInformation{};

    if(ProcessInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessInformation, &stProcessInformation, sizeof(stProcessInformation));
    }


    NTSTATUS RtlCreateUserProcessResult = RtlCreateUserProcess((PUNICODE_STRING)&stNtImagePathName,(ULONG)Attributes,(PRTL_USER_PROCESS_PARAMETERS)&stProcessParameters,(PSECURITY_DESCRIPTOR)&ProcessSecurityDescriptor,(PSECURITY_DESCRIPTOR)&ThreadSecurityDescriptor,(HANDLE)ParentProcess,(BOOLEAN)InheritHandles,(HANDLE)DebugPort,(HANDLE)ExceptionPort,(PRTL_USER_PROCESS_INFORMATION)&stProcessInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateUserProcessResult);
    uc_mem_write(uc, (DWORD_PTR)NtImagePathName, &stNtImagePathName.Length, sizeof(stNtImagePathName.Length));
    uc_mem_write(uc, (DWORD_PTR)NtImagePathName+16, &stNtImagePathName.MaximumLength, sizeof(stNtImagePathName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)NtImagePathName+64, stNtImagePathName.Buffer, true, stNtImagePathName.Length)) { printf("Error when read NtImagePathName in RtlCreateUserProcess"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &Attributes);
    uc_reg_write(uc, UC_X86_REG_R8, &ProcessParameters);

    if(ProcessParameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessParameters, &stProcessParameters, sizeof(stProcessParameters));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ProcessSecurityDescriptor);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ThreadSecurityDescriptor, sizeof(ThreadSecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ParentProcess, sizeof(ParentProcess));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InheritHandles, sizeof(InheritHandles));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &DebugPort, sizeof(DebugPort));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ExceptionPort, sizeof(ExceptionPort));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ProcessInformation, sizeof(ProcessInformation));

    if(ProcessInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &stProcessInformation, sizeof(stProcessInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateUserProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateUserThread(
       HANDLE                      Process                   ,
       PSECURITY_DESCRIPTOR        ThreadSecurityDescriptor  ,
       BOOLEAN                     CreateSuspended           ,
       ULONG                       StackZeroBits             ,
       SIZE_T                      MaximumStackSize          ,
    ,  SIZE_T                      InitialStackSize          ,
    ,  PUSER_THREAD_START_ROUTINE  StartAddress              ,
       PVOID                       Parameter                 ,
       PHANDLE                     Thread                    ,
       PCLIENT_ID                  ClientId                  );

*/
void EmuApi::EmuRtlCreateUserThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Process{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Process);

    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadSecurityDescriptor);

    BOOLEAN CreateSuspended{};
    uc_reg_read(uc, UC_X86_REG_R8B, &CreateSuspended);

    ULONG StackZeroBits{};
    uc_reg_read(uc, UC_X86_REG_R9D, &StackZeroBits);

    SIZE_T MaximumStackSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaximumStackSize, sizeof(MaximumStackSize));

    SIZE_T InitialStackSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &InitialStackSize, sizeof(InitialStackSize));

    PUSER_THREAD_START_ROUTINE StartAddress{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &StartAddress, sizeof(StartAddress));

    PVOID Parameter{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Parameter, sizeof(Parameter));

    HANDLE Thread{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Thread, sizeof(Thread));

    HANDLE dpThread{};

    if(Thread != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Thread, &dpThread, sizeof(dpThread));
    }

    PCLIENT_ID ClientId{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ClientId, sizeof(ClientId));

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }


    NTSTATUS RtlCreateUserThreadResult = RtlCreateUserThread((HANDLE)Process,(PSECURITY_DESCRIPTOR)&ThreadSecurityDescriptor,(BOOLEAN)CreateSuspended,(ULONG)StackZeroBits,(SIZE_T)MaximumStackSize,(SIZE_T)InitialStackSize,(PUSER_THREAD_START_ROUTINE)StartAddress,(PVOID)&Parameter,(PHANDLE)dpThread,(PCLIENT_ID)&stClientId);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateUserThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Process);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8B, &CreateSuspended);
    uc_reg_write(uc, UC_X86_REG_R9D, &StackZeroBits);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaximumStackSize, sizeof(MaximumStackSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &InitialStackSize, sizeof(InitialStackSize));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &StartAddress, sizeof(StartAddress));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Parameter, sizeof(Parameter));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Thread, sizeof(Thread));

    if(Thread != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Thread, &dpThread, sizeof(dpThread));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ClientId, sizeof(ClientId));

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateUserThread\n";
    #endif

    return;
}


/*
void
__cdecl
RtlExitUserThread(
      NTSTATUS  ExitStatus  );

*/
void EmuApi::EmuRtlExitUserThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ExitStatus);


    RtlExitUserThread((NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_ECX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlExitUserThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlImageNtHeaderEx(
         ULONG                Flags       ,
         PVOID                Base        ,
         ULONG64              Size        ,
    OUT  PIMAGE_NT_HEADERS *  OutHeaders  );

*/
void EmuApi::EmuRtlImageNtHeaderEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PVOID Base{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Base);

    ULONG64 Size{};
    uc_reg_read(uc, UC_X86_REG_R8, &Size);

    PIMAGE_NT_HEADERS * OutHeaders{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutHeaders);

    PIMAGE_NT_HEADERS * dpOutHeaders{};

    if(OutHeaders != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OutHeaders, &dpOutHeaders, sizeof(dpOutHeaders));
    }

    IMAGE_NT_HEADERS64 stOutHeaders{};

    if(dpOutHeaders != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpOutHeaders, &stOutHeaders, sizeof(stOutHeaders));
    }


    NTSTATUS RtlImageNtHeaderExResult = RtlImageNtHeaderEx((ULONG)Flags,(PVOID)&Base,(ULONG64)Size,(PIMAGE_NT_HEADERS *)&stOutHeaders);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlImageNtHeaderExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_reg_write(uc, UC_X86_REG_RDX, &Base);
    uc_reg_write(uc, UC_X86_REG_R8, &Size);
    uc_reg_write(uc, UC_X86_REG_R9, &OutHeaders);

    if(OutHeaders != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OutHeaders, &dpOutHeaders, sizeof(dpOutHeaders));
    }

    if(dpOutHeaders != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpOutHeaders, &stOutHeaders, sizeof(stOutHeaders));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlImageNtHeaderEx\n";
    #endif

    return;
}


/*
PIMAGE_NT_HEADERS
__cdecl
RtlImageNtHeader(
      PVOID  Base  );

*/
void EmuApi::EmuRtlImageNtHeader(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Base{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Base);


    PIMAGE_NT_HEADERS RtlImageNtHeaderResult = RtlImageNtHeader((PVOID)&Base);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlImageNtHeaderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Base);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlImageNtHeader\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlAddressInSectionTable(
    IN  PIMAGE_NT_HEADERS  NtHeaders       ,
    IN  PVOID              BaseOfImage     ,
    IN  ULONG              VirtualAddress  );

*/
void EmuApi::EmuRtlAddressInSectionTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIMAGE_NT_HEADERS NtHeaders{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NtHeaders);

    IMAGE_NT_HEADERS64 stNtHeaders{};

    if(NtHeaders != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }

    PVOID BaseOfImage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseOfImage);

    ULONG VirtualAddress{};
    uc_reg_read(uc, UC_X86_REG_R8D, &VirtualAddress);


    PVOID RtlAddressInSectionTableResult = RtlAddressInSectionTable((PIMAGE_NT_HEADERS)&stNtHeaders,(PVOID)&BaseOfImage,(ULONG)VirtualAddress);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlAddressInSectionTableResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NtHeaders);

    if(NtHeaders != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseOfImage);
    uc_reg_write(uc, UC_X86_REG_R8D, &VirtualAddress);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddressInSectionTable\n";
    #endif

    return;
}


/*
PIMAGE_SECTION_HEADER
__cdecl
RtlSectionTableFromVirtualAddress(
    IN  PIMAGE_NT_HEADERS  NtHeaders       ,
    IN  PVOID              BaseOfImage     ,
    IN  ULONG              VirtualAddress  );

*/
void EmuApi::EmuRtlSectionTableFromVirtualAddress(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIMAGE_NT_HEADERS NtHeaders{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NtHeaders);

    IMAGE_NT_HEADERS64 stNtHeaders{};

    if(NtHeaders != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }

    PVOID BaseOfImage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseOfImage);

    ULONG VirtualAddress{};
    uc_reg_read(uc, UC_X86_REG_R8D, &VirtualAddress);


    PIMAGE_SECTION_HEADER RtlSectionTableFromVirtualAddressResult = RtlSectionTableFromVirtualAddress((PIMAGE_NT_HEADERS)&stNtHeaders,(PVOID)&BaseOfImage,(ULONG)VirtualAddress);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSectionTableFromVirtualAddressResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NtHeaders);

    if(NtHeaders != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseOfImage);
    uc_reg_write(uc, UC_X86_REG_R8D, &VirtualAddress);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSectionTableFromVirtualAddress\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlImageDirectoryEntryToData(
      PVOID    BaseOfImage     ,
      BOOLEAN  MappedAsImage   ,
      USHORT   DirectoryEntry  ,
      PULONG   Size            );

*/
void EmuApi::EmuRtlImageDirectoryEntryToData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID BaseOfImage{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BaseOfImage);

    BOOLEAN MappedAsImage{};
    uc_reg_read(uc, UC_X86_REG_DL, &MappedAsImage);

    USHORT DirectoryEntry{};
    uc_reg_read(uc, UC_X86_REG_R8W, &DirectoryEntry);

    PULONG Size{};
    uc_reg_read(uc, UC_X86_REG_R9, &Size);

    ULONG rlSize{};

    if(Size != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Size, &rlSize, sizeof(rlSize));
    }


    PVOID RtlImageDirectoryEntryToDataResult = RtlImageDirectoryEntryToData((PVOID)&BaseOfImage,(BOOLEAN)MappedAsImage,(USHORT)DirectoryEntry,(PULONG)&rlSize);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlImageDirectoryEntryToDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BaseOfImage);
    uc_reg_write(uc, UC_X86_REG_DL, &MappedAsImage);
    uc_reg_write(uc, UC_X86_REG_R8W, &DirectoryEntry);
    uc_reg_write(uc, UC_X86_REG_R9, &Size);

    if(Size != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Size, &rlSize, sizeof(rlSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlImageDirectoryEntryToData\n";
    #endif

    return;
}


/*
PIMAGE_SECTION_HEADER
__cdecl
RtlImageRvaToSection(
    IN  PIMAGE_NT_HEADERS  NtHeaders  ,
    IN  PVOID              Base       ,
    IN  ULONG              Rva        );

*/
void EmuApi::EmuRtlImageRvaToSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIMAGE_NT_HEADERS NtHeaders{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NtHeaders);

    IMAGE_NT_HEADERS64 stNtHeaders{};

    if(NtHeaders != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }

    PVOID Base{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Base);

    ULONG Rva{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Rva);


    PIMAGE_SECTION_HEADER RtlImageRvaToSectionResult = RtlImageRvaToSection((PIMAGE_NT_HEADERS)&stNtHeaders,(PVOID)&Base,(ULONG)Rva);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlImageRvaToSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NtHeaders);

    if(NtHeaders != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Base);
    uc_reg_write(uc, UC_X86_REG_R8D, &Rva);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlImageRvaToSection\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlImageRvaToVa(
    IN     PIMAGE_NT_HEADERS        NtHeaders       ,
    IN     PVOID                    Base            ,
    IN     ULONG                    Rva             ,
    INOUT  PIMAGE_SECTION_HEADER *  LastRvaSection  );

*/
void EmuApi::EmuRtlImageRvaToVa(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PIMAGE_NT_HEADERS NtHeaders{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NtHeaders);

    IMAGE_NT_HEADERS64 stNtHeaders{};

    if(NtHeaders != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }

    PVOID Base{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Base);

    ULONG Rva{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Rva);

    PIMAGE_SECTION_HEADER * LastRvaSection{};
    uc_reg_read(uc, UC_X86_REG_R9, &LastRvaSection);

    PIMAGE_SECTION_HEADER * dpLastRvaSection{};

    if(LastRvaSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LastRvaSection, &dpLastRvaSection, sizeof(dpLastRvaSection));
    }

    IMAGE_SECTION_HEADER stLastRvaSection{};

    if(dpLastRvaSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpLastRvaSection, &stLastRvaSection, sizeof(stLastRvaSection));
    }


    PVOID RtlImageRvaToVaResult = RtlImageRvaToVa((PIMAGE_NT_HEADERS)&stNtHeaders,(PVOID)&Base,(ULONG)Rva,(PIMAGE_SECTION_HEADER *)&stLastRvaSection);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlImageRvaToVaResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NtHeaders);

    if(NtHeaders != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NtHeaders, &stNtHeaders, sizeof(stNtHeaders));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Base);
    uc_reg_write(uc, UC_X86_REG_R8D, &Rva);
    uc_reg_write(uc, UC_X86_REG_R9, &LastRvaSection);

    if(LastRvaSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LastRvaSection, &dpLastRvaSection, sizeof(dpLastRvaSection));
    }

    if(dpLastRvaSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpLastRvaSection, &stLastRvaSection, sizeof(stLastRvaSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlImageRvaToVa\n";
    #endif

    return;
}


/*
SIZE_T
__cdecl
RtlCompareMemoryUlong(
      PVOID   Source   ,
      SIZE_T  Length   ,
      ULONG   Pattern  );

*/
void EmuApi::EmuRtlCompareMemoryUlong(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Source{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Source);

    SIZE_T Length{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Length);

    ULONG Pattern{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Pattern);


    SIZE_T RtlCompareMemoryUlongResult = RtlCompareMemoryUlong((PVOID)&Source,(SIZE_T)Length,(ULONG)Pattern);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlCompareMemoryUlongResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Source);
    uc_reg_write(uc, UC_X86_REG_RDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8D, &Pattern);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCompareMemoryUlong\n";
    #endif

    return;
}


/*
void
__cdecl
RtlFillMemoryUlong(
      PVOID   Destination  ,
      SIZE_T  Length       ,
      ULONG   Pattern      );

*/
void EmuApi::EmuRtlFillMemoryUlong(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Destination{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Destination);

    SIZE_T Length{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Length);

    ULONG Pattern{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Pattern);


    RtlFillMemoryUlong((PVOID)&Destination,(SIZE_T)Length,(ULONG)Pattern);


    uc_reg_write(uc, UC_X86_REG_RCX, &Destination);
    uc_reg_write(uc, UC_X86_REG_RDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8D, &Pattern);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFillMemoryUlong\n";
    #endif

    return;
}


/*
void
__cdecl
RtlFillMemoryUlonglong(
      PVOID      Destination  ,
      SIZE_T     Length       ,
      ULONGLONG  Pattern      );

*/
void EmuApi::EmuRtlFillMemoryUlonglong(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Destination{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Destination);

    SIZE_T Length{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Length);

    ULONGLONG Pattern{};
    uc_reg_read(uc, UC_X86_REG_R8, &Pattern);


    RtlFillMemoryUlonglong((PVOID)&Destination,(SIZE_T)Length,(ULONGLONG)Pattern);


    uc_reg_write(uc, UC_X86_REG_RCX, &Destination);
    uc_reg_write(uc, UC_X86_REG_RDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8, &Pattern);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFillMemoryUlonglong\n";
    #endif

    return;
}


/*
LONG
__cdecl
RtlUnhandledExceptionFilter(
    IN  struct _EXCEPTION_POINTERS *  ExceptionInfo  );

*/
void EmuApi::EmuRtlUnhandledExceptionFilter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEXCEPTION_POINTERS ExceptionInfo{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExceptionInfo);

    EXCEPTION_POINTERS stExceptionInfo{};

    if(ExceptionInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ExceptionInfo, &stExceptionInfo, sizeof(stExceptionInfo));
    }


    LONG RtlUnhandledExceptionFilterResult = RtlUnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&stExceptionInfo);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnhandledExceptionFilterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExceptionInfo);

    if(ExceptionInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ExceptionInfo, &stExceptionInfo, sizeof(stExceptionInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnhandledExceptionFilter\n";
    #endif

    return;
}


/*
void
__cdecl
DbgUserBreakPoint(VOID);

*/
void EmuApi::EmuDbgUserBreakPoint(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    DbgUserBreakPoint();


    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgUserBreakPoint\n";
    #endif

    return;
}


/*
void
__cdecl
DbgBreakPointWithStatus(
      ULONG  Status  );

*/
void EmuApi::EmuDbgBreakPointWithStatus(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Status{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Status);


    DbgBreakPointWithStatus((ULONG)Status);


    uc_reg_write(uc, UC_X86_REG_ECX, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgBreakPointWithStatus\n";
    #endif

    return;
}


/*
ULONG
__cdecl
DbgPrintEx(
    IN  ULONG  ComponentId  ,
    IN  ULONG  Level        ,
    IN  PCH    Format       );

*/
void EmuApi::EmuDbgPrintEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);

    PCH Format{};
    uc_reg_read(uc, UC_X86_REG_R8, &Format);

    std::string rlaFormat;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in DbgPrintEx"); _CrtDbgBreak(); }


    ULONG DbgPrintExResult = DbgPrintEx((ULONG)ComponentId,(ULONG)Level,(PCH)rlaFormat.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &DbgPrintExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in DbgPrintEx"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgPrintEx\n";
    #endif

    return;
}


/*
ULONG
__cdecl
vDbgPrintEx(
    IN  ULONG    ComponentId  ,
    IN  ULONG    Level        ,
    IN  PCH      Format       ,
    IN  va_list  arglist      );

*/
void EmuApi::EmuvDbgPrintEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);

    PCH Format{};
    uc_reg_read(uc, UC_X86_REG_R8, &Format);

    std::string rlaFormat;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in vDbgPrintEx"); _CrtDbgBreak(); }

    va_list arglist{};
    uc_reg_read(uc, UC_X86_REG_R9, &arglist);

    std::string rlaarglist;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)arglist, rlaarglist)) { printf("Error when read arglist in vDbgPrintEx"); _CrtDbgBreak(); }


    ULONG vDbgPrintExResult = vDbgPrintEx((ULONG)ComponentId,(ULONG)Level,(PCH)rlaFormat.data(),(va_list)rlaarglist.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &vDbgPrintExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in vDbgPrintEx"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)arglist, rlaarglist)) { printf("Error when read arglist in vDbgPrintEx"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuvDbgPrintEx\n";
    #endif

    return;
}


/*
ULONG
__cdecl
vDbgPrintExWithPrefix(
    IN  PCH      Prefix       ,
    IN  ULONG    ComponentId  ,
    IN  ULONG    Level        ,
    IN  PCH      Format       ,
    IN  va_list  arglist      );

*/
void EmuApi::EmuvDbgPrintExWithPrefix(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCH Prefix{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Prefix);

    std::string rlaPrefix;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Prefix, rlaPrefix)) { printf("Error when read Prefix in vDbgPrintExWithPrefix"); _CrtDbgBreak(); }

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Level);

    PCH Format{};
    uc_reg_read(uc, UC_X86_REG_R9, &Format);

    std::string rlaFormat;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in vDbgPrintExWithPrefix"); _CrtDbgBreak(); }

    va_list arglist{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &arglist, sizeof(arglist));

    std::string rlaarglist;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)arglist, rlaarglist)) { printf("Error when read arglist in vDbgPrintExWithPrefix"); _CrtDbgBreak(); }


    ULONG vDbgPrintExWithPrefixResult = vDbgPrintExWithPrefix((PCH)rlaPrefix.data(),(ULONG)ComponentId,(ULONG)Level,(PCH)rlaFormat.data(),(va_list)rlaarglist.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &vDbgPrintExWithPrefixResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Prefix, rlaPrefix)) { printf("Error when read Prefix in vDbgPrintExWithPrefix"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_R8D, &Level);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in vDbgPrintExWithPrefix"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)arglist, rlaarglist)) { printf("Error when read arglist in vDbgPrintExWithPrefix"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuvDbgPrintExWithPrefix\n";
    #endif

    return;
}


/*
ULONG
__cdecl
DbgPrintReturnControlC(
    IN  PCHAR  Format  );

*/
void EmuApi::EmuDbgPrintReturnControlC(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR Format{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Format);

    std::string rlaFormat;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in DbgPrintReturnControlC"); _CrtDbgBreak(); }


    ULONG DbgPrintReturnControlCResult = DbgPrintReturnControlC((PCHAR)rlaFormat.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &DbgPrintReturnControlCResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in DbgPrintReturnControlC"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgPrintReturnControlC\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
DbgQueryDebugFilterState(
    IN  ULONG  ComponentId  ,
    IN  ULONG  Level        );

*/
void EmuApi::EmuDbgQueryDebugFilterState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);


    NTSTATUS DbgQueryDebugFilterStateResult = DbgQueryDebugFilterState((ULONG)ComponentId,(ULONG)Level);


    uc_reg_write(uc, UC_X86_REG_EAX, &DbgQueryDebugFilterStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgQueryDebugFilterState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
DbgSetDebugFilterState(
    IN  ULONG    ComponentId  ,
    IN  ULONG    Level        ,
    IN  BOOLEAN  State        );

*/
void EmuApi::EmuDbgSetDebugFilterState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);

    BOOLEAN State{};
    uc_reg_read(uc, UC_X86_REG_R8B, &State);


    NTSTATUS DbgSetDebugFilterStateResult = DbgSetDebugFilterState((ULONG)ComponentId,(ULONG)Level,(BOOLEAN)State);


    uc_reg_write(uc, UC_X86_REG_EAX, &DbgSetDebugFilterStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    uc_reg_write(uc, UC_X86_REG_R8B, &State);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgSetDebugFilterState\n";
    #endif

    return;
}


/*
ULONG
__cdecl
DbgPrompt(
    IN   PCH    Prompt    ,
    OUT  PCH    Response  ,
    IN   ULONG  Length    );

*/
void EmuApi::EmuDbgPrompt(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCH Prompt{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Prompt);

    std::string rlaPrompt;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Prompt, rlaPrompt)) { printf("Error when read Prompt in DbgPrompt"); _CrtDbgBreak(); }

    PCH Response{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Response);

    std::string rlaResponse;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Response, rlaResponse)) { printf("Error when read Response in DbgPrompt"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Length);


    ULONG DbgPromptResult = DbgPrompt((PCH)rlaPrompt.data(),(PCH)rlaResponse.data(),(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &DbgPromptResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Prompt, rlaPrompt)) { printf("Error when read Prompt in DbgPrompt"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Response, rlaResponse)) { printf("Error when read Response in DbgPrompt"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgPrompt\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlCutoverTimeToSystemTime(
      PTIME_FIELDS    CutoverTime        ,
      PLARGE_INTEGER  SystemTime         ,
      PLARGE_INTEGER  CurrentSystemTime  ,
      BOOLEAN         ThisYear           );

*/
void EmuApi::EmuRtlCutoverTimeToSystemTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PTIME_FIELDS CutoverTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CutoverTime);

    TIME_FIELDS rlCutoverTime{};

    if(CutoverTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CutoverTime, &rlCutoverTime, sizeof(rlCutoverTime));
    }

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }

    PLARGE_INTEGER CurrentSystemTime{};
    uc_reg_read(uc, UC_X86_REG_R8, &CurrentSystemTime);

    LARGE_INTEGER rlCurrentSystemTime{};

    if(CurrentSystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CurrentSystemTime, &rlCurrentSystemTime, sizeof(rlCurrentSystemTime));
    }

    BOOLEAN ThisYear{};
    uc_reg_read(uc, UC_X86_REG_R9B, &ThisYear);


    BOOLEAN RtlCutoverTimeToSystemTimeResult = RtlCutoverTimeToSystemTime((PTIME_FIELDS)&rlCutoverTime,(PLARGE_INTEGER)&rlSystemTime,(PLARGE_INTEGER)&rlCurrentSystemTime,(BOOLEAN)ThisYear);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlCutoverTimeToSystemTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CutoverTime);

    if(CutoverTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CutoverTime, &rlCutoverTime, sizeof(rlCutoverTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &CurrentSystemTime);

    if(CurrentSystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CurrentSystemTime, &rlCurrentSystemTime, sizeof(rlCurrentSystemTime));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &ThisYear);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCutoverTimeToSystemTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSystemTimeToLocalTime(
    IN   PLARGE_INTEGER  SystemTime  ,
    OUT  PLARGE_INTEGER  LocalTime   );

*/
void EmuApi::EmuRtlSystemTimeToLocalTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }

    PLARGE_INTEGER LocalTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LocalTime);

    LARGE_INTEGER rlLocalTime{};

    if(LocalTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LocalTime, &rlLocalTime, sizeof(rlLocalTime));
    }


    NTSTATUS RtlSystemTimeToLocalTimeResult = RtlSystemTimeToLocalTime((PLARGE_INTEGER)&rlSystemTime,(PLARGE_INTEGER)&rlLocalTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSystemTimeToLocalTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &LocalTime);

    if(LocalTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LocalTime, &rlLocalTime, sizeof(rlLocalTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSystemTimeToLocalTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLocalTimeToSystemTime(
    IN   PLARGE_INTEGER  LocalTime   ,
    OUT  PLARGE_INTEGER  SystemTime  );

*/
void EmuApi::EmuRtlLocalTimeToSystemTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER LocalTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LocalTime);

    LARGE_INTEGER rlLocalTime{};

    if(LocalTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LocalTime, &rlLocalTime, sizeof(rlLocalTime));
    }

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }


    NTSTATUS RtlLocalTimeToSystemTimeResult = RtlLocalTimeToSystemTime((PLARGE_INTEGER)&rlLocalTime,(PLARGE_INTEGER)&rlSystemTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLocalTimeToSystemTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LocalTime);

    if(LocalTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LocalTime, &rlLocalTime, sizeof(rlLocalTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLocalTimeToSystemTime\n";
    #endif

    return;
}


/*
void
__cdecl
RtlTimeToElapsedTimeFields(
      PLARGE_INTEGER  Time        ,
      PTIME_FIELDS    TimeFields  );

*/
void EmuApi::EmuRtlTimeToElapsedTimeFields(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }

    PTIME_FIELDS TimeFields{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TimeFields);

    TIME_FIELDS rlTimeFields{};

    if(TimeFields != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimeFields, &rlTimeFields, sizeof(rlTimeFields));
    }


    RtlTimeToElapsedTimeFields((PLARGE_INTEGER)&rlTime,(PTIME_FIELDS)&rlTimeFields);


    uc_reg_write(uc, UC_X86_REG_RCX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &TimeFields);

    if(TimeFields != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimeFields, &rlTimeFields, sizeof(rlTimeFields));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTimeToElapsedTimeFields\n";
    #endif

    return;
}


/*
void
__cdecl
RtlTimeToTimeFields(
      PLARGE_INTEGER  Time        ,
      PTIME_FIELDS    TimeFields  );

*/
void EmuApi::EmuRtlTimeToTimeFields(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }

    PTIME_FIELDS TimeFields{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TimeFields);

    TIME_FIELDS rlTimeFields{};

    if(TimeFields != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimeFields, &rlTimeFields, sizeof(rlTimeFields));
    }


    RtlTimeToTimeFields((PLARGE_INTEGER)&rlTime,(PTIME_FIELDS)&rlTimeFields);


    uc_reg_write(uc, UC_X86_REG_RCX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &TimeFields);

    if(TimeFields != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimeFields, &rlTimeFields, sizeof(rlTimeFields));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTimeToTimeFields\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlTimeFieldsToTime(
      PTIME_FIELDS    TimeFields  ,
      PLARGE_INTEGER  Time        );

*/
void EmuApi::EmuRtlTimeFieldsToTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PTIME_FIELDS TimeFields{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimeFields);

    TIME_FIELDS rlTimeFields{};

    if(TimeFields != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimeFields, &rlTimeFields, sizeof(rlTimeFields));
    }

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }


    BOOLEAN RtlTimeFieldsToTimeResult = RtlTimeFieldsToTime((PTIME_FIELDS)&rlTimeFields,(PLARGE_INTEGER)&rlTime);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlTimeFieldsToTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimeFields);

    if(TimeFields != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimeFields, &rlTimeFields, sizeof(rlTimeFields));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTimeFieldsToTime\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlTimeToSecondsSince1980(
      PLARGE_INTEGER  Time            ,
      PULONG          ElapsedSeconds  );

*/
void EmuApi::EmuRtlTimeToSecondsSince1980(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }

    PULONG ElapsedSeconds{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ElapsedSeconds);

    ULONG rlElapsedSeconds{};

    if(ElapsedSeconds != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ElapsedSeconds, &rlElapsedSeconds, sizeof(rlElapsedSeconds));
    }


    BOOLEAN RtlTimeToSecondsSince1980Result = RtlTimeToSecondsSince1980((PLARGE_INTEGER)&rlTime,(PULONG)&rlElapsedSeconds);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlTimeToSecondsSince1980Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ElapsedSeconds);

    if(ElapsedSeconds != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ElapsedSeconds, &rlElapsedSeconds, sizeof(rlElapsedSeconds));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTimeToSecondsSince1980\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSecondsSince1980ToTime(
      ULONG           ElapsedSeconds  ,
      PLARGE_INTEGER  Time            );

*/
void EmuApi::EmuRtlSecondsSince1980ToTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ElapsedSeconds{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ElapsedSeconds);

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }


    RtlSecondsSince1980ToTime((ULONG)ElapsedSeconds,(PLARGE_INTEGER)&rlTime);


    uc_reg_write(uc, UC_X86_REG_ECX, &ElapsedSeconds);
    uc_reg_write(uc, UC_X86_REG_RDX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSecondsSince1980ToTime\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlTimeToSecondsSince1970(
      PLARGE_INTEGER  Time            ,
      PULONG          ElapsedSeconds  );

*/
void EmuApi::EmuRtlTimeToSecondsSince1970(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }

    PULONG ElapsedSeconds{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ElapsedSeconds);

    ULONG rlElapsedSeconds{};

    if(ElapsedSeconds != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ElapsedSeconds, &rlElapsedSeconds, sizeof(rlElapsedSeconds));
    }


    BOOLEAN RtlTimeToSecondsSince1970Result = RtlTimeToSecondsSince1970((PLARGE_INTEGER)&rlTime,(PULONG)&rlElapsedSeconds);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlTimeToSecondsSince1970Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ElapsedSeconds);

    if(ElapsedSeconds != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ElapsedSeconds, &rlElapsedSeconds, sizeof(rlElapsedSeconds));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTimeToSecondsSince1970\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSecondsSince1970ToTime(
      ULONG           ElapsedSeconds  ,
      PLARGE_INTEGER  Time            );

*/
void EmuApi::EmuRtlSecondsSince1970ToTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ElapsedSeconds{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ElapsedSeconds);

    PLARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Time);

    LARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }


    RtlSecondsSince1970ToTime((ULONG)ElapsedSeconds,(PLARGE_INTEGER)&rlTime);


    uc_reg_write(uc, UC_X86_REG_ECX, &ElapsedSeconds);
    uc_reg_write(uc, UC_X86_REG_RDX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSecondsSince1970ToTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryTimeZoneInformation(
    OUT  PRTL_TIME_ZONE_INFORMATION  TimeZoneInformation  );

*/
void EmuApi::EmuRtlQueryTimeZoneInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_TIME_ZONE_INFORMATION TimeZoneInformation{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimeZoneInformation);

    RTL_TIME_ZONE_INFORMATION stTimeZoneInformation{};

    if(TimeZoneInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimeZoneInformation, &stTimeZoneInformation, sizeof(stTimeZoneInformation));
    }


    NTSTATUS RtlQueryTimeZoneInformationResult = RtlQueryTimeZoneInformation((PRTL_TIME_ZONE_INFORMATION)&stTimeZoneInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryTimeZoneInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimeZoneInformation);

    if(TimeZoneInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimeZoneInformation, &stTimeZoneInformation, sizeof(stTimeZoneInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryTimeZoneInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetTimeZoneInformation(
    IN  PRTL_TIME_ZONE_INFORMATION  TimeZoneInformation  );

*/
void EmuApi::EmuRtlSetTimeZoneInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_TIME_ZONE_INFORMATION TimeZoneInformation{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimeZoneInformation);

    RTL_TIME_ZONE_INFORMATION stTimeZoneInformation{};

    if(TimeZoneInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimeZoneInformation, &stTimeZoneInformation, sizeof(stTimeZoneInformation));
    }


    NTSTATUS RtlSetTimeZoneInformationResult = RtlSetTimeZoneInformation((PRTL_TIME_ZONE_INFORMATION)&stTimeZoneInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetTimeZoneInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimeZoneInformation);

    if(TimeZoneInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimeZoneInformation, &stTimeZoneInformation, sizeof(stTimeZoneInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetTimeZoneInformation\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitializeBitMap(
      PRTL_BITMAP  BitMapHeader  ,
      PULONG       BitMapBuffer  ,
      ULONG        SizeOfBitMap  );

*/
void EmuApi::EmuRtlInitializeBitMap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    PULONG BitMapBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BitMapBuffer);

    ULONG rlBitMapBuffer{};

    if(BitMapBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapBuffer, &rlBitMapBuffer, sizeof(rlBitMapBuffer));
    }

    ULONG SizeOfBitMap{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SizeOfBitMap);


    RtlInitializeBitMap((PRTL_BITMAP)&rlBitMapHeader,(PULONG)&rlBitMapBuffer,(ULONG)SizeOfBitMap);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &BitMapBuffer);

    if(BitMapBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapBuffer, &rlBitMapBuffer, sizeof(rlBitMapBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &SizeOfBitMap);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeBitMap\n";
    #endif

    return;
}


/*
void
__cdecl
RtlClearBit(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        BitNumber     );

*/
void EmuApi::EmuRtlClearBit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG BitNumber{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BitNumber);


    RtlClearBit((PRTL_BITMAP)&rlBitMapHeader,(ULONG)BitNumber);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &BitNumber);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlClearBit\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetBit(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        BitNumber     );

*/
void EmuApi::EmuRtlSetBit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG BitNumber{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BitNumber);


    RtlSetBit((PRTL_BITMAP)&rlBitMapHeader,(ULONG)BitNumber);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &BitNumber);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetBit\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlTestBit(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        BitNumber     );

*/
void EmuApi::EmuRtlTestBit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG BitNumber{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BitNumber);


    BOOLEAN RtlTestBitResult = RtlTestBit((PRTL_BITMAP)&rlBitMapHeader,(ULONG)BitNumber);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlTestBitResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &BitNumber);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTestBit\n";
    #endif

    return;
}


/*
void
__cdecl
RtlClearAllBits(
      PRTL_BITMAP  BitMapHeader  );

*/
void EmuApi::EmuRtlClearAllBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }


    RtlClearAllBits((PRTL_BITMAP)&rlBitMapHeader);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlClearAllBits\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetAllBits(
      PRTL_BITMAP  BitMapHeader  );

*/
void EmuApi::EmuRtlSetAllBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }


    RtlSetAllBits((PRTL_BITMAP)&rlBitMapHeader);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetAllBits\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindClearBits(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        NumberToFind  ,
      ULONG        HintIndex     );

*/
void EmuApi::EmuRtlFindClearBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG NumberToFind{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumberToFind);

    ULONG HintIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HintIndex);


    ULONG RtlFindClearBitsResult = RtlFindClearBits((PRTL_BITMAP)&rlBitMapHeader,(ULONG)NumberToFind,(ULONG)HintIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindClearBitsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &NumberToFind);
    uc_reg_write(uc, UC_X86_REG_R8D, &HintIndex);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindClearBits\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindSetBits(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        NumberToFind  ,
      ULONG        HintIndex     );

*/
void EmuApi::EmuRtlFindSetBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG NumberToFind{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumberToFind);

    ULONG HintIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HintIndex);


    ULONG RtlFindSetBitsResult = RtlFindSetBits((PRTL_BITMAP)&rlBitMapHeader,(ULONG)NumberToFind,(ULONG)HintIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindSetBitsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &NumberToFind);
    uc_reg_write(uc, UC_X86_REG_R8D, &HintIndex);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindSetBits\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindClearBitsAndSet(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        NumberToFind  ,
      ULONG        HintIndex     );

*/
void EmuApi::EmuRtlFindClearBitsAndSet(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG NumberToFind{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumberToFind);

    ULONG HintIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HintIndex);


    ULONG RtlFindClearBitsAndSetResult = RtlFindClearBitsAndSet((PRTL_BITMAP)&rlBitMapHeader,(ULONG)NumberToFind,(ULONG)HintIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindClearBitsAndSetResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &NumberToFind);
    uc_reg_write(uc, UC_X86_REG_R8D, &HintIndex);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindClearBitsAndSet\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindSetBitsAndClear(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        NumberToFind  ,
      ULONG        HintIndex     );

*/
void EmuApi::EmuRtlFindSetBitsAndClear(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG NumberToFind{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumberToFind);

    ULONG HintIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HintIndex);


    ULONG RtlFindSetBitsAndClearResult = RtlFindSetBitsAndClear((PRTL_BITMAP)&rlBitMapHeader,(ULONG)NumberToFind,(ULONG)HintIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindSetBitsAndClearResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &NumberToFind);
    uc_reg_write(uc, UC_X86_REG_R8D, &HintIndex);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindSetBitsAndClear\n";
    #endif

    return;
}


/*
void
__cdecl
RtlClearBits(
      PRTL_BITMAP  BitMapHeader   ,
      ULONG        StartingIndex  ,
      ULONG        NumberToClear  );

*/
void EmuApi::EmuRtlClearBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG StartingIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &StartingIndex);

    ULONG NumberToClear{};
    uc_reg_read(uc, UC_X86_REG_R8D, &NumberToClear);


    RtlClearBits((PRTL_BITMAP)&rlBitMapHeader,(ULONG)StartingIndex,(ULONG)NumberToClear);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &StartingIndex);
    uc_reg_write(uc, UC_X86_REG_R8D, &NumberToClear);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlClearBits\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetBits(
      PRTL_BITMAP  BitMapHeader   ,
      ULONG        StartingIndex  ,
      ULONG        NumberToSet    );

*/
void EmuApi::EmuRtlSetBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG StartingIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &StartingIndex);

    ULONG NumberToSet{};
    uc_reg_read(uc, UC_X86_REG_R8D, &NumberToSet);


    RtlSetBits((PRTL_BITMAP)&rlBitMapHeader,(ULONG)StartingIndex,(ULONG)NumberToSet);


    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &StartingIndex);
    uc_reg_write(uc, UC_X86_REG_R8D, &NumberToSet);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetBits\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindClearRuns(
      PRTL_BITMAP      BitMapHeader       ,
      PRTL_BITMAP_RUN  RunArray           ,
      ULONG            SizeOfRunArray     ,
      BOOLEAN          LocateLongestRuns  );

*/
void EmuApi::EmuRtlFindClearRuns(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    PRTL_BITMAP_RUN RunArray{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RunArray);

    RTL_BITMAP_RUN rlRunArray{};

    if(RunArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RunArray, &rlRunArray, sizeof(rlRunArray));
    }

    ULONG SizeOfRunArray{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SizeOfRunArray);

    BOOLEAN LocateLongestRuns{};
    uc_reg_read(uc, UC_X86_REG_R9B, &LocateLongestRuns);


    ULONG RtlFindClearRunsResult = RtlFindClearRuns((PRTL_BITMAP)&rlBitMapHeader,(PRTL_BITMAP_RUN)&rlRunArray,(ULONG)SizeOfRunArray,(BOOLEAN)LocateLongestRuns);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindClearRunsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &RunArray);

    if(RunArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RunArray, &rlRunArray, sizeof(rlRunArray));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &SizeOfRunArray);
    uc_reg_write(uc, UC_X86_REG_R9B, &LocateLongestRuns);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindClearRuns\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindLongestRunClear(
      PRTL_BITMAP  BitMapHeader   ,
      PULONG       StartingIndex  );

*/
void EmuApi::EmuRtlFindLongestRunClear(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    PULONG StartingIndex{};
    uc_reg_read(uc, UC_X86_REG_RDX, &StartingIndex);

    ULONG rlStartingIndex{};

    if(StartingIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)StartingIndex, &rlStartingIndex, sizeof(rlStartingIndex));
    }


    ULONG RtlFindLongestRunClearResult = RtlFindLongestRunClear((PRTL_BITMAP)&rlBitMapHeader,(PULONG)&rlStartingIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindLongestRunClearResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &StartingIndex);

    if(StartingIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)StartingIndex, &rlStartingIndex, sizeof(rlStartingIndex));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindLongestRunClear\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindFirstRunClear(
      PRTL_BITMAP  BitMapHeader   ,
      PULONG       StartingIndex  );

*/
void EmuApi::EmuRtlFindFirstRunClear(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    PULONG StartingIndex{};
    uc_reg_read(uc, UC_X86_REG_RDX, &StartingIndex);

    ULONG rlStartingIndex{};

    if(StartingIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)StartingIndex, &rlStartingIndex, sizeof(rlStartingIndex));
    }


    ULONG RtlFindFirstRunClearResult = RtlFindFirstRunClear((PRTL_BITMAP)&rlBitMapHeader,(PULONG)&rlStartingIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindFirstRunClearResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &StartingIndex);

    if(StartingIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)StartingIndex, &rlStartingIndex, sizeof(rlStartingIndex));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindFirstRunClear\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlNumberOfClearBits(
      PRTL_BITMAP  BitMapHeader  );

*/
void EmuApi::EmuRtlNumberOfClearBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }


    ULONG RtlNumberOfClearBitsResult = RtlNumberOfClearBits((PRTL_BITMAP)&rlBitMapHeader);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNumberOfClearBitsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNumberOfClearBits\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlNumberOfSetBits(
      PRTL_BITMAP  BitMapHeader  );

*/
void EmuApi::EmuRtlNumberOfSetBits(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }


    ULONG RtlNumberOfSetBitsResult = RtlNumberOfSetBits((PRTL_BITMAP)&rlBitMapHeader);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNumberOfSetBitsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNumberOfSetBits\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlAreBitsClear(
      PRTL_BITMAP  BitMapHeader   ,
      ULONG        StartingIndex  ,
      ULONG        Length         );

*/
void EmuApi::EmuRtlAreBitsClear(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG StartingIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &StartingIndex);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Length);


    BOOLEAN RtlAreBitsClearResult = RtlAreBitsClear((PRTL_BITMAP)&rlBitMapHeader,(ULONG)StartingIndex,(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlAreBitsClearResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &StartingIndex);
    uc_reg_write(uc, UC_X86_REG_R8D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAreBitsClear\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlAreBitsSet(
      PRTL_BITMAP  BitMapHeader   ,
      ULONG        StartingIndex  ,
      ULONG        Length         );

*/
void EmuApi::EmuRtlAreBitsSet(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG StartingIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &StartingIndex);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Length);


    BOOLEAN RtlAreBitsSetResult = RtlAreBitsSet((PRTL_BITMAP)&rlBitMapHeader,(ULONG)StartingIndex,(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlAreBitsSetResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &StartingIndex);
    uc_reg_write(uc, UC_X86_REG_R8D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAreBitsSet\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindNextForwardRunClear(
    IN  PRTL_BITMAP  BitMapHeader      ,
    IN  ULONG        FromIndex         ,
    IN  PULONG       StartingRunIndex  );

*/
void EmuApi::EmuRtlFindNextForwardRunClear(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG FromIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &FromIndex);

    PULONG StartingRunIndex{};
    uc_reg_read(uc, UC_X86_REG_R8, &StartingRunIndex);

    ULONG rlStartingRunIndex{};

    if(StartingRunIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)StartingRunIndex, &rlStartingRunIndex, sizeof(rlStartingRunIndex));
    }


    ULONG RtlFindNextForwardRunClearResult = RtlFindNextForwardRunClear((PRTL_BITMAP)&rlBitMapHeader,(ULONG)FromIndex,(PULONG)&rlStartingRunIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindNextForwardRunClearResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &FromIndex);
    uc_reg_write(uc, UC_X86_REG_R8, &StartingRunIndex);

    if(StartingRunIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)StartingRunIndex, &rlStartingRunIndex, sizeof(rlStartingRunIndex));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindNextForwardRunClear\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlFindLastBackwardRunClear(
    IN  PRTL_BITMAP  BitMapHeader      ,
    IN  ULONG        FromIndex         ,
    IN  PULONG       StartingRunIndex  );

*/
void EmuApi::EmuRtlFindLastBackwardRunClear(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG FromIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &FromIndex);

    PULONG StartingRunIndex{};
    uc_reg_read(uc, UC_X86_REG_R8, &StartingRunIndex);

    ULONG rlStartingRunIndex{};

    if(StartingRunIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)StartingRunIndex, &rlStartingRunIndex, sizeof(rlStartingRunIndex));
    }


    ULONG RtlFindLastBackwardRunClearResult = RtlFindLastBackwardRunClear((PRTL_BITMAP)&rlBitMapHeader,(ULONG)FromIndex,(PULONG)&rlStartingRunIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindLastBackwardRunClearResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &FromIndex);
    uc_reg_write(uc, UC_X86_REG_R8, &StartingRunIndex);

    if(StartingRunIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)StartingRunIndex, &rlStartingRunIndex, sizeof(rlStartingRunIndex));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindLastBackwardRunClear\n";
    #endif

    return;
}


/*
CCHAR
__cdecl
RtlFindLeastSignificantBit(
    IN  ULONGLONG  Set  );

*/
void EmuApi::EmuRtlFindLeastSignificantBit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONGLONG Set{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Set);


    CCHAR RtlFindLeastSignificantBitResult = RtlFindLeastSignificantBit((ULONGLONG)Set);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlFindLeastSignificantBitResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Set);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindLeastSignificantBit\n";
    #endif

    return;
}


/*
CCHAR
__cdecl
RtlFindMostSignificantBit(
    IN  ULONGLONG  Set  );

*/
void EmuApi::EmuRtlFindMostSignificantBit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONGLONG Set{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Set);


    CCHAR RtlFindMostSignificantBitResult = RtlFindMostSignificantBit((ULONGLONG)Set);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlFindMostSignificantBitResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Set);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindMostSignificantBit\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlValidSid(
      PSID  Sid  );

*/
void EmuApi::EmuRtlValidSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);


    BOOLEAN RtlValidSidResult = RtlValidSid((PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlValidSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlValidSid\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlEqualSid(
      PSID  Sid1  ,
      PSID  Sid2  );

*/
void EmuApi::EmuRtlEqualSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid1);

    PSID Sid2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Sid2);


    BOOLEAN RtlEqualSidResult = RtlEqualSid((PSID)&Sid1,(PSID)&Sid2);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlEqualSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid1);
    uc_reg_write(uc, UC_X86_REG_RDX, &Sid2);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEqualSid\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlEqualPrefixSid(
      PSID  Sid1  ,
      PSID  Sid2  );

*/
void EmuApi::EmuRtlEqualPrefixSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid1{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid1);

    PSID Sid2{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Sid2);


    BOOLEAN RtlEqualPrefixSidResult = RtlEqualPrefixSid((PSID)&Sid1,(PSID)&Sid2);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlEqualPrefixSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid1);
    uc_reg_write(uc, UC_X86_REG_RDX, &Sid2);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEqualPrefixSid\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlLengthRequiredSid(
      ULONG  SubAuthorityCount  );

*/
void EmuApi::EmuRtlLengthRequiredSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG SubAuthorityCount{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SubAuthorityCount);


    ULONG RtlLengthRequiredSidResult = RtlLengthRequiredSid((ULONG)SubAuthorityCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLengthRequiredSidResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SubAuthorityCount);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLengthRequiredSid\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlFreeSid(
    IN  PSID  Sid  );

*/
void EmuApi::EmuRtlFreeSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);


    PVOID RtlFreeSidResult = RtlFreeSid((PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlFreeSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFreeSid\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlInitializeSid(
    OUT  PSID                       Sid                  ,
    IN   PSID_IDENTIFIER_AUTHORITY  IdentifierAuthority  ,
    IN   UCHAR                      SubAuthorityCount    );

*/
void EmuApi::EmuRtlInitializeSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);

    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IdentifierAuthority);

    SID_IDENTIFIER_AUTHORITY stIdentifierAuthority{};

    if(IdentifierAuthority != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IdentifierAuthority, &stIdentifierAuthority, sizeof(stIdentifierAuthority));
    }

    UCHAR SubAuthorityCount{};
    uc_reg_read(uc, UC_X86_REG_R8B, &SubAuthorityCount);


    NTSTATUS RtlInitializeSidResult = RtlInitializeSid((PSID)&Sid,(PSID_IDENTIFIER_AUTHORITY)&stIdentifierAuthority,(UCHAR)SubAuthorityCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlInitializeSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    uc_reg_write(uc, UC_X86_REG_RDX, &IdentifierAuthority);

    if(IdentifierAuthority != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IdentifierAuthority, &stIdentifierAuthority, sizeof(stIdentifierAuthority));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &SubAuthorityCount);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeSid\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAllocateAndInitializeSid(
    IN   PSID_IDENTIFIER_AUTHORITY  IdentifierAuthority  ,
    IN   UCHAR                      SubAuthorityCount    ,
    IN   ULONG                      SubAuthority0        ,
    IN   ULONG                      SubAuthority1        ,
    IN   ULONG                      SubAuthority2        ,
    IN   ULONG                      SubAuthority3        ,
    IN   ULONG                      SubAuthority4        ,
    IN   ULONG                      SubAuthority5        ,
    IN   ULONG                      SubAuthority6        ,
    IN   ULONG                      SubAuthority7        ,
    OUT  PSID *                     Sid                  );

*/
void EmuApi::EmuRtlAllocateAndInitializeSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IdentifierAuthority);

    SID_IDENTIFIER_AUTHORITY stIdentifierAuthority{};

    if(IdentifierAuthority != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IdentifierAuthority, &stIdentifierAuthority, sizeof(stIdentifierAuthority));
    }

    UCHAR SubAuthorityCount{};
    uc_reg_read(uc, UC_X86_REG_DL, &SubAuthorityCount);

    ULONG SubAuthority0{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SubAuthority0);

    ULONG SubAuthority1{};
    uc_reg_read(uc, UC_X86_REG_R9D, &SubAuthority1);

    ULONG SubAuthority2{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SubAuthority2, sizeof(SubAuthority2));

    ULONG SubAuthority3{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SubAuthority3, sizeof(SubAuthority3));

    ULONG SubAuthority4{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &SubAuthority4, sizeof(SubAuthority4));

    ULONG SubAuthority5{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &SubAuthority5, sizeof(SubAuthority5));

    ULONG SubAuthority6{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &SubAuthority6, sizeof(SubAuthority6));

    ULONG SubAuthority7{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &SubAuthority7, sizeof(SubAuthority7));

    PSID * Sid{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &Sid, sizeof(Sid));

    PSID * dpSid{};

    if(Sid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sid, &dpSid, sizeof(dpSid));
    }


    NTSTATUS RtlAllocateAndInitializeSidResult = RtlAllocateAndInitializeSid((PSID_IDENTIFIER_AUTHORITY)&stIdentifierAuthority,(UCHAR)SubAuthorityCount,(ULONG)SubAuthority0,(ULONG)SubAuthority1,(ULONG)SubAuthority2,(ULONG)SubAuthority3,(ULONG)SubAuthority4,(ULONG)SubAuthority5,(ULONG)SubAuthority6,(ULONG)SubAuthority7,(PSID *)&dpSid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAllocateAndInitializeSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IdentifierAuthority);

    if(IdentifierAuthority != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IdentifierAuthority, &stIdentifierAuthority, sizeof(stIdentifierAuthority));
    }
    uc_reg_write(uc, UC_X86_REG_DL, &SubAuthorityCount);
    uc_reg_write(uc, UC_X86_REG_R8D, &SubAuthority0);
    uc_reg_write(uc, UC_X86_REG_R9D, &SubAuthority1);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SubAuthority2, sizeof(SubAuthority2));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SubAuthority3, sizeof(SubAuthority3));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &SubAuthority4, sizeof(SubAuthority4));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &SubAuthority5, sizeof(SubAuthority5));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &SubAuthority6, sizeof(SubAuthority6));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &SubAuthority7, sizeof(SubAuthority7));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &Sid, sizeof(Sid));

    if(Sid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sid, &dpSid, sizeof(dpSid));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAllocateAndInitializeSid\n";
    #endif

    return;
}


/*
PSID_IDENTIFIER_AUTHORITY
__cdecl
RtlIdentifierAuthoritySid(
      PSID  Sid  );

*/
void EmuApi::EmuRtlIdentifierAuthoritySid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);


    PSID_IDENTIFIER_AUTHORITY RtlIdentifierAuthoritySidResult = RtlIdentifierAuthoritySid((PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlIdentifierAuthoritySidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIdentifierAuthoritySid\n";
    #endif

    return;
}


/*
PULONG
__cdecl
RtlSubAuthoritySid(
    IN  PSID   Sid           ,
    IN  ULONG  SubAuthority  );

*/
void EmuApi::EmuRtlSubAuthoritySid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);

    ULONG SubAuthority{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SubAuthority);


    PULONG RtlSubAuthoritySidResult = RtlSubAuthoritySid((PSID)&Sid,(ULONG)SubAuthority);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSubAuthoritySidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    uc_reg_write(uc, UC_X86_REG_EDX, &SubAuthority);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSubAuthoritySid\n";
    #endif

    return;
}


/*
PUCHAR
__cdecl
RtlSubAuthorityCountSid(
      PSID  Sid  );

*/
void EmuApi::EmuRtlSubAuthorityCountSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);


    PUCHAR RtlSubAuthorityCountSidResult = RtlSubAuthorityCountSid((PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlSubAuthorityCountSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSubAuthorityCountSid\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlLengthSid(
      PSID  Sid  );

*/
void EmuApi::EmuRtlLengthSid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);


    ULONG RtlLengthSidResult = RtlLengthSid((PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLengthSidResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLengthSid\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCopySid(
      ULONG  DestinationSidLength  ,
      PSID   DestinationSid        ,
      PSID   SourceSid             );

*/
void EmuApi::EmuRtlCopySid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG DestinationSidLength{};
    uc_reg_read(uc, UC_X86_REG_ECX, &DestinationSidLength);

    PSID DestinationSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DestinationSid);

    PSID SourceSid{};
    uc_reg_read(uc, UC_X86_REG_R8, &SourceSid);


    NTSTATUS RtlCopySidResult = RtlCopySid((ULONG)DestinationSidLength,(PSID)&DestinationSid,(PSID)&SourceSid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCopySidResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &DestinationSidLength);
    uc_reg_write(uc, UC_X86_REG_RDX, &DestinationSid);
    uc_reg_write(uc, UC_X86_REG_R8, &SourceSid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopySid\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCopySidAndAttributesArray(
      ULONG                ArrayLength             ,
      PSID_AND_ATTRIBUTES  Source                  ,
      ULONG                TargetSidBufferSize     ,
      PSID_AND_ATTRIBUTES  TargetArrayElement      ,
      PSID                 TargetSid               ,
      PSID *               NextTargetSid           ,
      PULONG               RemainingTargetSidSize  );

*/
void EmuApi::EmuRtlCopySidAndAttributesArray(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ArrayLength{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ArrayLength);

    PSID_AND_ATTRIBUTES Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    SID_AND_ATTRIBUTES stSource{};

    if(Source != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Source, &stSource, sizeof(stSource));
    }

    ULONG TargetSidBufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8D, &TargetSidBufferSize);

    PSID_AND_ATTRIBUTES TargetArrayElement{};
    uc_reg_read(uc, UC_X86_REG_R9, &TargetArrayElement);

    SID_AND_ATTRIBUTES stTargetArrayElement{};

    if(TargetArrayElement != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetArrayElement, &stTargetArrayElement, sizeof(stTargetArrayElement));
    }

    PSID TargetSid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TargetSid, sizeof(TargetSid));

    PSID * NextTargetSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NextTargetSid, sizeof(NextTargetSid));

    PSID * dpNextTargetSid{};

    if(NextTargetSid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NextTargetSid, &dpNextTargetSid, sizeof(dpNextTargetSid));
    }

    PULONG RemainingTargetSidSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &RemainingTargetSidSize, sizeof(RemainingTargetSidSize));

    ULONG rlRemainingTargetSidSize{};

    if(RemainingTargetSidSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RemainingTargetSidSize, &rlRemainingTargetSidSize, sizeof(rlRemainingTargetSidSize));
    }


    NTSTATUS RtlCopySidAndAttributesArrayResult = RtlCopySidAndAttributesArray((ULONG)ArrayLength,(PSID_AND_ATTRIBUTES)&stSource,(ULONG)TargetSidBufferSize,(PSID_AND_ATTRIBUTES)&stTargetArrayElement,(PSID)&TargetSid,(PSID *)&dpNextTargetSid,(PULONG)&rlRemainingTargetSidSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCopySidAndAttributesArrayResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ArrayLength);
    uc_reg_write(uc, UC_X86_REG_RDX, &Source);

    if(Source != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Source, &stSource, sizeof(stSource));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &TargetSidBufferSize);
    uc_reg_write(uc, UC_X86_REG_R9, &TargetArrayElement);

    if(TargetArrayElement != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetArrayElement, &stTargetArrayElement, sizeof(stTargetArrayElement));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TargetSid, sizeof(TargetSid));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NextTargetSid, sizeof(NextTargetSid));

    if(NextTargetSid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NextTargetSid, &dpNextTargetSid, sizeof(dpNextTargetSid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &RemainingTargetSidSize, sizeof(RemainingTargetSidSize));

    if(RemainingTargetSidSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RemainingTargetSidSize, &rlRemainingTargetSidSize, sizeof(rlRemainingTargetSidSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopySidAndAttributesArray\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLengthSidAsUnicodeString(
      PSID    Sid           ,
      PULONG  StringLength  );

*/
void EmuApi::EmuRtlLengthSidAsUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Sid);

    PULONG StringLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &StringLength);

    ULONG rlStringLength{};

    if(StringLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)StringLength, &rlStringLength, sizeof(rlStringLength));
    }


    NTSTATUS RtlLengthSidAsUnicodeStringResult = RtlLengthSidAsUnicodeString((PSID)&Sid,(PULONG)&rlStringLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLengthSidAsUnicodeStringResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Sid);
    uc_reg_write(uc, UC_X86_REG_RDX, &StringLength);

    if(StringLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)StringLength, &rlStringLength, sizeof(rlStringLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLengthSidAsUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlConvertSidToUnicodeString(
      PUNICODE_STRING  UnicodeString              ,
      PSID             Sid                        ,
      BOOLEAN          AllocateDestinationString  );

*/
void EmuApi::EmuRtlConvertSidToUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UnicodeString);

    std::wstring rlwUnicodeString;

    USHORT rlLengthUnicodeString;

    USHORT rlMaxLengthUnicodeString;
    uc_mem_read(uc, (DWORD_PTR)UnicodeString, &rlLengthUnicodeString, sizeof(rlLengthUnicodeString));
    uc_mem_read(uc, (DWORD_PTR)UnicodeString+16, &rlMaxLengthUnicodeString, sizeof(rlMaxLengthUnicodeString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString+64, rlwUnicodeString, true, rlLengthUnicodeString)) { printf("Error when read UnicodeString in RtlConvertSidToUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stUnicodeString{};
    stUnicodeString.Length = rlLengthUnicodeString;
    stUnicodeString.MaximumLength = rlMaxLengthUnicodeString;
    stUnicodeString.Buffer = rlwUnicodeString.data();

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Sid);

    BOOLEAN AllocateDestinationString{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AllocateDestinationString);


    NTSTATUS RtlConvertSidToUnicodeStringResult = RtlConvertSidToUnicodeString((PUNICODE_STRING)&stUnicodeString,(PSID)&Sid,(BOOLEAN)AllocateDestinationString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlConvertSidToUnicodeStringResult);
    uc_mem_write(uc, (DWORD_PTR)UnicodeString, &stUnicodeString.Length, sizeof(stUnicodeString.Length));
    uc_mem_write(uc, (DWORD_PTR)UnicodeString+16, &stUnicodeString.MaximumLength, sizeof(stUnicodeString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString+64, stUnicodeString.Buffer, true, stUnicodeString.Length)) { printf("Error when read UnicodeString in RtlConvertSidToUnicodeString"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &Sid);
    uc_reg_write(uc, UC_X86_REG_R8B, &AllocateDestinationString);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlConvertSidToUnicodeString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlCopyLuid(
      PLUID  DestinationLuid  ,
      PLUID  SourceLuid       );

*/
void EmuApi::EmuRtlCopyLuid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLUID DestinationLuid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DestinationLuid);

    LUID stDestinationLuid{};

    if(DestinationLuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DestinationLuid, &stDestinationLuid, sizeof(stDestinationLuid));
    }

    PLUID SourceLuid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceLuid);

    LUID stSourceLuid{};

    if(SourceLuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceLuid, &stSourceLuid, sizeof(stSourceLuid));
    }


    RtlCopyLuid((PLUID)&stDestinationLuid,(PLUID)&stSourceLuid);


    uc_reg_write(uc, UC_X86_REG_RCX, &DestinationLuid);

    if(DestinationLuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DestinationLuid, &stDestinationLuid, sizeof(stDestinationLuid));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceLuid);

    if(SourceLuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceLuid, &stSourceLuid, sizeof(stSourceLuid));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopyLuid\n";
    #endif

    return;
}


/*
void
__cdecl
RtlCopyLuidAndAttributesArray(
      ULONG                 ArrayLength  ,
      PLUID_AND_ATTRIBUTES  Source       ,
      PLUID_AND_ATTRIBUTES  Target       );

*/
void EmuApi::EmuRtlCopyLuidAndAttributesArray(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ArrayLength{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ArrayLength);

    PLUID_AND_ATTRIBUTES Source{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Source);

    LUID_AND_ATTRIBUTES stSource{};

    if(Source != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Source, &stSource, sizeof(stSource));
    }

    PLUID_AND_ATTRIBUTES Target{};
    uc_reg_read(uc, UC_X86_REG_R8, &Target);

    LUID_AND_ATTRIBUTES stTarget{};

    if(Target != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Target, &stTarget, sizeof(stTarget));
    }


    RtlCopyLuidAndAttributesArray((ULONG)ArrayLength,(PLUID_AND_ATTRIBUTES)&stSource,(PLUID_AND_ATTRIBUTES)&stTarget);


    uc_reg_write(uc, UC_X86_REG_ECX, &ArrayLength);
    uc_reg_write(uc, UC_X86_REG_RDX, &Source);

    if(Source != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Source, &stSource, sizeof(stSource));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Target);

    if(Target != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Target, &stTarget, sizeof(stTarget));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCopyLuidAndAttributesArray\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlAreAllAccessesGranted(
      ACCESS_MASK  GrantedAccess  ,
      ACCESS_MASK  DesiredAccess  );

*/
void EmuApi::EmuRtlAreAllAccessesGranted(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ACCESS_MASK GrantedAccess{};
    uc_reg_read(uc, UC_X86_REG_ECX, &GrantedAccess);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);


    BOOLEAN RtlAreAllAccessesGrantedResult = RtlAreAllAccessesGranted((ACCESS_MASK)GrantedAccess,(ACCESS_MASK)DesiredAccess);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlAreAllAccessesGrantedResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &GrantedAccess);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAreAllAccessesGranted\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlAreAnyAccessesGranted(
      ACCESS_MASK  GrantedAccess  ,
      ACCESS_MASK  DesiredAccess  );

*/
void EmuApi::EmuRtlAreAnyAccessesGranted(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ACCESS_MASK GrantedAccess{};
    uc_reg_read(uc, UC_X86_REG_ECX, &GrantedAccess);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);


    BOOLEAN RtlAreAnyAccessesGrantedResult = RtlAreAnyAccessesGranted((ACCESS_MASK)GrantedAccess,(ACCESS_MASK)DesiredAccess);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlAreAnyAccessesGrantedResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &GrantedAccess);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAreAnyAccessesGranted\n";
    #endif

    return;
}


/*
void
__cdecl
RtlMapGenericMask(
      PACCESS_MASK      AccessMask      ,
      PGENERIC_MAPPING  GenericMapping  );

*/
void EmuApi::EmuRtlMapGenericMask(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AccessMask);

    ACCESS_MASK rlAccessMask{};

    if(AccessMask != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessMask, &rlAccessMask, sizeof(rlAccessMask));
    }

    PGENERIC_MAPPING GenericMapping{};
    uc_reg_read(uc, UC_X86_REG_RDX, &GenericMapping);

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }


    RtlMapGenericMask((PACCESS_MASK)&rlAccessMask,(PGENERIC_MAPPING)&rlGenericMapping);


    uc_reg_write(uc, UC_X86_REG_RCX, &AccessMask);

    if(AccessMask != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessMask, &rlAccessMask, sizeof(rlAccessMask));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &GenericMapping);

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlMapGenericMask\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateAcl(
    OUT  PACL   Acl          ,
    IN   ULONG  AclLength    ,
    IN   ULONG  AclRevision  );

*/
void EmuApi::EmuRtlCreateAcl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AclLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AclLength);

    ULONG AclRevision{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AclRevision);


    NTSTATUS RtlCreateAclResult = RtlCreateAcl((PACL)&rlAcl,(ULONG)AclLength,(ULONG)AclRevision);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateAclResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AclLength);
    uc_reg_write(uc, UC_X86_REG_R8D, &AclRevision);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateAcl\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlValidAcl(
      PACL  Acl  );

*/
void EmuApi::EmuRtlValidAcl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }


    BOOLEAN RtlValidAclResult = RtlValidAcl((PACL)&rlAcl);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlValidAclResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlValidAcl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryInformationAcl(
      PACL                   Acl                   ,
      PVOID                  AclInformation        ,
      ULONG                  AclInformationLength  ,
      ACL_INFORMATION_CLASS  AclInformationClass   );

*/
void EmuApi::EmuRtlQueryInformationAcl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    PVOID AclInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AclInformation);

    ULONG AclInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AclInformationLength);

    ACL_INFORMATION_CLASS AclInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AclInformationClass);


    NTSTATUS RtlQueryInformationAclResult = RtlQueryInformationAcl((PACL)&rlAcl,(PVOID)&AclInformation,(ULONG)AclInformationLength,(ACL_INFORMATION_CLASS)AclInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryInformationAclResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &AclInformation);
    uc_reg_write(uc, UC_X86_REG_R8D, &AclInformationLength);
    uc_reg_write(uc, UC_X86_REG_R9D, &AclInformationClass);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryInformationAcl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetInformationAcl(
      PACL                   Acl                   ,
      PVOID                  AclInformation        ,
      ULONG                  AclInformationLength  ,
      ACL_INFORMATION_CLASS  AclInformationClass   );

*/
void EmuApi::EmuRtlSetInformationAcl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    PVOID AclInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AclInformation);

    ULONG AclInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AclInformationLength);

    ACL_INFORMATION_CLASS AclInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AclInformationClass);


    NTSTATUS RtlSetInformationAclResult = RtlSetInformationAcl((PACL)&rlAcl,(PVOID)&AclInformation,(ULONG)AclInformationLength,(ACL_INFORMATION_CLASS)AclInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetInformationAclResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &AclInformation);
    uc_reg_write(uc, UC_X86_REG_R8D, &AclInformationLength);
    uc_reg_write(uc, UC_X86_REG_R9D, &AclInformationClass);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetInformationAcl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAce(
      PACL   Acl               ,
      ULONG  AceRevision       ,
      ULONG  StartingAceIndex  ,
      PVOID  AceList           ,
      ULONG  AceListLength     );

*/
void EmuApi::EmuRtlAddAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG StartingAceIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &StartingAceIndex);

    PVOID AceList{};
    uc_reg_read(uc, UC_X86_REG_R9, &AceList);

    ULONG AceListLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AceListLength, sizeof(AceListLength));


    NTSTATUS RtlAddAceResult = RtlAddAce((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)StartingAceIndex,(PVOID)&AceList,(ULONG)AceListLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &StartingAceIndex);
    uc_reg_write(uc, UC_X86_REG_R9, &AceList);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AceListLength, sizeof(AceListLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteAce(
      PACL   Acl       ,
      ULONG  AceIndex  );

*/
void EmuApi::EmuRtlDeleteAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceIndex);


    NTSTATUS RtlDeleteAceResult = RtlDeleteAce((PACL)&rlAcl,(ULONG)AceIndex);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceIndex);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetAce(
      PACL     Acl       ,
      ULONG    AceIndex  ,
      PVOID *  Ace       );

*/
void EmuApi::EmuRtlGetAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceIndex{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceIndex);

    PVOID * Ace{};
    uc_reg_read(uc, UC_X86_REG_R8, &Ace);

    PVOID * dpAce{};

    if(Ace != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ace, &dpAce, sizeof(dpAce));
    }


    NTSTATUS RtlGetAceResult = RtlGetAce((PACL)&rlAcl,(ULONG)AceIndex,(PVOID *)&dpAce);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceIndex);
    uc_reg_write(uc, UC_X86_REG_R8, &Ace);

    if(Ace != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ace, &dpAce, sizeof(dpAce));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetOwnerSecurityDescriptor(
    INOUT       PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    INOPTIONAL  PSID                  Owner               ,
    INOPTIONAL  BOOLEAN               OwnerDefaulted      );

*/
void EmuApi::EmuRtlSetOwnerSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID Owner{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Owner);

    BOOLEAN OwnerDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R8B, &OwnerDefaulted);


    NTSTATUS RtlSetOwnerSecurityDescriptorResult = RtlSetOwnerSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&Owner,(BOOLEAN)OwnerDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetOwnerSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &Owner);
    uc_reg_write(uc, UC_X86_REG_R8B, &OwnerDefaulted);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetOwnerSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetOwnerSecurityDescriptor(
    IN   PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    OUT  PSID *                Owner               ,
    OUT  PBOOLEAN              OwnerDefaulted      );

*/
void EmuApi::EmuRtlGetOwnerSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID * Owner{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Owner);

    PSID * dpOwner{};

    if(Owner != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Owner, &dpOwner, sizeof(dpOwner));
    }

    PBOOLEAN OwnerDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R8, &OwnerDefaulted);

    BOOLEAN rlOwnerDefaulted{};

    if(OwnerDefaulted != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OwnerDefaulted, &rlOwnerDefaulted, sizeof(rlOwnerDefaulted));
    }


    NTSTATUS RtlGetOwnerSecurityDescriptorResult = RtlGetOwnerSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID *)&dpOwner,(PBOOLEAN)&rlOwnerDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetOwnerSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &Owner);

    if(Owner != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Owner, &dpOwner, sizeof(dpOwner));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &OwnerDefaulted);

    if(OwnerDefaulted != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OwnerDefaulted, &rlOwnerDefaulted, sizeof(rlOwnerDefaulted));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetOwnerSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAccessAllowedAce(
      PACL         Acl          ,
      ULONG        AceRevision  ,
      ACCESS_MASK  AccessMask   ,
      PSID         Sid          );

*/
void EmuApi::EmuRtlAddAccessAllowedAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AccessMask);

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_R9, &Sid);


    NTSTATUS RtlAddAccessAllowedAceResult = RtlAddAccessAllowedAce((PACL)&rlAcl,(ULONG)AceRevision,(ACCESS_MASK)AccessMask,(PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAccessAllowedAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AccessMask);
    uc_reg_write(uc, UC_X86_REG_R9, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAccessAllowedAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAccessAllowedAceEx(
      PACL         Acl          ,
      ULONG        AceRevision  ,
      ULONG        AceFlags     ,
      ACCESS_MASK  AccessMask   ,
      PSID         Sid          );

*/
void EmuApi::EmuRtlAddAccessAllowedAceEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG AceFlags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AceFlags);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    PSID Sid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Sid, sizeof(Sid));


    NTSTATUS RtlAddAccessAllowedAceExResult = RtlAddAccessAllowedAceEx((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)AceFlags,(ACCESS_MASK)AccessMask,(PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAccessAllowedAceExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AceFlags);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Sid, sizeof(Sid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAccessAllowedAceEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAccessDeniedAce(
      PACL         Acl          ,
      ULONG        AceRevision  ,
      ACCESS_MASK  AccessMask   ,
      PSID         Sid          );

*/
void EmuApi::EmuRtlAddAccessDeniedAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AccessMask);

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_R9, &Sid);


    NTSTATUS RtlAddAccessDeniedAceResult = RtlAddAccessDeniedAce((PACL)&rlAcl,(ULONG)AceRevision,(ACCESS_MASK)AccessMask,(PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAccessDeniedAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AccessMask);
    uc_reg_write(uc, UC_X86_REG_R9, &Sid);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAccessDeniedAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAccessDeniedAceEx(
      PACL         Acl          ,
      ULONG        AceRevision  ,
      ULONG        AceFlags     ,
      ACCESS_MASK  AccessMask   ,
      PSID         Sid          );

*/
void EmuApi::EmuRtlAddAccessDeniedAceEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG AceFlags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AceFlags);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    PSID Sid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Sid, sizeof(Sid));


    NTSTATUS RtlAddAccessDeniedAceExResult = RtlAddAccessDeniedAceEx((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)AceFlags,(ACCESS_MASK)AccessMask,(PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAccessDeniedAceExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AceFlags);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Sid, sizeof(Sid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAccessDeniedAceEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAuditAccessAce(
      PACL         Acl           ,
      ULONG        AceRevision   ,
      ACCESS_MASK  AccessMask    ,
      PSID         Sid           ,
      BOOLEAN      AuditSuccess  ,
      BOOLEAN      AuditFailure  );

*/
void EmuApi::EmuRtlAddAuditAccessAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AccessMask);

    PSID Sid{};
    uc_reg_read(uc, UC_X86_REG_R9, &Sid);

    BOOLEAN AuditSuccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AuditSuccess, sizeof(AuditSuccess));

    BOOLEAN AuditFailure{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AuditFailure, sizeof(AuditFailure));


    NTSTATUS RtlAddAuditAccessAceResult = RtlAddAuditAccessAce((PACL)&rlAcl,(ULONG)AceRevision,(ACCESS_MASK)AccessMask,(PSID)&Sid,(BOOLEAN)AuditSuccess,(BOOLEAN)AuditFailure);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAuditAccessAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AccessMask);
    uc_reg_write(uc, UC_X86_REG_R9, &Sid);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AuditSuccess, sizeof(AuditSuccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AuditFailure, sizeof(AuditFailure));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAuditAccessAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAuditAccessAceEx(
      PACL         Acl           ,
      ULONG        AceRevision   ,
      ULONG        AceFlags      ,
      ACCESS_MASK  AccessMask    ,
      PSID         Sid           ,
      BOOLEAN      AuditSuccess  ,
      BOOLEAN      AuditFailure  );

*/
void EmuApi::EmuRtlAddAuditAccessAceEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG AceFlags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AceFlags);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    PSID Sid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Sid, sizeof(Sid));

    BOOLEAN AuditSuccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AuditSuccess, sizeof(AuditSuccess));

    BOOLEAN AuditFailure{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &AuditFailure, sizeof(AuditFailure));


    NTSTATUS RtlAddAuditAccessAceExResult = RtlAddAuditAccessAceEx((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)AceFlags,(ACCESS_MASK)AccessMask,(PSID)&Sid,(BOOLEAN)AuditSuccess,(BOOLEAN)AuditFailure);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAuditAccessAceExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AceFlags);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Sid, sizeof(Sid));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AuditSuccess, sizeof(AuditSuccess));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &AuditFailure, sizeof(AuditFailure));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAuditAccessAceEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAccessAllowedObjectAce(
    INOUT  PACL         Acl                      ,
    IN     ULONG        AceRevision              ,
    IN     ULONG        AceFlags                 ,
    IN     ACCESS_MASK  AccessMask               ,
    IN     GUID *       ObjectTypeGuid           ,
    ,IN    GUID *       InheritedObjectTypeGuid  ,
    ,IN    PSID         Sid                      );

*/
void EmuApi::EmuRtlAddAccessAllowedObjectAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG AceFlags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AceFlags);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    GUID * ObjectTypeGuid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeGuid, sizeof(ObjectTypeGuid));

    GUID stObjectTypeGuid{};

    if(ObjectTypeGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeGuid, &stObjectTypeGuid, sizeof(stObjectTypeGuid));
    }

    GUID * InheritedObjectTypeGuid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &InheritedObjectTypeGuid, sizeof(InheritedObjectTypeGuid));

    GUID stInheritedObjectTypeGuid{};

    if(InheritedObjectTypeGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InheritedObjectTypeGuid, &stInheritedObjectTypeGuid, sizeof(stInheritedObjectTypeGuid));
    }

    PSID Sid{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Sid, sizeof(Sid));


    NTSTATUS RtlAddAccessAllowedObjectAceResult = RtlAddAccessAllowedObjectAce((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)AceFlags,(ACCESS_MASK)AccessMask,(GUID *)&stObjectTypeGuid,(GUID *)&stInheritedObjectTypeGuid,(PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAccessAllowedObjectAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AceFlags);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeGuid, sizeof(ObjectTypeGuid));

    if(ObjectTypeGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeGuid, &stObjectTypeGuid, sizeof(stObjectTypeGuid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &InheritedObjectTypeGuid, sizeof(InheritedObjectTypeGuid));

    if(InheritedObjectTypeGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InheritedObjectTypeGuid, &stInheritedObjectTypeGuid, sizeof(stInheritedObjectTypeGuid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Sid, sizeof(Sid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAccessAllowedObjectAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAccessDeniedObjectAce(
    INOUT  PACL         Acl                      ,
    IN     ULONG        AceRevision              ,
    IN     ULONG        AceFlags                 ,
    IN     ACCESS_MASK  AccessMask               ,
    IN     GUID *       ObjectTypeGuid           ,
    ,IN    GUID *       InheritedObjectTypeGuid  ,
    ,IN    PSID         Sid                      );

*/
void EmuApi::EmuRtlAddAccessDeniedObjectAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG AceFlags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AceFlags);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    GUID * ObjectTypeGuid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeGuid, sizeof(ObjectTypeGuid));

    GUID stObjectTypeGuid{};

    if(ObjectTypeGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeGuid, &stObjectTypeGuid, sizeof(stObjectTypeGuid));
    }

    GUID * InheritedObjectTypeGuid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &InheritedObjectTypeGuid, sizeof(InheritedObjectTypeGuid));

    GUID stInheritedObjectTypeGuid{};

    if(InheritedObjectTypeGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InheritedObjectTypeGuid, &stInheritedObjectTypeGuid, sizeof(stInheritedObjectTypeGuid));
    }

    PSID Sid{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Sid, sizeof(Sid));


    NTSTATUS RtlAddAccessDeniedObjectAceResult = RtlAddAccessDeniedObjectAce((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)AceFlags,(ACCESS_MASK)AccessMask,(GUID *)&stObjectTypeGuid,(GUID *)&stInheritedObjectTypeGuid,(PSID)&Sid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAccessDeniedObjectAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AceFlags);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeGuid, sizeof(ObjectTypeGuid));

    if(ObjectTypeGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeGuid, &stObjectTypeGuid, sizeof(stObjectTypeGuid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &InheritedObjectTypeGuid, sizeof(InheritedObjectTypeGuid));

    if(InheritedObjectTypeGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InheritedObjectTypeGuid, &stInheritedObjectTypeGuid, sizeof(stInheritedObjectTypeGuid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Sid, sizeof(Sid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAccessDeniedObjectAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddAuditAccessObjectAce(
    INOUT  PACL         Acl                      ,
    IN     ULONG        AceRevision              ,
    IN     ULONG        AceFlags                 ,
    IN     ACCESS_MASK  AccessMask               ,
    IN     GUID *       ObjectTypeGuid           ,
    ,IN    GUID *       InheritedObjectTypeGuid  ,
    ,IN    PSID         Sid                      ,
           BOOLEAN      AuditSuccess             ,
           BOOLEAN      AuditFailure             );

*/
void EmuApi::EmuRtlAddAuditAccessObjectAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    ULONG AceFlags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &AceFlags);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    GUID * ObjectTypeGuid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeGuid, sizeof(ObjectTypeGuid));

    GUID stObjectTypeGuid{};

    if(ObjectTypeGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeGuid, &stObjectTypeGuid, sizeof(stObjectTypeGuid));
    }

    GUID * InheritedObjectTypeGuid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &InheritedObjectTypeGuid, sizeof(InheritedObjectTypeGuid));

    GUID stInheritedObjectTypeGuid{};

    if(InheritedObjectTypeGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InheritedObjectTypeGuid, &stInheritedObjectTypeGuid, sizeof(stInheritedObjectTypeGuid));
    }

    PSID Sid{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Sid, sizeof(Sid));

    BOOLEAN AuditSuccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AuditSuccess, sizeof(AuditSuccess));

    BOOLEAN AuditFailure{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &AuditFailure, sizeof(AuditFailure));


    NTSTATUS RtlAddAuditAccessObjectAceResult = RtlAddAuditAccessObjectAce((PACL)&rlAcl,(ULONG)AceRevision,(ULONG)AceFlags,(ACCESS_MASK)AccessMask,(GUID *)&stObjectTypeGuid,(GUID *)&stInheritedObjectTypeGuid,(PSID)&Sid,(BOOLEAN)AuditSuccess,(BOOLEAN)AuditFailure);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddAuditAccessObjectAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8D, &AceFlags);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeGuid, sizeof(ObjectTypeGuid));

    if(ObjectTypeGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeGuid, &stObjectTypeGuid, sizeof(stObjectTypeGuid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &InheritedObjectTypeGuid, sizeof(InheritedObjectTypeGuid));

    if(InheritedObjectTypeGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InheritedObjectTypeGuid, &stInheritedObjectTypeGuid, sizeof(stInheritedObjectTypeGuid));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Sid, sizeof(Sid));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditSuccess, sizeof(AuditSuccess));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &AuditFailure, sizeof(AuditFailure));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddAuditAccessObjectAce\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlFirstFreeAce(
      PACL     Acl        ,
      PVOID *  FirstFree  );

*/
void EmuApi::EmuRtlFirstFreeAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    PVOID * FirstFree{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FirstFree);

    PVOID * dpFirstFree{};

    if(FirstFree != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FirstFree, &dpFirstFree, sizeof(dpFirstFree));
    }


    BOOLEAN RtlFirstFreeAceResult = RtlFirstFreeAce((PACL)&rlAcl,(PVOID *)&dpFirstFree);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlFirstFreeAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &FirstFree);

    if(FirstFree != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FirstFree, &dpFirstFree, sizeof(dpFirstFree));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFirstFreeAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAddCompoundAce(
    IN  PACL         Acl          ,
    IN  ULONG        AceRevision  ,
    IN  UCHAR        AceType      ,
    IN  ACCESS_MASK  AccessMask   ,
    IN  PSID         ServerSid    ,
    IN  PSID         ClientSid    );

*/
void EmuApi::EmuRtlAddCompoundAce(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PACL Acl{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Acl);

    ACL rlAcl{};

    if(Acl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }

    ULONG AceRevision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AceRevision);

    UCHAR AceType{};
    uc_reg_read(uc, UC_X86_REG_R8B, &AceType);

    ACCESS_MASK AccessMask{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AccessMask);

    PSID ServerSid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ServerSid, sizeof(ServerSid));

    PSID ClientSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ClientSid, sizeof(ClientSid));


    NTSTATUS RtlAddCompoundAceResult = RtlAddCompoundAce((PACL)&rlAcl,(ULONG)AceRevision,(UCHAR)AceType,(ACCESS_MASK)AccessMask,(PSID)&ServerSid,(PSID)&ClientSid);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAddCompoundAceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Acl);

    if(Acl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Acl, &rlAcl, sizeof(rlAcl));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &AceRevision);
    uc_reg_write(uc, UC_X86_REG_R8B, &AceType);
    uc_reg_write(uc, UC_X86_REG_R9D, &AccessMask);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ServerSid, sizeof(ServerSid));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ClientSid, sizeof(ClientSid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddCompoundAce\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateSecurityDescriptor(
      PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
      ULONG                 Revision            );

*/
void EmuApi::EmuRtlCreateSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    ULONG Revision{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Revision);


    NTSTATUS RtlCreateSecurityDescriptorResult = RtlCreateSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(ULONG)Revision);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_EDX, &Revision);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateSecurityDescriptor\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlValidSecurityDescriptor(
      PSECURITY_DESCRIPTOR  SecurityDescriptor  );

*/
void EmuApi::EmuRtlValidSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);


    BOOLEAN RtlValidSecurityDescriptorResult = RtlValidSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlValidSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlValidSecurityDescriptor\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlLengthSecurityDescriptor(
      PSECURITY_DESCRIPTOR  SecurityDescriptor  );

*/
void EmuApi::EmuRtlLengthSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);


    ULONG RtlLengthSecurityDescriptorResult = RtlLengthSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLengthSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLengthSecurityDescriptor\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlValidRelativeSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptorInput   ,
    IN  ULONG                 SecurityDescriptorLength  ,
    IN  SECURITY_INFORMATION  RequiredInformation       );

*/
void EmuApi::EmuRtlValidRelativeSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptorInput{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptorInput);

    ULONG SecurityDescriptorLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SecurityDescriptorLength);

    SECURITY_INFORMATION RequiredInformation{};
    uc_reg_read(uc, UC_X86_REG_R8D, &RequiredInformation);


    BOOLEAN RtlValidRelativeSecurityDescriptorResult = RtlValidRelativeSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptorInput,(ULONG)SecurityDescriptorLength,(SECURITY_INFORMATION)RequiredInformation);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlValidRelativeSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptorInput);
    uc_reg_write(uc, UC_X86_REG_EDX, &SecurityDescriptorLength);
    uc_reg_write(uc, UC_X86_REG_R8D, &RequiredInformation);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlValidRelativeSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetControlSecurityDescriptor(
      PSECURITY_DESCRIPTOR          SecurityDescriptor  ,
      PSECURITY_DESCRIPTOR_CONTROL  Control             ,
      PULONG                        Revision            );

*/
void EmuApi::EmuRtlGetControlSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSECURITY_DESCRIPTOR_CONTROL Control{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Control);

    WORD rlControl{};

    if(Control != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Control, &rlControl, sizeof(rlControl));
    }

    PULONG Revision{};
    uc_reg_read(uc, UC_X86_REG_R8, &Revision);

    ULONG rlRevision{};

    if(Revision != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Revision, &rlRevision, sizeof(rlRevision));
    }


    NTSTATUS RtlGetControlSecurityDescriptorResult = RtlGetControlSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSECURITY_DESCRIPTOR_CONTROL)&rlControl,(PULONG)&rlRevision);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetControlSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &Control);

    if(Control != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Control, &rlControl, sizeof(rlControl));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Revision);

    if(Revision != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Revision, &rlRevision, sizeof(rlRevision));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetControlSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetControlSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR         pSecurityDescriptor    ,
    IN  SECURITY_DESCRIPTOR_CONTROL  ControlBitsOfInterest  ,
    IN  SECURITY_DESCRIPTOR_CONTROL  ControlBitsToSet       );

*/
void EmuApi::EmuRtlSetControlSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR pSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &pSecurityDescriptor);

    SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest{};
    uc_reg_read(uc, UC_X86_REG_DX, &ControlBitsOfInterest);

    SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet{};
    uc_reg_read(uc, UC_X86_REG_R8W, &ControlBitsToSet);


    NTSTATUS RtlSetControlSecurityDescriptorResult = RtlSetControlSecurityDescriptor((PSECURITY_DESCRIPTOR)&pSecurityDescriptor,(SECURITY_DESCRIPTOR_CONTROL)ControlBitsOfInterest,(SECURITY_DESCRIPTOR_CONTROL)ControlBitsToSet);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetControlSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &pSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_DX, &ControlBitsOfInterest);
    uc_reg_write(uc, UC_X86_REG_R8W, &ControlBitsToSet);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetControlSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetAttributesSecurityDescriptor(
    IN     PSECURITY_DESCRIPTOR         SecurityDescriptor  ,
    IN     SECURITY_DESCRIPTOR_CONTROL  Control             ,
    INOUT  PULONG                       Revision            );

*/
void EmuApi::EmuRtlSetAttributesSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    SECURITY_DESCRIPTOR_CONTROL Control{};
    uc_reg_read(uc, UC_X86_REG_DX, &Control);

    PULONG Revision{};
    uc_reg_read(uc, UC_X86_REG_R8, &Revision);

    ULONG rlRevision{};

    if(Revision != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Revision, &rlRevision, sizeof(rlRevision));
    }


    NTSTATUS RtlSetAttributesSecurityDescriptorResult = RtlSetAttributesSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(SECURITY_DESCRIPTOR_CONTROL)Control,(PULONG)&rlRevision);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetAttributesSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_DX, &Control);
    uc_reg_write(uc, UC_X86_REG_R8, &Revision);

    if(Revision != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Revision, &rlRevision, sizeof(rlRevision));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetAttributesSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetDaclSecurityDescriptor(
      PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
      BOOLEAN               DaclPresent         ,
      PACL                  Dacl                ,
      BOOLEAN               DaclDefaulted       );

*/
void EmuApi::EmuRtlSetDaclSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    BOOLEAN DaclPresent{};
    uc_reg_read(uc, UC_X86_REG_DL, &DaclPresent);

    PACL Dacl{};
    uc_reg_read(uc, UC_X86_REG_R8, &Dacl);

    ACL rlDacl{};

    if(Dacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Dacl, &rlDacl, sizeof(rlDacl));
    }

    BOOLEAN DaclDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R9B, &DaclDefaulted);


    NTSTATUS RtlSetDaclSecurityDescriptorResult = RtlSetDaclSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(BOOLEAN)DaclPresent,(PACL)&rlDacl,(BOOLEAN)DaclDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetDaclSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_DL, &DaclPresent);
    uc_reg_write(uc, UC_X86_REG_R8, &Dacl);

    if(Dacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Dacl, &rlDacl, sizeof(rlDacl));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &DaclDefaulted);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetDaclSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetDaclSecurityDescriptor(
    IN   PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    OUT  PBOOLEAN              DaclPresent         ,
    OUT  PACL *                Dacl                ,
    OUT  PBOOLEAN              DaclDefaulted       );

*/
void EmuApi::EmuRtlGetDaclSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PBOOLEAN DaclPresent{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DaclPresent);

    BOOLEAN rlDaclPresent{};

    if(DaclPresent != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DaclPresent, &rlDaclPresent, sizeof(rlDaclPresent));
    }

    PACL * Dacl{};
    uc_reg_read(uc, UC_X86_REG_R8, &Dacl);

    PACL * dpDacl{};

    if(Dacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Dacl, &dpDacl, sizeof(dpDacl));
    }

    ACL rlDacl{};

    if(dpDacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpDacl, &rlDacl, sizeof(rlDacl));
    }

    PBOOLEAN DaclDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R9, &DaclDefaulted);

    BOOLEAN rlDaclDefaulted{};

    if(DaclDefaulted != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DaclDefaulted, &rlDaclDefaulted, sizeof(rlDaclDefaulted));
    }


    NTSTATUS RtlGetDaclSecurityDescriptorResult = RtlGetDaclSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PBOOLEAN)&rlDaclPresent,(PACL *)&rlDacl,(PBOOLEAN)&rlDaclDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetDaclSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &DaclPresent);

    if(DaclPresent != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DaclPresent, &rlDaclPresent, sizeof(rlDaclPresent));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Dacl);

    if(Dacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Dacl, &dpDacl, sizeof(dpDacl));
    }

    if(dpDacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpDacl, &rlDacl, sizeof(rlDacl));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &DaclDefaulted);

    if(DaclDefaulted != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DaclDefaulted, &rlDaclDefaulted, sizeof(rlDaclDefaulted));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetDaclSecurityDescriptor\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlGetSecurityDescriptorRMControl(
    IN   PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    OUT  PUCHAR                RMControl           );

*/
void EmuApi::EmuRtlGetSecurityDescriptorRMControl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PUCHAR RMControl{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RMControl);

    UCHAR rlRMControl{};

    if(RMControl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RMControl, &rlRMControl, sizeof(rlRMControl));
    }


    BOOLEAN RtlGetSecurityDescriptorRMControlResult = RtlGetSecurityDescriptorRMControl((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PUCHAR)&rlRMControl);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlGetSecurityDescriptorRMControlResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &RMControl);

    if(RMControl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RMControl, &rlRMControl, sizeof(rlRMControl));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetSecurityDescriptorRMControl\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetSecurityDescriptorRMControl(
      PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
      PUCHAR                RMControl           );

*/
void EmuApi::EmuRtlSetSecurityDescriptorRMControl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PUCHAR RMControl{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RMControl);

    UCHAR rlRMControl{};

    if(RMControl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RMControl, &rlRMControl, sizeof(rlRMControl));
    }


    RtlSetSecurityDescriptorRMControl((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PUCHAR)&rlRMControl);


    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &RMControl);

    if(RMControl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RMControl, &rlRMControl, sizeof(rlRMControl));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetSecurityDescriptorRMControl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetSaclSecurityDescriptor(
      PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
      BOOLEAN               SaclPresent         ,
      PACL                  Sacl                ,
      BOOLEAN               SaclDefaulted       );

*/
void EmuApi::EmuRtlSetSaclSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    BOOLEAN SaclPresent{};
    uc_reg_read(uc, UC_X86_REG_DL, &SaclPresent);

    PACL Sacl{};
    uc_reg_read(uc, UC_X86_REG_R8, &Sacl);

    ACL rlSacl{};

    if(Sacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sacl, &rlSacl, sizeof(rlSacl));
    }

    BOOLEAN SaclDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R9B, &SaclDefaulted);


    NTSTATUS RtlSetSaclSecurityDescriptorResult = RtlSetSaclSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(BOOLEAN)SaclPresent,(PACL)&rlSacl,(BOOLEAN)SaclDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetSaclSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_DL, &SaclPresent);
    uc_reg_write(uc, UC_X86_REG_R8, &Sacl);

    if(Sacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sacl, &rlSacl, sizeof(rlSacl));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &SaclDefaulted);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetSaclSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetSaclSecurityDescriptor(
    IN   PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    OUT  PBOOLEAN              SaclPresent         ,
    OUT  PACL *                Sacl                ,
    OUT  PBOOLEAN              SaclDefaulted       );

*/
void EmuApi::EmuRtlGetSaclSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PBOOLEAN SaclPresent{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SaclPresent);

    BOOLEAN rlSaclPresent{};

    if(SaclPresent != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SaclPresent, &rlSaclPresent, sizeof(rlSaclPresent));
    }

    PACL * Sacl{};
    uc_reg_read(uc, UC_X86_REG_R8, &Sacl);

    PACL * dpSacl{};

    if(Sacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sacl, &dpSacl, sizeof(dpSacl));
    }

    ACL rlSacl{};

    if(dpSacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpSacl, &rlSacl, sizeof(rlSacl));
    }

    PBOOLEAN SaclDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R9, &SaclDefaulted);

    BOOLEAN rlSaclDefaulted{};

    if(SaclDefaulted != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SaclDefaulted, &rlSaclDefaulted, sizeof(rlSaclDefaulted));
    }


    NTSTATUS RtlGetSaclSecurityDescriptorResult = RtlGetSaclSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PBOOLEAN)&rlSaclPresent,(PACL *)&rlSacl,(PBOOLEAN)&rlSaclDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetSaclSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &SaclPresent);

    if(SaclPresent != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SaclPresent, &rlSaclPresent, sizeof(rlSaclPresent));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Sacl);

    if(Sacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sacl, &dpSacl, sizeof(dpSacl));
    }

    if(dpSacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpSacl, &rlSacl, sizeof(rlSacl));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &SaclDefaulted);

    if(SaclDefaulted != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SaclDefaulted, &rlSaclDefaulted, sizeof(rlSaclDefaulted));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetSaclSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetGroupSecurityDescriptor(
    INOUT  PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN     PSID                  Group               ,
    ,IN    BOOLEAN               GroupDefaulted      );

*/
void EmuApi::EmuRtlSetGroupSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID Group{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Group);

    BOOLEAN GroupDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R8B, &GroupDefaulted);


    NTSTATUS RtlSetGroupSecurityDescriptorResult = RtlSetGroupSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&Group,(BOOLEAN)GroupDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetGroupSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &Group);
    uc_reg_write(uc, UC_X86_REG_R8B, &GroupDefaulted);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetGroupSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetGroupSecurityDescriptor(
    IN   PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    OUT  PSID *                Group               ,
    OUT  PBOOLEAN              GroupDefaulted      );

*/
void EmuApi::EmuRtlGetGroupSecurityDescriptor(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID * Group{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Group);

    PSID * dpGroup{};

    if(Group != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Group, &dpGroup, sizeof(dpGroup));
    }

    PBOOLEAN GroupDefaulted{};
    uc_reg_read(uc, UC_X86_REG_R8, &GroupDefaulted);

    BOOLEAN rlGroupDefaulted{};

    if(GroupDefaulted != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GroupDefaulted, &rlGroupDefaulted, sizeof(rlGroupDefaulted));
    }


    NTSTATUS RtlGetGroupSecurityDescriptorResult = RtlGetGroupSecurityDescriptor((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID *)&dpGroup,(PBOOLEAN)&rlGroupDefaulted);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetGroupSecurityDescriptorResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &Group);

    if(Group != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Group, &dpGroup, sizeof(dpGroup));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &GroupDefaulted);

    if(GroupDefaulted != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GroupDefaulted, &rlGroupDefaulted, sizeof(rlGroupDefaulted));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetGroupSecurityDescriptor\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlMakeSelfRelativeSD(
    IN     PSECURITY_DESCRIPTOR  AbsoluteSecurityDescriptor      ,
    OUT    PSECURITY_DESCRIPTOR  SelfRelativeSecurityDescriptor  ,
    INOUT  PULONG                BufferLength                    );

*/
void EmuApi::EmuRtlMakeSelfRelativeSD(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AbsoluteSecurityDescriptor);

    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SelfRelativeSecurityDescriptor);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS RtlMakeSelfRelativeSDResult = RtlMakeSelfRelativeSD((PSECURITY_DESCRIPTOR)&AbsoluteSecurityDescriptor,(PSECURITY_DESCRIPTOR)&SelfRelativeSecurityDescriptor,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlMakeSelfRelativeSDResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AbsoluteSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &SelfRelativeSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlMakeSelfRelativeSD\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAbsoluteToSelfRelativeSD(
    IN     PSECURITY_DESCRIPTOR  AbsoluteSecurityDescriptor      ,
    OUT    PSECURITY_DESCRIPTOR  SelfRelativeSecurityDescriptor  ,
    INOUT  PULONG                BufferLength                    );

*/
void EmuApi::EmuRtlAbsoluteToSelfRelativeSD(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AbsoluteSecurityDescriptor);

    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SelfRelativeSecurityDescriptor);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS RtlAbsoluteToSelfRelativeSDResult = RtlAbsoluteToSelfRelativeSD((PSECURITY_DESCRIPTOR)&AbsoluteSecurityDescriptor,(PSECURITY_DESCRIPTOR)&SelfRelativeSecurityDescriptor,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAbsoluteToSelfRelativeSDResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &AbsoluteSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &SelfRelativeSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAbsoluteToSelfRelativeSD\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSelfRelativeToAbsoluteSD(
    IN           PSECURITY_DESCRIPTOR  SelfRelativeSecurityDescriptor  ,
    OUTOPTIONAL  PSECURITY_DESCRIPTOR  AbsoluteSecurityDescriptor      ,
    INOUT        PULONG                AbsoluteSecurityDescriptorSize  ,
    OUTOPTIONAL  PACL                  Dacl                            ,
    INOUT        PULONG                DaclSize                        ,
    OUTOPTIONAL  PACL                  Sacl                            ,
    INOUT        PULONG                SaclSize                        ,
    OUTOPTIONAL  PSID                  Owner                           ,
    INOUT        PULONG                OwnerSize                       ,
    OUTOPTIONAL  PSID                  PrimaryGroup                    ,
    INOUT        PULONG                PrimaryGroupSize                );

*/
void EmuApi::EmuRtlSelfRelativeToAbsoluteSD(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SelfRelativeSecurityDescriptor);

    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &AbsoluteSecurityDescriptor);

    PULONG AbsoluteSecurityDescriptorSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &AbsoluteSecurityDescriptorSize);

    ULONG rlAbsoluteSecurityDescriptorSize{};

    if(AbsoluteSecurityDescriptorSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AbsoluteSecurityDescriptorSize, &rlAbsoluteSecurityDescriptorSize, sizeof(rlAbsoluteSecurityDescriptorSize));
    }

    PACL Dacl{};
    uc_reg_read(uc, UC_X86_REG_R9, &Dacl);

    ACL rlDacl{};

    if(Dacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Dacl, &rlDacl, sizeof(rlDacl));
    }

    PULONG DaclSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &DaclSize, sizeof(DaclSize));

    ULONG rlDaclSize{};

    if(DaclSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DaclSize, &rlDaclSize, sizeof(rlDaclSize));
    }

    PACL Sacl{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Sacl, sizeof(Sacl));

    ACL rlSacl{};

    if(Sacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sacl, &rlSacl, sizeof(rlSacl));
    }

    PULONG SaclSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &SaclSize, sizeof(SaclSize));

    ULONG rlSaclSize{};

    if(SaclSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SaclSize, &rlSaclSize, sizeof(rlSaclSize));
    }

    PSID Owner{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Owner, sizeof(Owner));

    PULONG OwnerSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &OwnerSize, sizeof(OwnerSize));

    ULONG rlOwnerSize{};

    if(OwnerSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OwnerSize, &rlOwnerSize, sizeof(rlOwnerSize));
    }

    PSID PrimaryGroup{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &PrimaryGroup, sizeof(PrimaryGroup));

    PULONG PrimaryGroupSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &PrimaryGroupSize, sizeof(PrimaryGroupSize));

    ULONG rlPrimaryGroupSize{};

    if(PrimaryGroupSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrimaryGroupSize, &rlPrimaryGroupSize, sizeof(rlPrimaryGroupSize));
    }


    NTSTATUS RtlSelfRelativeToAbsoluteSDResult = RtlSelfRelativeToAbsoluteSD((PSECURITY_DESCRIPTOR)&SelfRelativeSecurityDescriptor,(PSECURITY_DESCRIPTOR)&AbsoluteSecurityDescriptor,(PULONG)&rlAbsoluteSecurityDescriptorSize,(PACL)&rlDacl,(PULONG)&rlDaclSize,(PACL)&rlSacl,(PULONG)&rlSaclSize,(PSID)&Owner,(PULONG)&rlOwnerSize,(PSID)&PrimaryGroup,(PULONG)&rlPrimaryGroupSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSelfRelativeToAbsoluteSDResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SelfRelativeSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &AbsoluteSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &AbsoluteSecurityDescriptorSize);

    if(AbsoluteSecurityDescriptorSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AbsoluteSecurityDescriptorSize, &rlAbsoluteSecurityDescriptorSize, sizeof(rlAbsoluteSecurityDescriptorSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Dacl);

    if(Dacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Dacl, &rlDacl, sizeof(rlDacl));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &DaclSize, sizeof(DaclSize));

    if(DaclSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DaclSize, &rlDaclSize, sizeof(rlDaclSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Sacl, sizeof(Sacl));

    if(Sacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sacl, &rlSacl, sizeof(rlSacl));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &SaclSize, sizeof(SaclSize));

    if(SaclSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SaclSize, &rlSaclSize, sizeof(rlSaclSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Owner, sizeof(Owner));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &OwnerSize, sizeof(OwnerSize));

    if(OwnerSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OwnerSize, &rlOwnerSize, sizeof(rlOwnerSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &PrimaryGroup, sizeof(PrimaryGroup));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &PrimaryGroupSize, sizeof(PrimaryGroupSize));

    if(PrimaryGroupSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrimaryGroupSize, &rlPrimaryGroupSize, sizeof(rlPrimaryGroupSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSelfRelativeToAbsoluteSD\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSelfRelativeToAbsoluteSD2(
    INOUT  PSECURITY_DESCRIPTOR  pSelfRelativeSecurityDescriptor  ,
    INOUT  PULONG                pBufferSize                      );

*/
void EmuApi::EmuRtlSelfRelativeToAbsoluteSD2(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &pSelfRelativeSecurityDescriptor);

    PULONG pBufferSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &pBufferSize);

    ULONG rlpBufferSize{};

    if(pBufferSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pBufferSize, &rlpBufferSize, sizeof(rlpBufferSize));
    }


    NTSTATUS RtlSelfRelativeToAbsoluteSD2Result = RtlSelfRelativeToAbsoluteSD2((PSECURITY_DESCRIPTOR)&pSelfRelativeSecurityDescriptor,(PULONG)&rlpBufferSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSelfRelativeToAbsoluteSD2Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &pSelfRelativeSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &pBufferSize);

    if(pBufferSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pBufferSize, &rlpBufferSize, sizeof(rlpBufferSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSelfRelativeToAbsoluteSD2\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlImpersonateSelf(
    IN  SECURITY_IMPERSONATION_LEVEL  ImpersonationLevel  );

*/
void EmuApi::EmuRtlImpersonateSelf(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ImpersonationLevel);


    NTSTATUS RtlImpersonateSelfResult = RtlImpersonateSelf((SECURITY_IMPERSONATION_LEVEL)ImpersonationLevel);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlImpersonateSelfResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ImpersonationLevel);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlImpersonateSelf\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAdjustPrivilege(
      ULONG     Privilege   ,
      BOOLEAN   Enable      ,
      BOOLEAN   Client      ,
      PBOOLEAN  WasEnabled  );

*/
void EmuApi::EmuRtlAdjustPrivilege(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Privilege{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Privilege);

    BOOLEAN Enable{};
    uc_reg_read(uc, UC_X86_REG_DL, &Enable);

    BOOLEAN Client{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Client);

    PBOOLEAN WasEnabled{};
    uc_reg_read(uc, UC_X86_REG_R9, &WasEnabled);

    BOOLEAN rlWasEnabled{};

    if(WasEnabled != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)WasEnabled, &rlWasEnabled, sizeof(rlWasEnabled));
    }


    NTSTATUS RtlAdjustPrivilegeResult = RtlAdjustPrivilege((ULONG)Privilege,(BOOLEAN)Enable,(BOOLEAN)Client,(PBOOLEAN)&rlWasEnabled);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAdjustPrivilegeResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Privilege);
    uc_reg_write(uc, UC_X86_REG_DL, &Enable);
    uc_reg_write(uc, UC_X86_REG_R8B, &Client);
    uc_reg_write(uc, UC_X86_REG_R9, &WasEnabled);

    if(WasEnabled != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)WasEnabled, &rlWasEnabled, sizeof(rlWasEnabled));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAdjustPrivilege\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlAcquirePrivilege(
      PULONG   Privilege      ,
      ULONG    NumPriv        ,
      ULONG    Flags          ,
      PVOID *  ReturnedState  );

*/
void EmuApi::EmuRtlAcquirePrivilege(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Privilege{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Privilege);

    ULONG rlPrivilege{};

    if(Privilege != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privilege, &rlPrivilege, sizeof(rlPrivilege));
    }

    ULONG NumPriv{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumPriv);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);

    PVOID * ReturnedState{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReturnedState);

    PVOID * dpReturnedState{};

    if(ReturnedState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnedState, &dpReturnedState, sizeof(dpReturnedState));
    }


    NTSTATUS RtlAcquirePrivilegeResult = RtlAcquirePrivilege((PULONG)&rlPrivilege,(ULONG)NumPriv,(ULONG)Flags,(PVOID *)&dpReturnedState);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlAcquirePrivilegeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Privilege);

    if(Privilege != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privilege, &rlPrivilege, sizeof(rlPrivilege));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &NumPriv);
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    uc_reg_write(uc, UC_X86_REG_R9, &ReturnedState);

    if(ReturnedState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnedState, &dpReturnedState, sizeof(dpReturnedState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAcquirePrivilege\n";
    #endif

    return;
}


/*
void
__cdecl
RtlReleasePrivilege(
      PVOID  StatePointer  );

*/
void EmuApi::EmuRtlReleasePrivilege(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID StatePointer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &StatePointer);


    RtlReleasePrivilege((PVOID)&StatePointer);


    uc_reg_write(uc, UC_X86_REG_RCX, &StatePointer);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlReleasePrivilege\n";
    #endif

    return;
}


/*
void
__cdecl
RtlRunEncodeUnicodeString(
      PUCHAR           Seed    ,
      PUNICODE_STRING  String  );

*/
void EmuApi::EmuRtlRunEncodeUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUCHAR Seed{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Seed);

    UCHAR rlSeed{};

    if(Seed != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Seed, &rlSeed, sizeof(rlSeed));
    }

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlRunEncodeUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    RtlRunEncodeUnicodeString((PUCHAR)&rlSeed,(PUNICODE_STRING)&stString);


    uc_reg_write(uc, UC_X86_REG_RCX, &Seed);

    if(Seed != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Seed, &rlSeed, sizeof(rlSeed));
    }
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlRunEncodeUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRunEncodeUnicodeString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlRunDecodeUnicodeString(
      UCHAR            Seed    ,
      PUNICODE_STRING  String  );

*/
void EmuApi::EmuRtlRunDecodeUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    UCHAR Seed{};
    uc_reg_read(uc, UC_X86_REG_CL, &Seed);

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RDX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlRunDecodeUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    RtlRunDecodeUnicodeString((UCHAR)Seed,(PUNICODE_STRING)&stString);


    uc_reg_write(uc, UC_X86_REG_CL, &Seed);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlRunDecodeUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRunDecodeUnicodeString\n";
    #endif

    return;
}


/*
void
__cdecl
RtlEraseUnicodeString(
      PUNICODE_STRING  String  );

*/
void EmuApi::EmuRtlEraseUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in RtlEraseUnicodeString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    RtlEraseUnicodeString((PUNICODE_STRING)&stString);


    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in RtlEraseUnicodeString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEraseUnicodeString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlFindMessage(
      PVOID                      DllHandle          ,
      ULONG                      MessageTableId     ,
      ULONG                      MessageLanguageId  ,
      ULONG                      MessageId          ,
      PMESSAGE_RESOURCE_ENTRY *  MessageEntry       );

*/
void EmuApi::EmuRtlFindMessage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllHandle);

    ULONG MessageTableId{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MessageTableId);

    ULONG MessageLanguageId{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MessageLanguageId);

    ULONG MessageId{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MessageId);

    PMESSAGE_RESOURCE_ENTRY * MessageEntry{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MessageEntry, sizeof(MessageEntry));

    PMESSAGE_RESOURCE_ENTRY * dpMessageEntry{};

    if(MessageEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MessageEntry, &dpMessageEntry, sizeof(dpMessageEntry));
    }

    MESSAGE_RESOURCE_ENTRY stMessageEntry{};

    if(dpMessageEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dpMessageEntry, &stMessageEntry, sizeof(stMessageEntry));
    }


    NTSTATUS RtlFindMessageResult = RtlFindMessage((PVOID)&DllHandle,(ULONG)MessageTableId,(ULONG)MessageLanguageId,(ULONG)MessageId,(PMESSAGE_RESOURCE_ENTRY *)&stMessageEntry);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFindMessageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DllHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &MessageTableId);
    uc_reg_write(uc, UC_X86_REG_R8D, &MessageLanguageId);
    uc_reg_write(uc, UC_X86_REG_R9D, &MessageId);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MessageEntry, sizeof(MessageEntry));

    if(MessageEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MessageEntry, &dpMessageEntry, sizeof(dpMessageEntry));
    }

    if(dpMessageEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dpMessageEntry, &stMessageEntry, sizeof(stMessageEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFindMessage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlFormatMessage(
    IN           PWSTR      MessageFormat        ,
    IN           ULONG      MaximumWidth         ,
    IN           BOOLEAN    IgnoreInserts        ,
    IN           BOOLEAN    ArgumentsAreAnsi     ,
    IN           BOOLEAN    ArgumentsAreAnArray  ,
    IN           va_list *  Arguments            ,
    OUT          PWSTR      Buffer               ,
    IN           ULONG      Length               ,
    OUTOPTIONAL  PULONG     ReturnLength         );

*/
void EmuApi::EmuRtlFormatMessage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR MessageFormat{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MessageFormat);

    std::wstring rlwMessageFormat;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)MessageFormat, rlwMessageFormat)) { printf("Error when read MessageFormat in RtlFormatMessage"); _CrtDbgBreak(); }

    ULONG MaximumWidth{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaximumWidth);

    BOOLEAN IgnoreInserts{};
    uc_reg_read(uc, UC_X86_REG_R8B, &IgnoreInserts);

    BOOLEAN ArgumentsAreAnsi{};
    uc_reg_read(uc, UC_X86_REG_R9B, &ArgumentsAreAnsi);

    BOOLEAN ArgumentsAreAnArray{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ArgumentsAreAnArray, sizeof(ArgumentsAreAnArray));

    va_list * Arguments{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Arguments, sizeof(Arguments));

    std::string rlaArguments;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Arguments, rlaArguments)) { printf("Error when read Arguments in RtlFormatMessage"); _CrtDbgBreak(); }

    PWSTR Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Buffer, sizeof(Buffer));

    std::wstring rlwBuffer;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Buffer, rlwBuffer)) { printf("Error when read Buffer in RtlFormatMessage"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Length, sizeof(Length));

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS RtlFormatMessageResult = RtlFormatMessage((PWSTR)rlwMessageFormat.data(),(ULONG)MaximumWidth,(BOOLEAN)IgnoreInserts,(BOOLEAN)ArgumentsAreAnsi,(BOOLEAN)ArgumentsAreAnArray,(va_list *)rlaArguments.data(),(PWSTR)rlwBuffer.data(),(ULONG)Length,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFormatMessageResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)MessageFormat, rlwMessageFormat)) { printf("Error when read MessageFormat in RtlFormatMessage"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaximumWidth);
    uc_reg_write(uc, UC_X86_REG_R8B, &IgnoreInserts);
    uc_reg_write(uc, UC_X86_REG_R9B, &ArgumentsAreAnsi);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ArgumentsAreAnArray, sizeof(ArgumentsAreAnArray));
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Arguments, rlaArguments)) { printf("Error when read Arguments in RtlFormatMessage"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Buffer, rlwBuffer)) { printf("Error when read Buffer in RtlFormatMessage"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFormatMessage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlFormatMessageEx(
    IN           PWSTR                   MessageFormat        ,
    IN           ULONG                   MaximumWidth         ,
    IN           BOOLEAN                 IgnoreInserts        ,
    IN           BOOLEAN                 ArgumentsAreAnsi     ,
    IN           BOOLEAN                 ArgumentsAreAnArray  ,
    IN           va_list *               Arguments            ,
    OUT          PWSTR                   Buffer               ,
    IN           ULONG                   Length               ,
    OUTOPTIONAL  PULONG                  ReturnLength         ,
    OUTOPTIONAL  PPARSE_MESSAGE_CONTEXT  ParseContext         );

*/
void EmuApi::EmuRtlFormatMessageEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR MessageFormat{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MessageFormat);

    std::wstring rlwMessageFormat;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)MessageFormat, rlwMessageFormat)) { printf("Error when read MessageFormat in RtlFormatMessageEx"); _CrtDbgBreak(); }

    ULONG MaximumWidth{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MaximumWidth);

    BOOLEAN IgnoreInserts{};
    uc_reg_read(uc, UC_X86_REG_R8B, &IgnoreInserts);

    BOOLEAN ArgumentsAreAnsi{};
    uc_reg_read(uc, UC_X86_REG_R9B, &ArgumentsAreAnsi);

    BOOLEAN ArgumentsAreAnArray{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ArgumentsAreAnArray, sizeof(ArgumentsAreAnArray));

    va_list * Arguments{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Arguments, sizeof(Arguments));

    std::string rlaArguments;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Arguments, rlaArguments)) { printf("Error when read Arguments in RtlFormatMessageEx"); _CrtDbgBreak(); }

    PWSTR Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Buffer, sizeof(Buffer));

    std::wstring rlwBuffer;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Buffer, rlwBuffer)) { printf("Error when read Buffer in RtlFormatMessageEx"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Length, sizeof(Length));

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }

    PPARSE_MESSAGE_CONTEXT ParseContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ParseContext, sizeof(ParseContext));

    PARSE_MESSAGE_CONTEXT stParseContext{};

    if(ParseContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ParseContext, &stParseContext, sizeof(stParseContext));
    }


    NTSTATUS RtlFormatMessageExResult = RtlFormatMessageEx((PWSTR)rlwMessageFormat.data(),(ULONG)MaximumWidth,(BOOLEAN)IgnoreInserts,(BOOLEAN)ArgumentsAreAnsi,(BOOLEAN)ArgumentsAreAnArray,(va_list *)rlaArguments.data(),(PWSTR)rlwBuffer.data(),(ULONG)Length,(PULONG)&rlReturnLength,(PPARSE_MESSAGE_CONTEXT)&stParseContext);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlFormatMessageExResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)MessageFormat, rlwMessageFormat)) { printf("Error when read MessageFormat in RtlFormatMessageEx"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &MaximumWidth);
    uc_reg_write(uc, UC_X86_REG_R8B, &IgnoreInserts);
    uc_reg_write(uc, UC_X86_REG_R9B, &ArgumentsAreAnsi);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ArgumentsAreAnArray, sizeof(ArgumentsAreAnArray));
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Arguments, rlaArguments)) { printf("Error when read Arguments in RtlFormatMessageEx"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Buffer, rlwBuffer)) { printf("Error when read Buffer in RtlFormatMessageEx"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ParseContext, sizeof(ParseContext));

    if(ParseContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ParseContext, &stParseContext, sizeof(stParseContext));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFormatMessageEx\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlNtStatusToDosError(
      NTSTATUS  Status  );

*/
void EmuApi::EmuRtlNtStatusToDosError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS Status{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Status);


    ULONG RtlNtStatusToDosErrorResult = RtlNtStatusToDosError((NTSTATUS)Status);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNtStatusToDosErrorResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNtStatusToDosError\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlNtStatusToDosErrorNoTeb(
      NTSTATUS  Status  );

*/
void EmuApi::EmuRtlNtStatusToDosErrorNoTeb(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS Status{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Status);


    ULONG RtlNtStatusToDosErrorNoTebResult = RtlNtStatusToDosErrorNoTeb((NTSTATUS)Status);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNtStatusToDosErrorNoTebResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNtStatusToDosErrorNoTeb\n";
    #endif

    return;
}


/*
PPEB
__cdecl
RtlGetCurrentPeb(VOID);

*/
void EmuApi::EmuRtlGetCurrentPeb(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    PPEB RtlGetCurrentPebResult = RtlGetCurrentPeb();


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlGetCurrentPebResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCurrentPeb\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCustomCPToUnicodeN(
    IN           PCPTABLEINFO  CustomCP                 ,
    OUT          PWCH          UnicodeString            ,
    IN           ULONG         MaxBytesInUnicodeString  ,
    OUTOPTIONAL  PULONG        BytesInUnicodeString     ,
    IN           PCH           CustomCPString           ,
    IN           ULONG         BytesInCustomCPString    );

*/
void EmuApi::EmuRtlCustomCPToUnicodeN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCPTABLEINFO CustomCP{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CustomCP);

    CPTABLEINFO stCustomCP{};

    if(CustomCP != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CustomCP, &stCustomCP, sizeof(stCustomCP));
    }

    PWCH UnicodeString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UnicodeString);

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlCustomCPToUnicodeN"); _CrtDbgBreak(); }

    ULONG MaxBytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxBytesInUnicodeString);

    PULONG BytesInUnicodeString{};
    uc_reg_read(uc, UC_X86_REG_R9, &BytesInUnicodeString);

    ULONG rlBytesInUnicodeString{};

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }

    PCH CustomCPString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CustomCPString, sizeof(CustomCPString));

    std::string rlaCustomCPString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)CustomCPString, rlaCustomCPString)) { printf("Error when read CustomCPString in RtlCustomCPToUnicodeN"); _CrtDbgBreak(); }

    ULONG BytesInCustomCPString{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &BytesInCustomCPString, sizeof(BytesInCustomCPString));


    NTSTATUS RtlCustomCPToUnicodeNResult = RtlCustomCPToUnicodeN((PCPTABLEINFO)&stCustomCP,(PWCH)rlwUnicodeString.data(),(ULONG)MaxBytesInUnicodeString,(PULONG)&rlBytesInUnicodeString,(PCH)rlaCustomCPString.data(),(ULONG)BytesInCustomCPString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCustomCPToUnicodeNResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CustomCP);

    if(CustomCP != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CustomCP, &stCustomCP, sizeof(stCustomCP));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlCustomCPToUnicodeN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxBytesInUnicodeString);
    uc_reg_write(uc, UC_X86_REG_R9, &BytesInUnicodeString);

    if(BytesInUnicodeString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInUnicodeString, &rlBytesInUnicodeString, sizeof(rlBytesInUnicodeString));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)CustomCPString, rlaCustomCPString)) { printf("Error when read CustomCPString in RtlCustomCPToUnicodeN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInCustomCPString, sizeof(BytesInCustomCPString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCustomCPToUnicodeN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUnicodeToCustomCPN(
    IN           PCPTABLEINFO  CustomCP                  ,
    OUT          PCH           CustomCPString            ,
    IN           ULONG         MaxBytesInCustomCPString  ,
    OUTOPTIONAL  PULONG        BytesInCustomCPString     ,
    IN           PWCH          UnicodeString             ,
    IN           ULONG         BytesInUnicodeString      );

*/
void EmuApi::EmuRtlUnicodeToCustomCPN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCPTABLEINFO CustomCP{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CustomCP);

    CPTABLEINFO stCustomCP{};

    if(CustomCP != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CustomCP, &stCustomCP, sizeof(stCustomCP));
    }

    PCH CustomCPString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CustomCPString);

    std::string rlaCustomCPString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)CustomCPString, rlaCustomCPString)) { printf("Error when read CustomCPString in RtlUnicodeToCustomCPN"); _CrtDbgBreak(); }

    ULONG MaxBytesInCustomCPString{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxBytesInCustomCPString);

    PULONG BytesInCustomCPString{};
    uc_reg_read(uc, UC_X86_REG_R9, &BytesInCustomCPString);

    ULONG rlBytesInCustomCPString{};

    if(BytesInCustomCPString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInCustomCPString, &rlBytesInCustomCPString, sizeof(rlBytesInCustomCPString));
    }

    PWCH UnicodeString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &UnicodeString, sizeof(UnicodeString));

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToCustomCPN"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &BytesInUnicodeString, sizeof(BytesInUnicodeString));


    NTSTATUS RtlUnicodeToCustomCPNResult = RtlUnicodeToCustomCPN((PCPTABLEINFO)&stCustomCP,(PCH)rlaCustomCPString.data(),(ULONG)MaxBytesInCustomCPString,(PULONG)&rlBytesInCustomCPString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUnicodeToCustomCPNResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CustomCP);

    if(CustomCP != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CustomCP, &stCustomCP, sizeof(stCustomCP));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)CustomCPString, rlaCustomCPString)) { printf("Error when read CustomCPString in RtlUnicodeToCustomCPN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxBytesInCustomCPString);
    uc_reg_write(uc, UC_X86_REG_R9, &BytesInCustomCPString);

    if(BytesInCustomCPString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInCustomCPString, &rlBytesInCustomCPString, sizeof(rlBytesInCustomCPString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUnicodeToCustomCPN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnicodeToCustomCPN\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpcaseUnicodeToCustomCPN(
    IN           PCPTABLEINFO  CustomCP                  ,
    OUT          PCH           CustomCPString            ,
    IN           ULONG         MaxBytesInCustomCPString  ,
    OUTOPTIONAL  PULONG        BytesInCustomCPString     ,
    IN           PWCH          UnicodeString             ,
    IN           ULONG         BytesInUnicodeString      );

*/
void EmuApi::EmuRtlUpcaseUnicodeToCustomCPN(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCPTABLEINFO CustomCP{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CustomCP);

    CPTABLEINFO stCustomCP{};

    if(CustomCP != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CustomCP, &stCustomCP, sizeof(stCustomCP));
    }

    PCH CustomCPString{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CustomCPString);

    std::string rlaCustomCPString;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)CustomCPString, rlaCustomCPString)) { printf("Error when read CustomCPString in RtlUpcaseUnicodeToCustomCPN"); _CrtDbgBreak(); }

    ULONG MaxBytesInCustomCPString{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxBytesInCustomCPString);

    PULONG BytesInCustomCPString{};
    uc_reg_read(uc, UC_X86_REG_R9, &BytesInCustomCPString);

    ULONG rlBytesInCustomCPString{};

    if(BytesInCustomCPString != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BytesInCustomCPString, &rlBytesInCustomCPString, sizeof(rlBytesInCustomCPString));
    }

    PWCH UnicodeString{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &UnicodeString, sizeof(UnicodeString));

    std::wstring rlwUnicodeString;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUpcaseUnicodeToCustomCPN"); _CrtDbgBreak(); }

    ULONG BytesInUnicodeString{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &BytesInUnicodeString, sizeof(BytesInUnicodeString));


    NTSTATUS RtlUpcaseUnicodeToCustomCPNResult = RtlUpcaseUnicodeToCustomCPN((PCPTABLEINFO)&stCustomCP,(PCH)rlaCustomCPString.data(),(ULONG)MaxBytesInCustomCPString,(PULONG)&rlBytesInCustomCPString,(PWCH)rlwUnicodeString.data(),(ULONG)BytesInUnicodeString);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpcaseUnicodeToCustomCPNResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CustomCP);

    if(CustomCP != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CustomCP, &stCustomCP, sizeof(stCustomCP));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)CustomCPString, rlaCustomCPString)) { printf("Error when read CustomCPString in RtlUpcaseUnicodeToCustomCPN"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxBytesInCustomCPString);
    uc_reg_write(uc, UC_X86_REG_R9, &BytesInCustomCPString);

    if(BytesInCustomCPString != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BytesInCustomCPString, &rlBytesInCustomCPString, sizeof(rlBytesInCustomCPString));
    }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)UnicodeString, rlwUnicodeString)) { printf("Error when read UnicodeString in RtlUpcaseUnicodeToCustomCPN"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BytesInUnicodeString, sizeof(BytesInUnicodeString));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpcaseUnicodeToCustomCPN\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitCodePageTable(
      PUSHORT       TableBase      ,
      PCPTABLEINFO  CodePageTable  );

*/
void EmuApi::EmuRtlInitCodePageTable(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUSHORT TableBase{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TableBase);

    USHORT rlTableBase{};

    if(TableBase != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TableBase, &rlTableBase, sizeof(rlTableBase));
    }

    PCPTABLEINFO CodePageTable{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CodePageTable);

    CPTABLEINFO stCodePageTable{};

    if(CodePageTable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CodePageTable, &stCodePageTable, sizeof(stCodePageTable));
    }


    RtlInitCodePageTable((PUSHORT)&rlTableBase,(PCPTABLEINFO)&stCodePageTable);


    uc_reg_write(uc, UC_X86_REG_RCX, &TableBase);

    if(TableBase != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TableBase, &rlTableBase, sizeof(rlTableBase));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &CodePageTable);

    if(CodePageTable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CodePageTable, &stCodePageTable, sizeof(stCodePageTable));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitCodePageTable\n";
    #endif

    return;
}


/*
void
__cdecl
RtlInitNlsTables(
      PUSHORT        AnsiNlsBase      ,
      PUSHORT        OemNlsBase       ,
      PUSHORT        LanguageNlsBase  ,
      PNLSTABLEINFO  TableInfo        );

*/
void EmuApi::EmuRtlInitNlsTables(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUSHORT AnsiNlsBase{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AnsiNlsBase);

    USHORT rlAnsiNlsBase{};

    if(AnsiNlsBase != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AnsiNlsBase, &rlAnsiNlsBase, sizeof(rlAnsiNlsBase));
    }

    PUSHORT OemNlsBase{};
    uc_reg_read(uc, UC_X86_REG_RDX, &OemNlsBase);

    USHORT rlOemNlsBase{};

    if(OemNlsBase != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OemNlsBase, &rlOemNlsBase, sizeof(rlOemNlsBase));
    }

    PUSHORT LanguageNlsBase{};
    uc_reg_read(uc, UC_X86_REG_R8, &LanguageNlsBase);

    USHORT rlLanguageNlsBase{};

    if(LanguageNlsBase != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LanguageNlsBase, &rlLanguageNlsBase, sizeof(rlLanguageNlsBase));
    }

    PNLSTABLEINFO TableInfo{};
    uc_reg_read(uc, UC_X86_REG_R9, &TableInfo);

    NLSTABLEINFO stTableInfo{};

    if(TableInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TableInfo, &stTableInfo, sizeof(stTableInfo));
    }


    RtlInitNlsTables((PUSHORT)&rlAnsiNlsBase,(PUSHORT)&rlOemNlsBase,(PUSHORT)&rlLanguageNlsBase,(PNLSTABLEINFO)&stTableInfo);


    uc_reg_write(uc, UC_X86_REG_RCX, &AnsiNlsBase);

    if(AnsiNlsBase != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AnsiNlsBase, &rlAnsiNlsBase, sizeof(rlAnsiNlsBase));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &OemNlsBase);

    if(OemNlsBase != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OemNlsBase, &rlOemNlsBase, sizeof(rlOemNlsBase));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &LanguageNlsBase);

    if(LanguageNlsBase != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LanguageNlsBase, &rlLanguageNlsBase, sizeof(rlLanguageNlsBase));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &TableInfo);

    if(TableInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TableInfo, &stTableInfo, sizeof(stTableInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitNlsTables\n";
    #endif

    return;
}


/*
void
__cdecl
RtlResetRtlTranslations(
      PNLSTABLEINFO  TableInfo  );

*/
void EmuApi::EmuRtlResetRtlTranslations(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PNLSTABLEINFO TableInfo{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TableInfo);

    NLSTABLEINFO stTableInfo{};

    if(TableInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TableInfo, &stTableInfo, sizeof(stTableInfo));
    }


    RtlResetRtlTranslations((PNLSTABLEINFO)&stTableInfo);


    uc_reg_write(uc, UC_X86_REG_RCX, &TableInfo);

    if(TableInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TableInfo, &stTableInfo, sizeof(stTableInfo));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlResetRtlTranslations\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetVersion(
    OUT  PRTL_OSVERSIONINFOW  lpVersionInformation  );

*/
void EmuApi::EmuRtlGetVersion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_OSVERSIONINFOEXW lpVersionInformation{};
    uc_reg_read(uc, UC_X86_REG_RCX, &lpVersionInformation);

    OSVERSIONINFOEXW stlpVersionInformation{};

    if(lpVersionInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)lpVersionInformation, &stlpVersionInformation, sizeof(stlpVersionInformation));
    }


    NTSTATUS RtlGetVersionResult = RtlGetVersion((PRTL_OSVERSIONINFOEXW)&stlpVersionInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetVersionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &lpVersionInformation);

    if(lpVersionInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)lpVersionInformation, &stlpVersionInformation, sizeof(stlpVersionInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetVersion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlVerifyVersionInfo(
    IN  PRTL_OSVERSIONINFOEXW  VersionInfo    ,
    IN  ULONG                  TypeMask       ,
    IN  ULONGLONG              ConditionMask  );

*/
void EmuApi::EmuRtlVerifyVersionInfo(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_OSVERSIONINFOEXW VersionInfo{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VersionInfo);

    OSVERSIONINFOEXW stVersionInfo{};

    if(VersionInfo != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VersionInfo, &stVersionInfo, sizeof(stVersionInfo));
    }

    ULONG TypeMask{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TypeMask);

    ULONGLONG ConditionMask{};
    uc_reg_read(uc, UC_X86_REG_R8, &ConditionMask);


    NTSTATUS RtlVerifyVersionInfoResult = RtlVerifyVersionInfo((PRTL_OSVERSIONINFOEXW)&stVersionInfo,(ULONG)TypeMask,(ULONGLONG)ConditionMask);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlVerifyVersionInfoResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &VersionInfo);

    if(VersionInfo != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VersionInfo, &stVersionInfo, sizeof(stVersionInfo));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &TypeMask);
    uc_reg_write(uc, UC_X86_REG_R8, &ConditionMask);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlVerifyVersionInfo\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlFlushSecureMemoryCache(
      PVOID   lpAddr     ,
      SIZE_T  Func_size  );

*/
void EmuApi::EmuRtlFlushSecureMemoryCache(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID lpAddr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &lpAddr);

    SIZE_T Func_size{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Func_size);


    BOOLEAN RtlFlushSecureMemoryCacheResult = RtlFlushSecureMemoryCache((PVOID)&lpAddr,(SIZE_T)Func_size);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlFlushSecureMemoryCacheResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &lpAddr);
    uc_reg_write(uc, UC_X86_REG_RDX, &Func_size);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlFlushSecureMemoryCache\n";
    #endif

    return;
}


/*
LONG
__cdecl
RtlGetLastWin32Error(VOID);

*/
void EmuApi::EmuRtlGetLastWin32Error(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    LONG RtlGetLastWin32ErrorResult = RtlGetLastWin32Error();


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetLastWin32ErrorResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetLastWin32Error\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
      NTSTATUS  Status  );

*/
void EmuApi::EmuRtlSetLastWin32ErrorAndNtStatusFromNtStatus(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS Status{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Status);


    RtlSetLastWin32ErrorAndNtStatusFromNtStatus((NTSTATUS)Status);


    uc_reg_write(uc, UC_X86_REG_ECX, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetLastWin32ErrorAndNtStatusFromNtStatus\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetLastWin32Error(
      LONG  Win32Error  );

*/
void EmuApi::EmuRtlSetLastWin32Error(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LONG Win32Error{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Win32Error);


    RtlSetLastWin32Error((LONG)Win32Error);


    uc_reg_write(uc, UC_X86_REG_ECX, &Win32Error);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetLastWin32Error\n";
    #endif

    return;
}


/*
void
__cdecl
RtlRestoreLastWin32Error(
      LONG  Win32Error  );

*/
void EmuApi::EmuRtlRestoreLastWin32Error(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LONG Win32Error{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Win32Error);


    RtlRestoreLastWin32Error((LONG)Win32Error);


    uc_reg_write(uc, UC_X86_REG_ECX, &Win32Error);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRestoreLastWin32Error\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlGetSetBootStatusData(
    IN   HANDLE             Handle            ,
    IN   BOOLEAN            Get               ,
    IN   RTL_BSD_ITEM_TYPE  DataItem          ,
    IN   PVOID              DataBuffer        ,
    IN   ULONG              DataBufferLength  ,
    OUT  PULONG             ByteRead          );

*/
void EmuApi::EmuRtlGetSetBootStatusData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    BOOLEAN Get{};
    uc_reg_read(uc, UC_X86_REG_DL, &Get);

    RTL_BSD_ITEM_TYPE DataItem{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DataItem);

    PVOID DataBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &DataBuffer);

    ULONG DataBufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &DataBufferLength, sizeof(DataBufferLength));

    PULONG ByteRead{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ByteRead, sizeof(ByteRead));

    ULONG rlByteRead{};

    if(ByteRead != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteRead, &rlByteRead, sizeof(rlByteRead));
    }


    NTSTATUS RtlGetSetBootStatusDataResult = RtlGetSetBootStatusData((HANDLE)Handle,(BOOLEAN)Get,(RTL_BSD_ITEM_TYPE)DataItem,(PVOID)&DataBuffer,(ULONG)DataBufferLength,(PULONG)&rlByteRead);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetSetBootStatusDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_DL, &Get);
    uc_reg_write(uc, UC_X86_REG_R8D, &DataItem);
    uc_reg_write(uc, UC_X86_REG_R9, &DataBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &DataBufferLength, sizeof(DataBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ByteRead, sizeof(ByteRead));

    if(ByteRead != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteRead, &rlByteRead, sizeof(rlByteRead));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetSetBootStatusData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLockBootStatusData(
    OUT  PHANDLE  BootStatusDataHandle  );

*/
void EmuApi::EmuRtlLockBootStatusData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE BootStatusDataHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootStatusDataHandle);

    HANDLE dpBootStatusDataHandle{};

    if(BootStatusDataHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootStatusDataHandle, &dpBootStatusDataHandle, sizeof(dpBootStatusDataHandle));
    }


    NTSTATUS RtlLockBootStatusDataResult = RtlLockBootStatusData((PHANDLE)dpBootStatusDataHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLockBootStatusDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootStatusDataHandle);

    if(BootStatusDataHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootStatusDataHandle, &dpBootStatusDataHandle, sizeof(dpBootStatusDataHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLockBootStatusData\n";
    #endif

    return;
}


/*
void
__cdecl
RtlUnlockBootStatusData(
      HANDLE  BootStatusDataHandle  );

*/
void EmuApi::EmuRtlUnlockBootStatusData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE BootStatusDataHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootStatusDataHandle);


    RtlUnlockBootStatusData((HANDLE)BootStatusDataHandle);


    uc_reg_write(uc, UC_X86_REG_RCX, &BootStatusDataHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUnlockBootStatusData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateBootStatusDataFile(VOID);

*/
void EmuApi::EmuRtlCreateBootStatusDataFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS RtlCreateBootStatusDataFileResult = RtlCreateBootStatusDataFile();


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateBootStatusDataFileResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateBootStatusDataFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDelayExecution(
    IN  BOOLEAN         Alertable      ,
    IN  PLARGE_INTEGER  DelayInterval  );

*/
void EmuApi::EmuNtDelayExecution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_CL, &Alertable);

    PLARGE_INTEGER DelayInterval{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DelayInterval);

    LARGE_INTEGER rlDelayInterval{};

    if(DelayInterval != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DelayInterval, &rlDelayInterval, sizeof(rlDelayInterval));
    }


    NTSTATUS NtDelayExecutionResult = NtDelayExecution((BOOLEAN)Alertable,(PLARGE_INTEGER)&rlDelayInterval);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDelayExecutionResult);
    uc_reg_write(uc, UC_X86_REG_CL, &Alertable);
    uc_reg_write(uc, UC_X86_REG_RDX, &DelayInterval);

    if(DelayInterval != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DelayInterval, &rlDelayInterval, sizeof(rlDelayInterval));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDelayExecution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySystemEnvironmentValue(
    IN           PUNICODE_STRING  VariableName   ,
    OUT          PWSTR            VariableValue  ,
    IN           USHORT           ValueLength    ,
    OUTOPTIONAL  PUSHORT          ReturnLength   );

*/
void EmuApi::EmuNtQuerySystemEnvironmentValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in NtQuerySystemEnvironmentValue"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    PWSTR VariableValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VariableValue);

    std::wstring rlwVariableValue;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableValue, rlwVariableValue)) { printf("Error when read VariableValue in NtQuerySystemEnvironmentValue"); _CrtDbgBreak(); }

    USHORT ValueLength{};
    uc_reg_read(uc, UC_X86_REG_R8W, &ValueLength);

    PUSHORT ReturnLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReturnLength);

    USHORT rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQuerySystemEnvironmentValueResult = NtQuerySystemEnvironmentValue((PUNICODE_STRING)&stVariableName,(PWSTR)rlwVariableValue.data(),(USHORT)ValueLength,(PUSHORT)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySystemEnvironmentValueResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in NtQuerySystemEnvironmentValue"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableValue, rlwVariableValue)) { printf("Error when read VariableValue in NtQuerySystemEnvironmentValue"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8W, &ValueLength);
    uc_reg_write(uc, UC_X86_REG_R9, &ReturnLength);

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySystemEnvironmentValue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetSystemEnvironmentValue(
    IN  PUNICODE_STRING  VariableName   ,
    IN  PUNICODE_STRING  VariableValue  );

*/
void EmuApi::EmuNtSetSystemEnvironmentValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in NtSetSystemEnvironmentValue"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    PUNICODE_STRING VariableValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VariableValue);

    std::wstring rlwVariableValue;

    USHORT rlLengthVariableValue;

    USHORT rlMaxLengthVariableValue;
    uc_mem_read(uc, (DWORD_PTR)VariableValue, &rlLengthVariableValue, sizeof(rlLengthVariableValue));
    uc_mem_read(uc, (DWORD_PTR)VariableValue+16, &rlMaxLengthVariableValue, sizeof(rlMaxLengthVariableValue));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableValue+64, rlwVariableValue, true, rlLengthVariableValue)) { printf("Error when read VariableValue in NtSetSystemEnvironmentValue"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableValue{};
    stVariableValue.Length = rlLengthVariableValue;
    stVariableValue.MaximumLength = rlMaxLengthVariableValue;
    stVariableValue.Buffer = rlwVariableValue.data();


    NTSTATUS NtSetSystemEnvironmentValueResult = NtSetSystemEnvironmentValue((PUNICODE_STRING)&stVariableName,(PUNICODE_STRING)&stVariableValue);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetSystemEnvironmentValueResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in NtSetSystemEnvironmentValue"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)VariableValue, &stVariableValue.Length, sizeof(stVariableValue.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableValue+16, &stVariableValue.MaximumLength, sizeof(stVariableValue.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableValue+64, stVariableValue.Buffer, true, stVariableValue.Length)) { printf("Error when read VariableValue in NtSetSystemEnvironmentValue"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetSystemEnvironmentValue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySystemEnvironmentValueEx(
    IN           PUNICODE_STRING  VariableName  ,
    IN           LPGUID           VendorGuid    ,
    OUTOPTIONAL  PVOID            Value         ,
    INOUT        PULONG           ValueLength   ,
    OUTOPTIONAL  PULONG           Attributes    );

*/
void EmuApi::EmuNtQuerySystemEnvironmentValueEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in NtQuerySystemEnvironmentValueEx"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    LPGUID VendorGuid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VendorGuid);

    GUID rlVendorGuid{};

    if(VendorGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }

    PVOID Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    PULONG ValueLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ValueLength);

    ULONG rlValueLength{};

    if(ValueLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ValueLength, &rlValueLength, sizeof(rlValueLength));
    }

    PULONG Attributes{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));

    ULONG rlAttributes{};

    if(Attributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Attributes, &rlAttributes, sizeof(rlAttributes));
    }


    NTSTATUS NtQuerySystemEnvironmentValueExResult = NtQuerySystemEnvironmentValueEx((PUNICODE_STRING)&stVariableName,(LPGUID)&rlVendorGuid,(PVOID)&Value,(PULONG)&rlValueLength,(PULONG)&rlAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySystemEnvironmentValueExResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in NtQuerySystemEnvironmentValueEx"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &VendorGuid);

    if(VendorGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Value);
    uc_reg_write(uc, UC_X86_REG_R9, &ValueLength);

    if(ValueLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ValueLength, &rlValueLength, sizeof(rlValueLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));

    if(Attributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Attributes, &rlAttributes, sizeof(rlAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySystemEnvironmentValueEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetSystemEnvironmentValueEx(
    IN          PUNICODE_STRING  VariableName  ,
    IN          LPGUID           VendorGuid    ,
    INOPTIONAL  PVOID            Value         ,
    IN          ULONG            ValueLength   ,
    IN          ULONG            Attributes    );

*/
void EmuApi::EmuNtSetSystemEnvironmentValueEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in NtSetSystemEnvironmentValueEx"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    LPGUID VendorGuid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VendorGuid);

    GUID rlVendorGuid{};

    if(VendorGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }

    PVOID Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    ULONG ValueLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ValueLength);

    ULONG Attributes{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));


    NTSTATUS NtSetSystemEnvironmentValueExResult = NtSetSystemEnvironmentValueEx((PUNICODE_STRING)&stVariableName,(LPGUID)&rlVendorGuid,(PVOID)&Value,(ULONG)ValueLength,(ULONG)Attributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetSystemEnvironmentValueExResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in NtSetSystemEnvironmentValueEx"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &VendorGuid);

    if(VendorGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Value);
    uc_reg_write(uc, UC_X86_REG_R9D, &ValueLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetSystemEnvironmentValueEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtEnumerateSystemEnvironmentValuesEx(
    IN     ULONG   InformationClass  ,
    OUT    PVOID   Buffer            ,
    INOUT  PULONG  BufferLength      );

*/
void EmuApi::EmuNtEnumerateSystemEnvironmentValuesEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG InformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &InformationClass);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS NtEnumerateSystemEnvironmentValuesExResult = NtEnumerateSystemEnvironmentValuesEx((ULONG)InformationClass,(PVOID)&Buffer,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtEnumerateSystemEnvironmentValuesExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtEnumerateSystemEnvironmentValuesEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAddBootEntry(
    IN           PBOOT_ENTRY  BootEntry  ,
    OUTOPTIONAL  PULONG       Id         );

*/
void EmuApi::EmuNtAddBootEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_ENTRY BootEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootEntry);

    BOOT_ENTRY stBootEntry{};

    if(BootEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }

    PULONG Id{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Id);

    ULONG rlId{};

    if(Id != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }


    NTSTATUS NtAddBootEntryResult = NtAddBootEntry((PBOOT_ENTRY)&stBootEntry,(PULONG)&rlId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAddBootEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootEntry);

    if(BootEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Id);

    if(Id != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAddBootEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteBootEntry(
    IN  ULONG  Id  );

*/
void EmuApi::EmuNtDeleteBootEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Id{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Id);


    NTSTATUS NtDeleteBootEntryResult = NtDeleteBootEntry((ULONG)Id);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteBootEntryResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Id);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteBootEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtModifyBootEntry(
    IN  PBOOT_ENTRY  BootEntry  );

*/
void EmuApi::EmuNtModifyBootEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_ENTRY BootEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootEntry);

    BOOT_ENTRY stBootEntry{};

    if(BootEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }


    NTSTATUS NtModifyBootEntryResult = NtModifyBootEntry((PBOOT_ENTRY)&stBootEntry);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtModifyBootEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootEntry);

    if(BootEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtModifyBootEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtEnumerateBootEntries(
    OUTOPTIONAL  PVOID   Buffer        ,
    INOUT        PULONG  BufferLength  );

*/
void EmuApi::EmuNtEnumerateBootEntries(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS NtEnumerateBootEntriesResult = NtEnumerateBootEntries((PVOID)&Buffer,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtEnumerateBootEntriesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_RDX, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtEnumerateBootEntries\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryBootEntryOrder(
    OUTOPTIONAL  PULONG  Ids    ,
    INOUT        PULONG  Count  );

*/
void EmuApi::EmuNtQueryBootEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    PULONG Count{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Count);

    ULONG rlCount{};

    if(Count != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }


    NTSTATUS NtQueryBootEntryOrderResult = NtQueryBootEntryOrder((PULONG)&rlIds,(PULONG)&rlCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryBootEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Count);

    if(Count != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryBootEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetBootEntryOrder(
    IN  PULONG  Ids    ,
    IN  ULONG   Count  );

*/
void EmuApi::EmuNtSetBootEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);


    NTSTATUS NtSetBootEntryOrderResult = NtSetBootEntryOrder((PULONG)&rlIds,(ULONG)Count);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetBootEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetBootEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryBootOptions(
    OUTOPTIONAL  PBOOT_OPTIONS  BootOptions        ,
    INOUT        PULONG         BootOptionsLength  );

*/
void EmuApi::EmuNtQueryBootOptions(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_OPTIONS BootOptions{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootOptions);

    BOOT_OPTIONS stBootOptions{};

    if(BootOptions != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }

    PULONG BootOptionsLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BootOptionsLength);

    ULONG rlBootOptionsLength{};

    if(BootOptionsLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootOptionsLength, &rlBootOptionsLength, sizeof(rlBootOptionsLength));
    }


    NTSTATUS NtQueryBootOptionsResult = NtQueryBootOptions((PBOOT_OPTIONS)&stBootOptions,(PULONG)&rlBootOptionsLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryBootOptionsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootOptions);

    if(BootOptions != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &BootOptionsLength);

    if(BootOptionsLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootOptionsLength, &rlBootOptionsLength, sizeof(rlBootOptionsLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryBootOptions\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetBootOptions(
    IN  PBOOT_OPTIONS  BootOptions     ,
    IN  ULONG          FieldsToChange  );

*/
void EmuApi::EmuNtSetBootOptions(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_OPTIONS BootOptions{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootOptions);

    BOOT_OPTIONS stBootOptions{};

    if(BootOptions != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }

    ULONG FieldsToChange{};
    uc_reg_read(uc, UC_X86_REG_EDX, &FieldsToChange);


    NTSTATUS NtSetBootOptionsResult = NtSetBootOptions((PBOOT_OPTIONS)&stBootOptions,(ULONG)FieldsToChange);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetBootOptionsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootOptions);

    if(BootOptions != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &FieldsToChange);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetBootOptions\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtTranslateFilePath(
    IN             PFILE_PATH  InputFilePath         ,
    IN             ULONG       OutputType            ,
    OUTOPTIONAL    PFILE_PATH  OutputFilePath        ,
    INOUTOPTIONAL  PULONG      OutputFilePathLength  );

*/
void EmuApi::EmuNtTranslateFilePath(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PFILE_PATH InputFilePath{};
    uc_reg_read(uc, UC_X86_REG_RCX, &InputFilePath);

    FILE_PATH stInputFilePath{};

    if(InputFilePath != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InputFilePath, &stInputFilePath, sizeof(stInputFilePath));
    }

    ULONG OutputType{};
    uc_reg_read(uc, UC_X86_REG_EDX, &OutputType);

    PFILE_PATH OutputFilePath{};
    uc_reg_read(uc, UC_X86_REG_R8, &OutputFilePath);

    FILE_PATH stOutputFilePath{};

    if(OutputFilePath != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OutputFilePath, &stOutputFilePath, sizeof(stOutputFilePath));
    }

    PULONG OutputFilePathLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutputFilePathLength);

    ULONG rlOutputFilePathLength{};

    if(OutputFilePathLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OutputFilePathLength, &rlOutputFilePathLength, sizeof(rlOutputFilePathLength));
    }


    NTSTATUS NtTranslateFilePathResult = NtTranslateFilePath((PFILE_PATH)&stInputFilePath,(ULONG)OutputType,(PFILE_PATH)&stOutputFilePath,(PULONG)&rlOutputFilePathLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtTranslateFilePathResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &InputFilePath);

    if(InputFilePath != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InputFilePath, &stInputFilePath, sizeof(stInputFilePath));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &OutputType);
    uc_reg_write(uc, UC_X86_REG_R8, &OutputFilePath);

    if(OutputFilePath != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OutputFilePath, &stOutputFilePath, sizeof(stOutputFilePath));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &OutputFilePathLength);

    if(OutputFilePathLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OutputFilePathLength, &rlOutputFilePathLength, sizeof(rlOutputFilePathLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtTranslateFilePath\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAddDriverEntry(
    IN           PEFI_DRIVER_ENTRY  DriverEntry  ,
    OUTOPTIONAL  PULONG             Id           );

*/
void EmuApi::EmuNtAddDriverEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEFI_DRIVER_ENTRY DriverEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverEntry);

    EFI_DRIVER_ENTRY stDriverEntry{};

    if(DriverEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }

    PULONG Id{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Id);

    ULONG rlId{};

    if(Id != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }


    NTSTATUS NtAddDriverEntryResult = NtAddDriverEntry((PEFI_DRIVER_ENTRY)&stDriverEntry,(PULONG)&rlId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAddDriverEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DriverEntry);

    if(DriverEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Id);

    if(Id != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAddDriverEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteDriverEntry(
    IN  ULONG  Id  );

*/
void EmuApi::EmuNtDeleteDriverEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Id{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Id);


    NTSTATUS NtDeleteDriverEntryResult = NtDeleteDriverEntry((ULONG)Id);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteDriverEntryResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Id);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteDriverEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtModifyDriverEntry(
    IN  PEFI_DRIVER_ENTRY  DriverEntry  );

*/
void EmuApi::EmuNtModifyDriverEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEFI_DRIVER_ENTRY DriverEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverEntry);

    EFI_DRIVER_ENTRY stDriverEntry{};

    if(DriverEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }


    NTSTATUS NtModifyDriverEntryResult = NtModifyDriverEntry((PEFI_DRIVER_ENTRY)&stDriverEntry);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtModifyDriverEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DriverEntry);

    if(DriverEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtModifyDriverEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtEnumerateDriverEntries(
    OUT    PVOID   Buffer        ,
    INOUT  PULONG  BufferLength  );

*/
void EmuApi::EmuNtEnumerateDriverEntries(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS NtEnumerateDriverEntriesResult = NtEnumerateDriverEntries((PVOID)&Buffer,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtEnumerateDriverEntriesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_RDX, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtEnumerateDriverEntries\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryDriverEntryOrder(
    OUT    PULONG  Ids    ,
    INOUT  PULONG  Count  );

*/
void EmuApi::EmuNtQueryDriverEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    PULONG Count{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Count);

    ULONG rlCount{};

    if(Count != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }


    NTSTATUS NtQueryDriverEntryOrderResult = NtQueryDriverEntryOrder((PULONG)&rlIds,(PULONG)&rlCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryDriverEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Count);

    if(Count != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryDriverEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetDriverEntryOrder(
    IN  PULONG  Ids    ,
    IN  ULONG   Count  );

*/
void EmuApi::EmuNtSetDriverEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);


    NTSTATUS NtSetDriverEntryOrderResult = NtSetDriverEntryOrder((PULONG)&rlIds,(ULONG)Count);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetDriverEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetDriverEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtClearEvent(
    IN  HANDLE  EventHandle  );

*/
void EmuApi::EmuNtClearEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);


    NTSTATUS NtClearEventResult = NtClearEvent((HANDLE)EventHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtClearEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtClearEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateEvent(
    OUT         PHANDLE             EventHandle       ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          EVENT_TYPE          EventType         ,
    IN          BOOLEAN             InitialState      );

*/
void EmuApi::EmuNtCreateEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    HANDLE dpEventHandle{};

    if(EventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    EVENT_TYPE EventType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &EventType);

    BOOLEAN InitialState{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &InitialState, sizeof(InitialState));


    NTSTATUS NtCreateEventResult = NtCreateEvent((PHANDLE)dpEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(EVENT_TYPE)EventType,(BOOLEAN)InitialState);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);

    if(EventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &EventType);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &InitialState, sizeof(InitialState));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenEvent(
    OUT  PHANDLE             EventHandle       ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    HANDLE dpEventHandle{};

    if(EventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenEventResult = NtOpenEvent((PHANDLE)dpEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);

    if(EventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtPulseEvent(
    IN           HANDLE  EventHandle    ,
    OUTOPTIONAL  PLONG   PreviousState  );

*/
void EmuApi::EmuNtPulseEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PLONG PreviousState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousState);

    LONG rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS NtPulseEventResult = NtPulseEvent((HANDLE)EventHandle,(PLONG)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtPulseEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousState);

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtPulseEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryEvent(
    IN           HANDLE                   EventHandle             ,
    IN           EVENT_INFORMATION_CLASS  EventInformationClass   ,
    OUT          PVOID                    EventInformation        ,
    IN           ULONG                    EventInformationLength  ,
    OUTOPTIONAL  PULONG                   ReturnLength            );

*/
void EmuApi::EmuNtQueryEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    EVENT_INFORMATION_CLASS EventInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &EventInformationClass);

    PVOID EventInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &EventInformation);

    ULONG EventInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &EventInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryEventResult = NtQueryEvent((HANDLE)EventHandle,(EVENT_INFORMATION_CLASS)EventInformationClass,(PVOID)&EventInformation,(ULONG)EventInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &EventInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &EventInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &EventInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtResetEvent(
    IN           HANDLE  EventHandle    ,
    OUTOPTIONAL  PLONG   PreviousState  );

*/
void EmuApi::EmuNtResetEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PLONG PreviousState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousState);

    LONG rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS NtResetEventResult = NtResetEvent((HANDLE)EventHandle,(PLONG)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtResetEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousState);

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtResetEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetEvent(
    IN           HANDLE  EventHandle    ,
    OUTOPTIONAL  PLONG   PreviousState  );

*/
void EmuApi::EmuNtSetEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PLONG PreviousState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousState);

    LONG rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS NtSetEventResult = NtSetEvent((HANDLE)EventHandle,(PLONG)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousState);

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetEventBoostPriority(
    IN  HANDLE  EventHandle  );

*/
void EmuApi::EmuNtSetEventBoostPriority(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);


    NTSTATUS NtSetEventBoostPriorityResult = NtSetEventBoostPriority((HANDLE)EventHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetEventBoostPriorityResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetEventBoostPriority\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateEventPair(
    OUT         PHANDLE             EventPairHandle   ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtCreateEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);

    HANDLE dpEventPairHandle{};

    if(EventPairHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtCreateEventPairResult = NtCreateEventPair((PHANDLE)dpEventPairHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);

    if(EventPairHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenEventPair(
    OUT  PHANDLE             EventPairHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);

    HANDLE dpEventPairHandle{};

    if(EventPairHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenEventPairResult = NtOpenEventPair((PHANDLE)dpEventPairHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);

    if(EventPairHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWaitLowEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuNtWaitLowEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS NtWaitLowEventPairResult = NtWaitLowEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWaitLowEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWaitLowEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWaitHighEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuNtWaitHighEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS NtWaitHighEventPairResult = NtWaitHighEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWaitHighEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWaitHighEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetLowWaitHighEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuNtSetLowWaitHighEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS NtSetLowWaitHighEventPairResult = NtSetLowWaitHighEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetLowWaitHighEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetLowWaitHighEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetHighWaitLowEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuNtSetHighWaitLowEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS NtSetHighWaitLowEventPairResult = NtSetHighWaitLowEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetHighWaitLowEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetHighWaitLowEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetLowEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuNtSetLowEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS NtSetLowEventPairResult = NtSetLowEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetLowEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetLowEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetHighEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuNtSetHighEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS NtSetHighEventPairResult = NtSetHighEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetHighEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetHighEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateMutant(
    OUT         PHANDLE             MutantHandle      ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          BOOLEAN             InitialOwner      );

*/
void EmuApi::EmuNtCreateMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    HANDLE dpMutantHandle{};

    if(MutantHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    BOOLEAN InitialOwner{};
    uc_reg_read(uc, UC_X86_REG_R9B, &InitialOwner);


    NTSTATUS NtCreateMutantResult = NtCreateMutant((PHANDLE)dpMutantHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(BOOLEAN)InitialOwner);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);

    if(MutantHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &InitialOwner);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenMutant(
    OUT  PHANDLE             MutantHandle      ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    HANDLE dpMutantHandle{};

    if(MutantHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenMutantResult = NtOpenMutant((PHANDLE)dpMutantHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);

    if(MutantHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryMutant(
    IN           HANDLE                    MutantHandle             ,
    IN           MUTANT_INFORMATION_CLASS  MutantInformationClass   ,
    OUT          PVOID                     MutantInformation        ,
    IN           ULONG                     MutantInformationLength  ,
    OUTOPTIONAL  PULONG                    ReturnLength             );

*/
void EmuApi::EmuNtQueryMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    MUTANT_INFORMATION_CLASS MutantInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MutantInformationClass);

    PVOID MutantInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &MutantInformation);

    ULONG MutantInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MutantInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryMutantResult = NtQueryMutant((HANDLE)MutantHandle,(MUTANT_INFORMATION_CLASS)MutantInformationClass,(PVOID)&MutantInformation,(ULONG)MutantInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &MutantInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &MutantInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &MutantInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReleaseMutant(
    IN           HANDLE  MutantHandle   ,
    OUTOPTIONAL  PLONG   PreviousCount  );

*/
void EmuApi::EmuNtReleaseMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    PLONG PreviousCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousCount);

    LONG rlPreviousCount{};

    if(PreviousCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }


    NTSTATUS NtReleaseMutantResult = NtReleaseMutant((HANDLE)MutantHandle,(PLONG)&rlPreviousCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReleaseMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousCount);

    if(PreviousCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReleaseMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateSemaphore(
    OUT         PHANDLE             SemaphoreHandle   ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          LONG                InitialCount      ,
    IN          LONG                MaximumCount      );

*/
void EmuApi::EmuNtCreateSemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    HANDLE dpSemaphoreHandle{};

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    LONG InitialCount{};
    uc_reg_read(uc, UC_X86_REG_R9D, &InitialCount);

    LONG MaximumCount{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaximumCount, sizeof(MaximumCount));


    NTSTATUS NtCreateSemaphoreResult = NtCreateSemaphore((PHANDLE)dpSemaphoreHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(LONG)InitialCount,(LONG)MaximumCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateSemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &InitialCount);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaximumCount, sizeof(MaximumCount));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateSemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenSemaphore(
    OUT  PHANDLE             SemaphoreHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenSemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    HANDLE dpSemaphoreHandle{};

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenSemaphoreResult = NtOpenSemaphore((PHANDLE)dpSemaphoreHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenSemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenSemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySemaphore(
    IN           HANDLE                       SemaphoreHandle             ,
    IN           SEMAPHORE_INFORMATION_CLASS  SemaphoreInformationClass   ,
    OUT          PVOID                        SemaphoreInformation        ,
    IN           ULONG                        SemaphoreInformationLength  ,
    OUTOPTIONAL  PULONG                       ReturnLength                );

*/
void EmuApi::EmuNtQuerySemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SemaphoreInformationClass);

    PVOID SemaphoreInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &SemaphoreInformation);

    ULONG SemaphoreInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &SemaphoreInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQuerySemaphoreResult = NtQuerySemaphore((HANDLE)SemaphoreHandle,(SEMAPHORE_INFORMATION_CLASS)SemaphoreInformationClass,(PVOID)&SemaphoreInformation,(ULONG)SemaphoreInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SemaphoreInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &SemaphoreInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &SemaphoreInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReleaseSemaphore(
    IN           HANDLE  SemaphoreHandle  ,
    IN           LONG    ReleaseCount     ,
    OUTOPTIONAL  PLONG   PreviousCount    );

*/
void EmuApi::EmuNtReleaseSemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    LONG ReleaseCount{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ReleaseCount);

    PLONG PreviousCount{};
    uc_reg_read(uc, UC_X86_REG_R8, &PreviousCount);

    LONG rlPreviousCount{};

    if(PreviousCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }


    NTSTATUS NtReleaseSemaphoreResult = NtReleaseSemaphore((HANDLE)SemaphoreHandle,(LONG)ReleaseCount,(PLONG)&rlPreviousCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReleaseSemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ReleaseCount);
    uc_reg_write(uc, UC_X86_REG_R8, &PreviousCount);

    if(PreviousCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReleaseSemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateTimer(
    OUT         PHANDLE             TimerHandle       ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          TIMER_TYPE          TimerType         );

*/
void EmuApi::EmuNtCreateTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    HANDLE dpTimerHandle{};

    if(TimerHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    TIMER_TYPE TimerType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TimerType);


    NTSTATUS NtCreateTimerResult = NtCreateTimer((PHANDLE)dpTimerHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(TIMER_TYPE)TimerType);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);

    if(TimerHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &TimerType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenTimer(
    OUT  PHANDLE             TimerHandle       ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    HANDLE dpTimerHandle{};

    if(TimerHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenTimerResult = NtOpenTimer((PHANDLE)dpTimerHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);

    if(TimerHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCancelTimer(
    IN           HANDLE    TimerHandle   ,
    OUTOPTIONAL  PBOOLEAN  CurrentState  );

*/
void EmuApi::EmuNtCancelTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    PBOOLEAN CurrentState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CurrentState);

    BOOLEAN rlCurrentState{};

    if(CurrentState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CurrentState, &rlCurrentState, sizeof(rlCurrentState));
    }


    NTSTATUS NtCancelTimerResult = NtCancelTimer((HANDLE)TimerHandle,(PBOOLEAN)&rlCurrentState);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCancelTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &CurrentState);

    if(CurrentState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CurrentState, &rlCurrentState, sizeof(rlCurrentState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCancelTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryTimer(
    IN           HANDLE                   TimerHandle             ,
    IN           TIMER_INFORMATION_CLASS  TimerInformationClass   ,
    OUT          PVOID                    TimerInformation        ,
    IN           ULONG                    TimerInformationLength  ,
    OUTOPTIONAL  PULONG                   ReturnLength            );

*/
void EmuApi::EmuNtQueryTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    TIMER_INFORMATION_CLASS TimerInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TimerInformationClass);

    PVOID TimerInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &TimerInformation);

    ULONG TimerInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TimerInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryTimerResult = NtQueryTimer((HANDLE)TimerHandle,(TIMER_INFORMATION_CLASS)TimerInformationClass,(PVOID)&TimerInformation,(ULONG)TimerInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &TimerInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &TimerInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &TimerInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetTimer(
    IN           HANDLE              TimerHandle      ,
    IN           PLARGE_INTEGER      DueTime          ,
    INOPTIONAL   PTIMER_APC_ROUTINE  TimerApcRoutine  ,
    INOPTIONAL   PVOID               TimerContext     ,
    IN           BOOLEAN             ResumeTimer      ,
    INOPTIONAL   LONG                Period           ,
    OUTOPTIONAL  PBOOLEAN            PreviousState    );

*/
void EmuApi::EmuNtSetTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    PLARGE_INTEGER DueTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DueTime);

    LARGE_INTEGER rlDueTime{};

    if(DueTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DueTime, &rlDueTime, sizeof(rlDueTime));
    }

    PTIMER_APC_ROUTINE TimerApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &TimerApcRoutine);

    PVOID TimerContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &TimerContext);

    BOOLEAN ResumeTimer{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ResumeTimer, sizeof(ResumeTimer));

    LONG Period{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Period, sizeof(Period));

    PBOOLEAN PreviousState{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &PreviousState, sizeof(PreviousState));

    BOOLEAN rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS NtSetTimerResult = NtSetTimer((HANDLE)TimerHandle,(PLARGE_INTEGER)&rlDueTime,(PTIMER_APC_ROUTINE)TimerApcRoutine,(PVOID)&TimerContext,(BOOLEAN)ResumeTimer,(LONG)Period,(PBOOLEAN)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &DueTime);

    if(DueTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DueTime, &rlDueTime, sizeof(rlDueTime));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &TimerApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &TimerContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ResumeTimer, sizeof(ResumeTimer));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Period, sizeof(Period));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &PreviousState, sizeof(PreviousState));

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySystemTime(
    OUT  PLARGE_INTEGER  SystemTime  );

*/
void EmuApi::EmuNtQuerySystemTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }


    NTSTATUS NtQuerySystemTimeResult = NtQuerySystemTime((PLARGE_INTEGER)&rlSystemTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySystemTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySystemTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetSystemTime(
    INOPTIONAL   PLARGE_INTEGER  SystemTime    ,
    OUTOPTIONAL  PLARGE_INTEGER  PreviousTime  );

*/
void EmuApi::EmuNtSetSystemTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }

    PLARGE_INTEGER PreviousTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousTime);

    LARGE_INTEGER rlPreviousTime{};

    if(PreviousTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousTime, &rlPreviousTime, sizeof(rlPreviousTime));
    }


    NTSTATUS NtSetSystemTimeResult = NtSetSystemTime((PLARGE_INTEGER)&rlSystemTime,(PLARGE_INTEGER)&rlPreviousTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetSystemTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousTime);

    if(PreviousTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousTime, &rlPreviousTime, sizeof(rlPreviousTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetSystemTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryTimerResolution(
    OUT  PULONG  MaximumTime  ,
    OUT  PULONG  MinimumTime  ,
    OUT  PULONG  CurrentTime  );

*/
void EmuApi::EmuNtQueryTimerResolution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG MaximumTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MaximumTime);

    ULONG rlMaximumTime{};

    if(MaximumTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaximumTime, &rlMaximumTime, sizeof(rlMaximumTime));
    }

    PULONG MinimumTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &MinimumTime);

    ULONG rlMinimumTime{};

    if(MinimumTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MinimumTime, &rlMinimumTime, sizeof(rlMinimumTime));
    }

    PULONG CurrentTime{};
    uc_reg_read(uc, UC_X86_REG_R8, &CurrentTime);

    ULONG rlCurrentTime{};

    if(CurrentTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CurrentTime, &rlCurrentTime, sizeof(rlCurrentTime));
    }


    NTSTATUS NtQueryTimerResolutionResult = NtQueryTimerResolution((PULONG)&rlMaximumTime,(PULONG)&rlMinimumTime,(PULONG)&rlCurrentTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryTimerResolutionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MaximumTime);

    if(MaximumTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaximumTime, &rlMaximumTime, sizeof(rlMaximumTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &MinimumTime);

    if(MinimumTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MinimumTime, &rlMinimumTime, sizeof(rlMinimumTime));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &CurrentTime);

    if(CurrentTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CurrentTime, &rlCurrentTime, sizeof(rlCurrentTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryTimerResolution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetTimerResolution(
    IN   ULONG    DesiredTime    ,
    IN   BOOLEAN  SetResolution  ,
    OUT  PULONG   ActualTime     );

*/
void EmuApi::EmuNtSetTimerResolution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG DesiredTime{};
    uc_reg_read(uc, UC_X86_REG_ECX, &DesiredTime);

    BOOLEAN SetResolution{};
    uc_reg_read(uc, UC_X86_REG_DL, &SetResolution);

    PULONG ActualTime{};
    uc_reg_read(uc, UC_X86_REG_R8, &ActualTime);

    ULONG rlActualTime{};

    if(ActualTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ActualTime, &rlActualTime, sizeof(rlActualTime));
    }


    NTSTATUS NtSetTimerResolutionResult = NtSetTimerResolution((ULONG)DesiredTime,(BOOLEAN)SetResolution,(PULONG)&rlActualTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetTimerResolutionResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &DesiredTime);
    uc_reg_write(uc, UC_X86_REG_DL, &SetResolution);
    uc_reg_write(uc, UC_X86_REG_R8, &ActualTime);

    if(ActualTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ActualTime, &rlActualTime, sizeof(rlActualTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetTimerResolution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAllocateLocallyUniqueId(
    OUT  PLUID  Luid  );

*/
void EmuApi::EmuNtAllocateLocallyUniqueId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLUID Luid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Luid);

    LUID stLuid{};

    if(Luid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Luid, &stLuid, sizeof(stLuid));
    }


    NTSTATUS NtAllocateLocallyUniqueIdResult = NtAllocateLocallyUniqueId((PLUID)&stLuid);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAllocateLocallyUniqueIdResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Luid);

    if(Luid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Luid, &stLuid, sizeof(stLuid));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAllocateLocallyUniqueId\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetUuidSeed(
    IN  PCHAR  Seed  );

*/
void EmuApi::EmuNtSetUuidSeed(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR Seed{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Seed);

    std::string rlaSeed;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in NtSetUuidSeed"); _CrtDbgBreak(); }


    NTSTATUS NtSetUuidSeedResult = NtSetUuidSeed((PCHAR)rlaSeed.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetUuidSeedResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in NtSetUuidSeed"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetUuidSeed\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAllocateUuids(
    OUT  PULARGE_INTEGER  Time      ,
    OUT  PULONG           Range     ,
    OUT  PULONG           Sequence  ,
    OUT  PCHAR            Seed      );

*/
void EmuApi::EmuNtAllocateUuids(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Time);

    ULARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }

    PULONG Range{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Range);

    ULONG rlRange{};

    if(Range != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Range, &rlRange, sizeof(rlRange));
    }

    PULONG Sequence{};
    uc_reg_read(uc, UC_X86_REG_R8, &Sequence);

    ULONG rlSequence{};

    if(Sequence != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sequence, &rlSequence, sizeof(rlSequence));
    }

    PCHAR Seed{};
    uc_reg_read(uc, UC_X86_REG_R9, &Seed);

    std::string rlaSeed;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in NtAllocateUuids"); _CrtDbgBreak(); }


    NTSTATUS NtAllocateUuidsResult = NtAllocateUuids((PULARGE_INTEGER)&rlTime,(PULONG)&rlRange,(PULONG)&rlSequence,(PCHAR)rlaSeed.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAllocateUuidsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Range);

    if(Range != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Range, &rlRange, sizeof(rlRange));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Sequence);

    if(Sequence != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sequence, &rlSequence, sizeof(rlSequence));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in NtAllocateUuids"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAllocateUuids\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateProfile(
    OUT  PHANDLE          ProfileHandle  ,
    IN   HANDLE           Process        ,
    ,IN  PVOID            ProfileBase    ,
    IN   SIZE_T           ProfileSize    ,
    IN   ULONG            BucketSize     ,
    IN   PULONG           Buffer         ,
    IN   ULONG            BufferSize     ,
    IN   KPROFILE_SOURCE  ProfileSource  ,
    IN   KAFFINITY        Affinity       );

*/
void EmuApi::EmuNtCreateProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProfileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProfileHandle);

    HANDLE dpProfileHandle{};

    if(ProfileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProfileHandle, &dpProfileHandle, sizeof(dpProfileHandle));
    }

    HANDLE Process{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Process);

    PVOID ProfileBase{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProfileBase);

    SIZE_T ProfileSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProfileSize);

    ULONG BucketSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BucketSize, sizeof(BucketSize));

    PULONG Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG rlBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &rlBuffer, sizeof(rlBuffer));
    }

    ULONG BufferSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &BufferSize, sizeof(BufferSize));

    KPROFILE_SOURCE ProfileSource{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ProfileSource, sizeof(ProfileSource));

    KAFFINITY Affinity{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Affinity, sizeof(Affinity));


    NTSTATUS NtCreateProfileResult = NtCreateProfile((PHANDLE)dpProfileHandle,(HANDLE)Process,(PVOID)&ProfileBase,(SIZE_T)ProfileSize,(ULONG)BucketSize,(PULONG)&rlBuffer,(ULONG)BufferSize,(KPROFILE_SOURCE)ProfileSource,(KAFFINITY)Affinity);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateProfileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProfileHandle);

    if(ProfileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProfileHandle, &dpProfileHandle, sizeof(dpProfileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Process);
    uc_reg_write(uc, UC_X86_REG_R8, &ProfileBase);
    uc_reg_write(uc, UC_X86_REG_R9, &ProfileSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BucketSize, sizeof(BucketSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &rlBuffer, sizeof(rlBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ProfileSource, sizeof(ProfileSource));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Affinity, sizeof(Affinity));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtStartProfile(
    IN  HANDLE  ProfileHandle  );

*/
void EmuApi::EmuNtStartProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProfileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProfileHandle);


    NTSTATUS NtStartProfileResult = NtStartProfile((HANDLE)ProfileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtStartProfileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProfileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtStartProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtStopProfile(
    IN  HANDLE  ProfileHandle  );

*/
void EmuApi::EmuNtStopProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProfileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProfileHandle);


    NTSTATUS NtStopProfileResult = NtStopProfile((HANDLE)ProfileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtStopProfileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProfileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtStopProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetIntervalProfile(
    IN  ULONG            Interval  ,
    IN  KPROFILE_SOURCE  Source    );

*/
void EmuApi::EmuNtSetIntervalProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Interval{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Interval);

    KPROFILE_SOURCE Source{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Source);


    NTSTATUS NtSetIntervalProfileResult = NtSetIntervalProfile((ULONG)Interval,(KPROFILE_SOURCE)Source);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetIntervalProfileResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Interval);
    uc_reg_write(uc, UC_X86_REG_EDX, &Source);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetIntervalProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryIntervalProfile(
    IN   KPROFILE_SOURCE  ProfileSource  ,
    OUT  PULONG           Interval       );

*/
void EmuApi::EmuNtQueryIntervalProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    KPROFILE_SOURCE ProfileSource{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ProfileSource);

    PULONG Interval{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Interval);

    ULONG rlInterval{};

    if(Interval != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Interval, &rlInterval, sizeof(rlInterval));
    }


    NTSTATUS NtQueryIntervalProfileResult = NtQueryIntervalProfile((KPROFILE_SOURCE)ProfileSource,(PULONG)&rlInterval);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryIntervalProfileResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ProfileSource);
    uc_reg_write(uc, UC_X86_REG_RDX, &Interval);

    if(Interval != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Interval, &rlInterval, sizeof(rlInterval));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryIntervalProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryPerformanceCounter(
    OUT          PLARGE_INTEGER  PerformanceCounter    ,
    OUTOPTIONAL  PLARGE_INTEGER  PerformanceFrequency  );

*/
void EmuApi::EmuNtQueryPerformanceCounter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER PerformanceCounter{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PerformanceCounter);

    LARGE_INTEGER rlPerformanceCounter{};

    if(PerformanceCounter != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PerformanceCounter, &rlPerformanceCounter, sizeof(rlPerformanceCounter));
    }

    PLARGE_INTEGER PerformanceFrequency{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PerformanceFrequency);

    LARGE_INTEGER rlPerformanceFrequency{};

    if(PerformanceFrequency != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PerformanceFrequency, &rlPerformanceFrequency, sizeof(rlPerformanceFrequency));
    }


    NTSTATUS NtQueryPerformanceCounterResult = NtQueryPerformanceCounter((PLARGE_INTEGER)&rlPerformanceCounter,(PLARGE_INTEGER)&rlPerformanceFrequency);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryPerformanceCounterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PerformanceCounter);

    if(PerformanceCounter != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PerformanceCounter, &rlPerformanceCounter, sizeof(rlPerformanceCounter));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PerformanceFrequency);

    if(PerformanceFrequency != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PerformanceFrequency, &rlPerformanceFrequency, sizeof(rlPerformanceFrequency));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryPerformanceCounter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateKeyedEvent(
    OUT         PHANDLE             KeyedEventHandle  ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          ULONG               Flags             );

*/
void EmuApi::EmuNtCreateKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    HANDLE dpKeyedEventHandle{};

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Flags);


    NTSTATUS NtCreateKeyedEventResult = NtCreateKeyedEvent((PHANDLE)dpKeyedEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenKeyedEvent(
    OUT  PHANDLE             KeyedEventHandle  ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    HANDLE dpKeyedEventHandle{};

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenKeyedEventResult = NtOpenKeyedEvent((PHANDLE)dpKeyedEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReleaseKeyedEvent(
    IN          HANDLE          KeyedEventHandle  ,
    IN          PVOID           KeyValue          ,
    IN          BOOLEAN         Alertable         ,
    INOPTIONAL  PLARGE_INTEGER  Timeout           );

*/
void EmuApi::EmuNtReleaseKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    PVOID KeyValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyValue);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R9, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtReleaseKeyedEventResult = NtReleaseKeyedEvent((HANDLE)KeyedEventHandle,(PVOID)&KeyValue,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReleaseKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyValue);
    uc_reg_write(uc, UC_X86_REG_R8B, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R9, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReleaseKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWaitForKeyedEvent(
    IN          HANDLE          KeyedEventHandle  ,
    IN          PVOID           KeyValue          ,
    IN          BOOLEAN         Alertable         ,
    INOPTIONAL  PLARGE_INTEGER  Timeout           );

*/
void EmuApi::EmuNtWaitForKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    PVOID KeyValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyValue);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R9, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtWaitForKeyedEventResult = NtWaitForKeyedEvent((HANDLE)KeyedEventHandle,(PVOID)&KeyValue,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWaitForKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyValue);
    uc_reg_write(uc, UC_X86_REG_R8B, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R9, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWaitForKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySystemInformation(
    IN           SYSTEM_INFORMATION_CLASS  SystemInformationClass   ,
    OUTOPTIONAL  PVOID                     SystemInformation        ,
    IN           ULONG                     SystemInformationLength  ,
    OUTOPTIONAL  PULONG                    ReturnLength             );

*/
void EmuApi::EmuNtQuerySystemInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SYSTEM_INFORMATION_CLASS SystemInformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SystemInformationClass);

    PVOID SystemInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SystemInformation);

    ULONG SystemInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SystemInformationLength);

    PULONG ReturnLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReturnLength);

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQuerySystemInformationResult = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemInformationClass,(PVOID)&SystemInformation,(ULONG)SystemInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySystemInformationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SystemInformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &SystemInformation);
    uc_reg_write(uc, UC_X86_REG_R8D, &SystemInformationLength);
    uc_reg_write(uc, UC_X86_REG_R9, &ReturnLength);

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySystemInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetSystemInformation(
    IN          SYSTEM_INFORMATION_CLASS  SystemInformationClass   ,
    INOPTIONAL  PVOID                     SystemInformation        ,
    IN          ULONG                     SystemInformationLength  );

*/
void EmuApi::EmuNtSetSystemInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SYSTEM_INFORMATION_CLASS SystemInformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SystemInformationClass);

    PVOID SystemInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SystemInformation);

    ULONG SystemInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SystemInformationLength);


    NTSTATUS NtSetSystemInformationResult = NtSetSystemInformation((SYSTEM_INFORMATION_CLASS)SystemInformationClass,(PVOID)&SystemInformation,(ULONG)SystemInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetSystemInformationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SystemInformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &SystemInformation);
    uc_reg_write(uc, UC_X86_REG_R8D, &SystemInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetSystemInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSystemDebugControl(
    IN           SYSDBG_COMMAND  Command             ,
    INOPTIONAL   PVOID           InputBuffer         ,
    IN           ULONG           InputBufferLength   ,
    OUTOPTIONAL  PVOID           OutputBuffer        ,
    IN           ULONG           OutputBufferLength  ,
    OUTOPTIONAL  PULONG          ReturnLength        );

*/
void EmuApi::EmuNtSystemDebugControl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SYSDBG_COMMAND Command{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Command);

    PVOID InputBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &InputBuffer);

    ULONG InputBufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InputBufferLength);

    PVOID OutputBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutputBuffer);

    ULONG OutputBufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtSystemDebugControlResult = NtSystemDebugControl((SYSDBG_COMMAND)Command,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSystemDebugControlResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Command);
    uc_reg_write(uc, UC_X86_REG_RDX, &InputBuffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &InputBufferLength);
    uc_reg_write(uc, UC_X86_REG_R9, &OutputBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSystemDebugControl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRaiseHardError(
    IN          NTSTATUS    ErrorStatus                 ,
    IN          ULONG       NumberOfParameters          ,
    IN          ULONG       UnicodeStringParameterMask  ,
    INOPTIONAL  PULONG_PTR  Parameters                  ,
    IN          ULONG       ValidResponseOptions        ,
    OUT         PULONG      Response                    );

*/
void EmuApi::EmuNtRaiseHardError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS ErrorStatus{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ErrorStatus);

    ULONG NumberOfParameters{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumberOfParameters);

    ULONG UnicodeStringParameterMask{};
    uc_reg_read(uc, UC_X86_REG_R8D, &UnicodeStringParameterMask);

    PULONG_PTR Parameters{};
    uc_reg_read(uc, UC_X86_REG_R9, &Parameters);

    unsigned long long rlParameters{};

    if(Parameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Parameters, &rlParameters, sizeof(rlParameters));
    }

    ULONG ValidResponseOptions{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ValidResponseOptions, sizeof(ValidResponseOptions));

    PULONG Response{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Response, sizeof(Response));

    ULONG rlResponse{};

    if(Response != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Response, &rlResponse, sizeof(rlResponse));
    }


    NTSTATUS NtRaiseHardErrorResult = NtRaiseHardError((NTSTATUS)ErrorStatus,(ULONG)NumberOfParameters,(ULONG)UnicodeStringParameterMask,(PULONG_PTR)&rlParameters,(ULONG)ValidResponseOptions,(PULONG)&rlResponse);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRaiseHardErrorResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ErrorStatus);
    uc_reg_write(uc, UC_X86_REG_EDX, &NumberOfParameters);
    uc_reg_write(uc, UC_X86_REG_R8D, &UnicodeStringParameterMask);
    uc_reg_write(uc, UC_X86_REG_R9, &Parameters);

    if(Parameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Parameters, &rlParameters, sizeof(rlParameters));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ValidResponseOptions, sizeof(ValidResponseOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Response, sizeof(Response));

    if(Response != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Response, &rlResponse, sizeof(rlResponse));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRaiseHardError\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryDefaultLocale(
    IN   BOOLEAN  UserProfile      ,
    OUT  PLCID    DefaultLocaleId  );

*/
void EmuApi::EmuNtQueryDefaultLocale(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN UserProfile{};
    uc_reg_read(uc, UC_X86_REG_CL, &UserProfile);

    PLCID DefaultLocaleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DefaultLocaleId);

    DWORD rlDefaultLocaleId{};

    if(DefaultLocaleId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultLocaleId, &rlDefaultLocaleId, sizeof(rlDefaultLocaleId));
    }


    NTSTATUS NtQueryDefaultLocaleResult = NtQueryDefaultLocale((BOOLEAN)UserProfile,(PLCID)&rlDefaultLocaleId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryDefaultLocaleResult);
    uc_reg_write(uc, UC_X86_REG_CL, &UserProfile);
    uc_reg_write(uc, UC_X86_REG_RDX, &DefaultLocaleId);

    if(DefaultLocaleId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultLocaleId, &rlDefaultLocaleId, sizeof(rlDefaultLocaleId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryDefaultLocale\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetDefaultLocale(
    IN  BOOLEAN  UserProfile      ,
    IN  LCID     DefaultLocaleId  );

*/
void EmuApi::EmuNtSetDefaultLocale(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN UserProfile{};
    uc_reg_read(uc, UC_X86_REG_CL, &UserProfile);

    LCID DefaultLocaleId{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DefaultLocaleId);


    NTSTATUS NtSetDefaultLocaleResult = NtSetDefaultLocale((BOOLEAN)UserProfile,(LCID)DefaultLocaleId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetDefaultLocaleResult);
    uc_reg_write(uc, UC_X86_REG_CL, &UserProfile);
    uc_reg_write(uc, UC_X86_REG_EDX, &DefaultLocaleId);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetDefaultLocale\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInstallUILanguage(
    OUT  LANGID *  InstallUILanguageId  );

*/
void EmuApi::EmuNtQueryInstallUILanguage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LANGID * InstallUILanguageId{};
    uc_reg_read(uc, UC_X86_REG_RCX, &InstallUILanguageId);

    WORD rlInstallUILanguageId{};

    if(InstallUILanguageId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InstallUILanguageId, &rlInstallUILanguageId, sizeof(rlInstallUILanguageId));
    }


    NTSTATUS NtQueryInstallUILanguageResult = NtQueryInstallUILanguage((LANGID *)&rlInstallUILanguageId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInstallUILanguageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &InstallUILanguageId);

    if(InstallUILanguageId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InstallUILanguageId, &rlInstallUILanguageId, sizeof(rlInstallUILanguageId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInstallUILanguage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryDefaultUILanguage(
    OUT  LANGID *  DefaultUILanguageId  );

*/
void EmuApi::EmuNtQueryDefaultUILanguage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LANGID * DefaultUILanguageId{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DefaultUILanguageId);

    WORD rlDefaultUILanguageId{};

    if(DefaultUILanguageId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultUILanguageId, &rlDefaultUILanguageId, sizeof(rlDefaultUILanguageId));
    }


    NTSTATUS NtQueryDefaultUILanguageResult = NtQueryDefaultUILanguage((LANGID *)&rlDefaultUILanguageId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryDefaultUILanguageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DefaultUILanguageId);

    if(DefaultUILanguageId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultUILanguageId, &rlDefaultUILanguageId, sizeof(rlDefaultUILanguageId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryDefaultUILanguage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetDefaultUILanguage(
    IN  LANGID  DefaultUILanguageId  );

*/
void EmuApi::EmuNtSetDefaultUILanguage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LANGID DefaultUILanguageId{};
    uc_reg_read(uc, UC_X86_REG_CX, &DefaultUILanguageId);


    NTSTATUS NtSetDefaultUILanguageResult = NtSetDefaultUILanguage((LANGID)DefaultUILanguageId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetDefaultUILanguageResult);
    uc_reg_write(uc, UC_X86_REG_CX, &DefaultUILanguageId);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetDefaultUILanguage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetDefaultHardErrorPort(
    IN  HANDLE  DefaultHardErrorPort  );

*/
void EmuApi::EmuNtSetDefaultHardErrorPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DefaultHardErrorPort{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DefaultHardErrorPort);


    NTSTATUS NtSetDefaultHardErrorPortResult = NtSetDefaultHardErrorPort((HANDLE)DefaultHardErrorPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetDefaultHardErrorPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DefaultHardErrorPort);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetDefaultHardErrorPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtShutdownSystem(
    IN  SHUTDOWN_ACTION  Action  );

*/
void EmuApi::EmuNtShutdownSystem(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SHUTDOWN_ACTION Action{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Action);


    NTSTATUS NtShutdownSystemResult = NtShutdownSystem((SHUTDOWN_ACTION)Action);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtShutdownSystemResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Action);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtShutdownSystem\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDisplayString(
    IN  PUNICODE_STRING  String  );

*/
void EmuApi::EmuNtDisplayString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in NtDisplayString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    NTSTATUS NtDisplayStringResult = NtDisplayString((PUNICODE_STRING)&stString);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDisplayStringResult);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in NtDisplayString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDisplayString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAddAtom(
    INOPTIONAL   PWSTR      AtomName  ,
    IN           ULONG      Length    ,
    OUTOPTIONAL  PRTL_ATOM  Atom      );

*/
void EmuApi::EmuNtAddAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in NtAddAtom"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Length);

    PRTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_R8, &Atom);

    RTL_ATOM rlAtom{};

    if(Atom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }


    NTSTATUS NtAddAtomResult = NtAddAtom((PWSTR)rlwAtomName.data(),(ULONG)Length,(PRTL_ATOM)&rlAtom);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAddAtomResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in NtAddAtom"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8, &Atom);

    if(Atom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAddAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFindAtom(
    INOPTIONAL   PWSTR      AtomName  ,
    IN           ULONG      Length    ,
    OUTOPTIONAL  PRTL_ATOM  Atom      );

*/
void EmuApi::EmuNtFindAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in NtFindAtom"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Length);

    PRTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_R8, &Atom);

    RTL_ATOM rlAtom{};

    if(Atom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }


    NTSTATUS NtFindAtomResult = NtFindAtom((PWSTR)rlwAtomName.data(),(ULONG)Length,(PRTL_ATOM)&rlAtom);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFindAtomResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in NtFindAtom"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8, &Atom);

    if(Atom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFindAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteAtom(
    IN  RTL_ATOM  Atom  );

*/
void EmuApi::EmuNtDeleteAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_CX, &Atom);


    NTSTATUS NtDeleteAtomResult = NtDeleteAtom((RTL_ATOM)Atom);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteAtomResult);
    uc_reg_write(uc, UC_X86_REG_CX, &Atom);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationAtom(
    IN           RTL_ATOM                Atom                   ,
    IN           ATOM_INFORMATION_CLASS  AtomInformationClass   ,
    OUTOPTIONAL  PVOID                   AtomInformation        ,
    IN           ULONG                   AtomInformationLength  ,
    OUTOPTIONAL  PULONG                  ReturnLength           );

*/
void EmuApi::EmuNtQueryInformationAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_CX, &Atom);

    ATOM_INFORMATION_CLASS AtomInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AtomInformationClass);

    PVOID AtomInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &AtomInformation);

    ULONG AtomInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AtomInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryInformationAtomResult = NtQueryInformationAtom((RTL_ATOM)Atom,(ATOM_INFORMATION_CLASS)AtomInformationClass,(PVOID)&AtomInformation,(ULONG)AtomInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationAtomResult);
    uc_reg_write(uc, UC_X86_REG_CX, &Atom);
    uc_reg_write(uc, UC_X86_REG_EDX, &AtomInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &AtomInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &AtomInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCancelIoFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  );

*/
void EmuApi::EmuNtCancelIoFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }


    NTSTATUS NtCancelIoFileResult = NtCancelIoFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCancelIoFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCancelIoFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateNamedPipeFile(
    OUT         PHANDLE             FileHandle         ,
    IN          ULONG               DesiredAccess      ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes   ,
    OUT         PIO_STATUS_BLOCK    IoStatusBlock      ,
    IN          ULONG               ShareAccess        ,
    IN          ULONG               CreateDisposition  ,
    IN          ULONG               CreateOptions      ,
    IN          ULONG               NamedPipeType      ,
    IN          ULONG               ReadMode           ,
    IN          ULONG               CompletionMode     ,
    IN          ULONG               MaximumInstances   ,
    IN          ULONG               InboundQuota       ,
    IN          ULONG               OutboundQuota      ,
    INOPTIONAL  PLARGE_INTEGER      DefaultTimeout     );

*/
void EmuApi::EmuNtCreateNamedPipeFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ULONG DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG ShareAccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));

    ULONG CreateDisposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CreateDisposition, sizeof(CreateDisposition));

    ULONG CreateOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &CreateOptions, sizeof(CreateOptions));

    ULONG NamedPipeType{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &NamedPipeType, sizeof(NamedPipeType));

    ULONG ReadMode{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ReadMode, sizeof(ReadMode));

    ULONG CompletionMode{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &CompletionMode, sizeof(CompletionMode));

    ULONG MaximumInstances{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &MaximumInstances, sizeof(MaximumInstances));

    ULONG InboundQuota{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &InboundQuota, sizeof(InboundQuota));

    ULONG OutboundQuota{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &OutboundQuota, sizeof(OutboundQuota));

    PLARGE_INTEGER DefaultTimeout{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &DefaultTimeout, sizeof(DefaultTimeout));

    LARGE_INTEGER rlDefaultTimeout{};

    if(DefaultTimeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultTimeout, &rlDefaultTimeout, sizeof(rlDefaultTimeout));
    }


    NTSTATUS NtCreateNamedPipeFileResult = NtCreateNamedPipeFile((PHANDLE)dpFileHandle,(ULONG)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)ShareAccess,(ULONG)CreateDisposition,(ULONG)CreateOptions,(ULONG)NamedPipeType,(ULONG)ReadMode,(ULONG)CompletionMode,(ULONG)MaximumInstances,(ULONG)InboundQuota,(ULONG)OutboundQuota,(PLARGE_INTEGER)&rlDefaultTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateNamedPipeFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &CreateDisposition, sizeof(CreateDisposition));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &NamedPipeType, sizeof(NamedPipeType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ReadMode, sizeof(ReadMode));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &CompletionMode, sizeof(CompletionMode));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &MaximumInstances, sizeof(MaximumInstances));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &InboundQuota, sizeof(InboundQuota));
    uc_mem_write(uc, (DWORD_PTR)SP+104, &OutboundQuota, sizeof(OutboundQuota));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &DefaultTimeout, sizeof(DefaultTimeout));

    if(DefaultTimeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultTimeout, &rlDefaultTimeout, sizeof(rlDefaultTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateNamedPipeFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateMailslotFile(
    OUT  PHANDLE             FileHandle          ,
    IN   ULONG               DesiredAccess       ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes    ,
    OUT  PIO_STATUS_BLOCK    IoStatusBlock       ,
    IN   ULONG               CreateOptions       ,
    IN   ULONG               MailslotQuota       ,
    IN   ULONG               MaximumMessageSize  ,
    IN   PLARGE_INTEGER      ReadTimeout         );

*/
void EmuApi::EmuNtCreateMailslotFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ULONG DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG CreateOptions{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CreateOptions, sizeof(CreateOptions));

    ULONG MailslotQuota{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &MailslotQuota, sizeof(MailslotQuota));

    ULONG MaximumMessageSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &MaximumMessageSize, sizeof(MaximumMessageSize));

    PLARGE_INTEGER ReadTimeout{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ReadTimeout, sizeof(ReadTimeout));

    LARGE_INTEGER rlReadTimeout{};

    if(ReadTimeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReadTimeout, &rlReadTimeout, sizeof(rlReadTimeout));
    }


    NTSTATUS NtCreateMailslotFileResult = NtCreateMailslotFile((PHANDLE)dpFileHandle,(ULONG)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)CreateOptions,(ULONG)MailslotQuota,(ULONG)MaximumMessageSize,(PLARGE_INTEGER)&rlReadTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateMailslotFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &MailslotQuota, sizeof(MailslotQuota));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &MaximumMessageSize, sizeof(MaximumMessageSize));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ReadTimeout, sizeof(ReadTimeout));

    if(ReadTimeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReadTimeout, &rlReadTimeout, sizeof(rlReadTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateMailslotFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteFile(
    IN  POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtDeleteFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtDeleteFileResult = NtDeleteFile((POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFlushBuffersFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  );

*/
void EmuApi::EmuNtFlushBuffersFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }


    NTSTATUS NtFlushBuffersFileResult = NtFlushBuffersFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFlushBuffersFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFlushBuffersFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtNotifyChangeDirectoryFile(
    IN          HANDLE            FileHandle        ,
    INOPTIONAL  HANDLE            Event             ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine        ,
    INOPTIONAL  PVOID             ApcContext        ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock     ,
    OUT         PVOID             Buffer            ,
    IN          ULONG             Length            ,
    IN          ULONG             CompletionFilter  ,
    IN          BOOLEAN           WatchTree         );

*/
void EmuApi::EmuNtNotifyChangeDirectoryFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    ULONG CompletionFilter{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));

    BOOLEAN WatchTree{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));


    NTSTATUS NtNotifyChangeDirectoryFileResult = NtNotifyChangeDirectoryFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(ULONG)CompletionFilter,(BOOLEAN)WatchTree);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtNotifyChangeDirectoryFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtNotifyChangeDirectoryFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryAttributesFile(
    IN   POBJECT_ATTRIBUTES       ObjectAttributes  ,
    OUT  PFILE_BASIC_INFORMATION  FileInformation   );

*/
void EmuApi::EmuNtQueryAttributesFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PFILE_BASIC_INFORMATION FileInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileInformation);

    FILE_BASIC_INFORMATION stFileInformation{};

    if(FileInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }


    NTSTATUS NtQueryAttributesFileResult = NtQueryAttributesFile((POBJECT_ATTRIBUTES)&rlObjectAttributes,(PFILE_BASIC_INFORMATION)&stFileInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryAttributesFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &FileInformation);

    if(FileInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryAttributesFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryFullAttributesFile(
    IN   POBJECT_ATTRIBUTES              ObjectAttributes  ,
    OUT  PFILE_NETWORK_OPEN_INFORMATION  FileInformation   );

*/
void EmuApi::EmuNtQueryFullAttributesFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PFILE_NETWORK_OPEN_INFORMATION FileInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileInformation);

    FILE_NETWORK_OPEN_INFORMATION stFileInformation{};

    if(FileInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }


    NTSTATUS NtQueryFullAttributesFileResult = NtQueryFullAttributesFile((POBJECT_ATTRIBUTES)&rlObjectAttributes,(PFILE_NETWORK_OPEN_INFORMATION)&stFileInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryFullAttributesFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &FileInformation);

    if(FileInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryFullAttributesFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryEaFile(
    IN          HANDLE            FileHandle         ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock      ,
    OUT         PVOID             Buffer             ,
    IN          ULONG             Length             ,
    IN          BOOLEAN           ReturnSingleEntry  ,
    IN          PVOID             EaList             ,
    IN          ULONG             EaListLength       ,
    INOPTIONAL  PULONG            EaIndex            ,
    ,IN         BOOLEAN           RestartScan        );

*/
void EmuApi::EmuNtQueryEaFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    BOOLEAN ReturnSingleEntry{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));

    PVOID EaList{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &EaList, sizeof(EaList));

    ULONG EaListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &EaListLength, sizeof(EaListLength));

    PULONG EaIndex{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &EaIndex, sizeof(EaIndex));

    ULONG rlEaIndex{};

    if(EaIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EaIndex, &rlEaIndex, sizeof(rlEaIndex));
    }

    BOOLEAN RestartScan{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));


    NTSTATUS NtQueryEaFileResult = NtQueryEaFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(BOOLEAN)ReturnSingleEntry,(PVOID)&EaList,(ULONG)EaListLength,(PULONG)&rlEaIndex,(BOOLEAN)RestartScan);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryEaFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &EaList, sizeof(EaList));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &EaListLength, sizeof(EaListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &EaIndex, sizeof(EaIndex));

    if(EaIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EaIndex, &rlEaIndex, sizeof(rlEaIndex));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryEaFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateFile(
    OUT         PHANDLE             FileHandle         ,
    IN          ACCESS_MASK         DesiredAccess      ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes   ,
    OUT         PIO_STATUS_BLOCK    IoStatusBlock      ,
    INOPTIONAL  PLARGE_INTEGER      AllocationSize     ,
    IN          ULONG               FileAttributes     ,
    IN          ULONG               ShareAccess        ,
    IN          ULONG               CreateDisposition  ,
    IN          ULONG               CreateOptions      ,
    INOPTIONAL  PVOID               EaBuffer           ,
    IN          ULONG               EaLength           );

*/
void EmuApi::EmuNtCreateFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER AllocationSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AllocationSize, sizeof(AllocationSize));

    LARGE_INTEGER rlAllocationSize{};

    if(AllocationSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AllocationSize, &rlAllocationSize, sizeof(rlAllocationSize));
    }

    ULONG FileAttributes{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FileAttributes, sizeof(FileAttributes));

    ULONG ShareAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ShareAccess, sizeof(ShareAccess));

    ULONG CreateDisposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CreateDisposition, sizeof(CreateDisposition));

    ULONG CreateOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &CreateOptions, sizeof(CreateOptions));

    PVOID EaBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &EaBuffer, sizeof(EaBuffer));

    ULONG EaLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &EaLength, sizeof(EaLength));


    NTSTATUS NtCreateFileResult = NtCreateFile((PHANDLE)dpFileHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlAllocationSize,(ULONG)FileAttributes,(ULONG)ShareAccess,(ULONG)CreateDisposition,(ULONG)CreateOptions,(PVOID)&EaBuffer,(ULONG)EaLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AllocationSize, sizeof(AllocationSize));

    if(AllocationSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AllocationSize, &rlAllocationSize, sizeof(rlAllocationSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FileAttributes, sizeof(FileAttributes));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ShareAccess, sizeof(ShareAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CreateDisposition, sizeof(CreateDisposition));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &EaBuffer, sizeof(EaBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &EaLength, sizeof(EaLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeviceIoControlFile(
    IN           HANDLE            FileHandle          ,
    INOPTIONAL   HANDLE            Event               ,
    INOPTIONAL   PIO_APC_ROUTINE   ApcRoutine          ,
    INOPTIONAL   PVOID             ApcContext          ,
    OUT          PIO_STATUS_BLOCK  IoStatusBlock       ,
    IN           ULONG             IoControlCode       ,
    INOPTIONAL   PVOID             InputBuffer         ,
    IN           ULONG             InputBufferLength   ,
    OUTOPTIONAL  PVOID             OutputBuffer        ,
    IN           ULONG             OutputBufferLength  );

*/
void EmuApi::EmuNtDeviceIoControlFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG IoControlCode{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &IoControlCode, sizeof(IoControlCode));

    PVOID InputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));

    ULONG InputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));

    PVOID OutputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));

    ULONG OutputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));


    NTSTATUS NtDeviceIoControlFileResult = NtDeviceIoControlFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)IoControlCode,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeviceIoControlFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &IoControlCode, sizeof(IoControlCode));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeviceIoControlFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFsControlFile(
    IN           HANDLE            FileHandle          ,
    INOPTIONAL   HANDLE            Event               ,
    INOPTIONAL   PIO_APC_ROUTINE   ApcRoutine          ,
    INOPTIONAL   PVOID             ApcContext          ,
    OUT          PIO_STATUS_BLOCK  IoStatusBlock       ,
    IN           ULONG             FsControlCode       ,
    INOPTIONAL   PVOID             InputBuffer         ,
    IN           ULONG             InputBufferLength   ,
    OUTOPTIONAL  PVOID             OutputBuffer        ,
    IN           ULONG             OutputBufferLength  );

*/
void EmuApi::EmuNtFsControlFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG FsControlCode{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FsControlCode, sizeof(FsControlCode));

    PVOID InputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));

    ULONG InputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));

    PVOID OutputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));

    ULONG OutputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));


    NTSTATUS NtFsControlFileResult = NtFsControlFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)FsControlCode,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFsControlFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FsControlCode, sizeof(FsControlCode));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFsControlFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtLockFile(
    IN          HANDLE            FileHandle       ,
    INOPTIONAL  HANDLE            Event            ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine       ,
    INOPTIONAL  PVOID             ApcContext       ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock    ,
    IN          PLARGE_INTEGER    ByteOffset       ,
    IN          PLARGE_INTEGER    Length           ,
    IN          ULONG             Key              ,
    IN          BOOLEAN           FailImmediately  ,
    IN          BOOLEAN           ExclusiveLock    );

*/
void EmuApi::EmuNtLockFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PLARGE_INTEGER Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    LARGE_INTEGER rlLength{};

    if(Length != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }

    ULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Key, sizeof(Key));

    BOOLEAN FailImmediately{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &FailImmediately, sizeof(FailImmediately));

    BOOLEAN ExclusiveLock{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ExclusiveLock, sizeof(ExclusiveLock));


    NTSTATUS NtLockFileResult = NtLockFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlByteOffset,(PLARGE_INTEGER)&rlLength,(ULONG)Key,(BOOLEAN)FailImmediately,(BOOLEAN)ExclusiveLock);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtLockFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    if(Length != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Key, sizeof(Key));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &FailImmediately, sizeof(FailImmediately));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ExclusiveLock, sizeof(ExclusiveLock));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtLockFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenFile(
    OUT  PHANDLE             FileHandle        ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  ,
    OUT  PIO_STATUS_BLOCK    IoStatusBlock     ,
    IN   ULONG               ShareAccess       ,
    IN   ULONG               OpenOptions       );

*/
void EmuApi::EmuNtOpenFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG ShareAccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));

    ULONG OpenOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &OpenOptions, sizeof(OpenOptions));


    NTSTATUS NtOpenFileResult = NtOpenFile((PHANDLE)dpFileHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)ShareAccess,(ULONG)OpenOptions);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &OpenOptions, sizeof(OpenOptions));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryDirectoryFile(
    IN          HANDLE                  FileHandle            ,
    INOPTIONAL  HANDLE                  Event                 ,
    INOPTIONAL  PIO_APC_ROUTINE         ApcRoutine            ,
    INOPTIONAL  PVOID                   ApcContext            ,
    OUT         PIO_STATUS_BLOCK        IoStatusBlock         ,
    OUT         PVOID                   FileInformation       ,
    IN          ULONG                   Length                ,
    IN          FILE_INFORMATION_CLASS  FileInformationClass  ,
    IN          BOOLEAN                 ReturnSingleEntry     ,
    INOPTIONAL  PUNICODE_STRING         FileName              ,
    IN          BOOLEAN                 RestartScan           );

*/
void EmuApi::EmuNtQueryDirectoryFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FileInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FileInformation, sizeof(FileInformation));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    FILE_INFORMATION_CLASS FileInformationClass{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &FileInformationClass, sizeof(FileInformationClass));

    BOOLEAN ReturnSingleEntry{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ReturnSingleEntry, sizeof(ReturnSingleEntry));

    PUNICODE_STRING FileName{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &FileName, sizeof(FileName));

    std::wstring rlwFileName;

    USHORT rlLengthFileName;

    USHORT rlMaxLengthFileName;
    uc_mem_read(uc, (DWORD_PTR)FileName, &rlLengthFileName, sizeof(rlLengthFileName));
    uc_mem_read(uc, (DWORD_PTR)FileName+16, &rlMaxLengthFileName, sizeof(rlMaxLengthFileName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)FileName+64, rlwFileName, true, rlLengthFileName)) { printf("Error when read FileName in NtQueryDirectoryFile"); _CrtDbgBreak(); }

    UNICODE_STRING stFileName{};
    stFileName.Length = rlLengthFileName;
    stFileName.MaximumLength = rlMaxLengthFileName;
    stFileName.Buffer = rlwFileName.data();

    BOOLEAN RestartScan{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &RestartScan, sizeof(RestartScan));


    NTSTATUS NtQueryDirectoryFileResult = NtQueryDirectoryFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FileInformation,(ULONG)Length,(FILE_INFORMATION_CLASS)FileInformationClass,(BOOLEAN)ReturnSingleEntry,(PUNICODE_STRING)&stFileName,(BOOLEAN)RestartScan);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryDirectoryFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FileInformation, sizeof(FileInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &FileInformationClass, sizeof(FileInformationClass));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ReturnSingleEntry, sizeof(ReturnSingleEntry));
    uc_mem_write(uc, (DWORD_PTR)FileName, &stFileName.Length, sizeof(stFileName.Length));
    uc_mem_write(uc, (DWORD_PTR)FileName+16, &stFileName.MaximumLength, sizeof(stFileName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)FileName+64, stFileName.Buffer, true, stFileName.Length)) { printf("Error when read FileName in NtQueryDirectoryFile"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &RestartScan, sizeof(RestartScan));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryDirectoryFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationFile(
    IN   HANDLE                  FileHandle            ,
    OUT  PIO_STATUS_BLOCK        IoStatusBlock         ,
    OUT  PVOID                   FileInformation       ,
    IN   ULONG                   Length                ,
    IN   FILE_INFORMATION_CLASS  FileInformationClass  );

*/
void EmuApi::EmuNtQueryInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FileInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FileInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FILE_INFORMATION_CLASS FileInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));


    NTSTATUS NtQueryInformationFileResult = NtQueryInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FileInformation,(ULONG)Length,(FILE_INFORMATION_CLASS)FileInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FileInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryQuotaInformationFile(
    IN          HANDLE            FileHandle         ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock      ,
    OUT         PVOID             Buffer             ,
    IN          ULONG             Length             ,
    IN          BOOLEAN           ReturnSingleEntry  ,
    INOPTIONAL  PVOID             SidList            ,
    IN          ULONG             SidListLength      ,
    INOPTIONAL  PSID              StartSid           ,
    IN          BOOLEAN           RestartScan        );

*/
void EmuApi::EmuNtQueryQuotaInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    BOOLEAN ReturnSingleEntry{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));

    PVOID SidList{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SidList, sizeof(SidList));

    ULONG SidListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &SidListLength, sizeof(SidListLength));

    PSID StartSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &StartSid, sizeof(StartSid));

    BOOLEAN RestartScan{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));


    NTSTATUS NtQueryQuotaInformationFileResult = NtQueryQuotaInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(BOOLEAN)ReturnSingleEntry,(PVOID)&SidList,(ULONG)SidListLength,(PSID)&StartSid,(BOOLEAN)RestartScan);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryQuotaInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SidList, sizeof(SidList));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &SidListLength, sizeof(SidListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &StartSid, sizeof(StartSid));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryQuotaInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryVolumeInformationFile(
    IN   HANDLE                FileHandle          ,
    OUT  PIO_STATUS_BLOCK      IoStatusBlock       ,
    OUT  PVOID                 FsInformation       ,
    IN   ULONG                 Length              ,
    IN   FS_INFORMATION_CLASS  FsInformationClass  );

*/
void EmuApi::EmuNtQueryVolumeInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FsInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FsInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FS_INFORMATION_CLASS FsInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));


    NTSTATUS NtQueryVolumeInformationFileResult = NtQueryVolumeInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FsInformation,(ULONG)Length,(FS_INFORMATION_CLASS)FsInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryVolumeInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FsInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryVolumeInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReadFile(
    IN          HANDLE            FileHandle     ,
    INOPTIONAL  HANDLE            Event          ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine     ,
    INOPTIONAL  PVOID             ApcContext     ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock  ,
    OUT         PVOID             Buffer         ,
    IN          ULONG             Length         ,
    INOPTIONAL  PLARGE_INTEGER    ByteOffset     ,
    INOPTIONAL  PULONG            Key            );

*/
void EmuApi::EmuNtReadFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS NtReadFileResult = NtReadFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReadFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReadFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationFile(
    IN   HANDLE                  FileHandle            ,
    OUT  PIO_STATUS_BLOCK        IoStatusBlock         ,
    IN   PVOID                   FileInformation       ,
    IN   ULONG                   Length                ,
    IN   FILE_INFORMATION_CLASS  FileInformationClass  );

*/
void EmuApi::EmuNtSetInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FileInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FileInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FILE_INFORMATION_CLASS FileInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));


    NTSTATUS NtSetInformationFileResult = NtSetInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FileInformation,(ULONG)Length,(FILE_INFORMATION_CLASS)FileInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FileInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetQuotaInformationFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN   PVOID             Buffer         ,
    IN   ULONG             Length         );

*/
void EmuApi::EmuNtSetQuotaInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);


    NTSTATUS NtSetQuotaInformationFileResult = NtSetQuotaInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetQuotaInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetQuotaInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetVolumeInformationFile(
    IN   HANDLE                FileHandle          ,
    OUT  PIO_STATUS_BLOCK      IoStatusBlock       ,
    IN   PVOID                 FsInformation       ,
    IN   ULONG                 Length              ,
    IN   FS_INFORMATION_CLASS  FsInformationClass  );

*/
void EmuApi::EmuNtSetVolumeInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FsInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FsInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FS_INFORMATION_CLASS FsInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));


    NTSTATUS NtSetVolumeInformationFileResult = NtSetVolumeInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FsInformation,(ULONG)Length,(FS_INFORMATION_CLASS)FsInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetVolumeInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FsInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetVolumeInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWriteFile(
    IN          HANDLE            FileHandle     ,
    INOPTIONAL  HANDLE            Event          ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine     ,
    INOPTIONAL  PVOID             ApcContext     ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN          PVOID             Buffer         ,
    IN          ULONG             Length         ,
    INOPTIONAL  PLARGE_INTEGER    ByteOffset     ,
    INOPTIONAL  PULONG            Key            );

*/
void EmuApi::EmuNtWriteFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS NtWriteFileResult = NtWriteFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWriteFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWriteFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnlockFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN   PLARGE_INTEGER    ByteOffset     ,
    IN   PLARGE_INTEGER    Length         ,
    IN   ULONG             Key            );

*/
void EmuApi::EmuNtUnlockFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER ByteOffset{};
    uc_reg_read(uc, UC_X86_REG_R8, &ByteOffset);

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PLARGE_INTEGER Length{};
    uc_reg_read(uc, UC_X86_REG_R9, &Length);

    LARGE_INTEGER rlLength{};

    if(Length != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }

    ULONG Key{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Key, sizeof(Key));


    NTSTATUS NtUnlockFileResult = NtUnlockFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlByteOffset,(PLARGE_INTEGER)&rlLength,(ULONG)Key);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnlockFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ByteOffset);

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Length);

    if(Length != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Key, sizeof(Key));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnlockFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReadFileScatter(
    IN          HANDLE                 FileHandle     ,
    INOPTIONAL  HANDLE                 Event          ,
    INOPTIONAL  PIO_APC_ROUTINE        ApcRoutine     ,
    INOPTIONAL  PVOID                  ApcContext     ,
    OUT         PIO_STATUS_BLOCK       IoStatusBlock  ,
    IN          PFILE_SEGMENT_ELEMENT  SegmentArray   ,
    IN          ULONG                  Length         ,
    INOPTIONAL  PLARGE_INTEGER         ByteOffset     ,
    INOPTIONAL  PULONG                 Key            );

*/
void EmuApi::EmuNtReadFileScatter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PFILE_SEGMENT_ELEMENT SegmentArray{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    union _FILE_SEGMENT_ELEMENT rlSegmentArray{};

    if(SegmentArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS NtReadFileScatterResult = NtReadFileScatter((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PFILE_SEGMENT_ELEMENT)&rlSegmentArray,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReadFileScatterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    if(SegmentArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReadFileScatter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetEaFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN   PVOID             Buffer         ,
    IN   ULONG             Length         );

*/
void EmuApi::EmuNtSetEaFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);


    NTSTATUS NtSetEaFileResult = NtSetEaFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetEaFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetEaFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWriteFileGather(
    IN          HANDLE                 FileHandle     ,
    INOPTIONAL  HANDLE                 Event          ,
    INOPTIONAL  PIO_APC_ROUTINE        ApcRoutine     ,
    INOPTIONAL  PVOID                  ApcContext     ,
    OUT         PIO_STATUS_BLOCK       IoStatusBlock  ,
    IN          PFILE_SEGMENT_ELEMENT  SegmentArray   ,
    IN          ULONG                  Length         ,
    INOPTIONAL  PLARGE_INTEGER         ByteOffset     ,
    INOPTIONAL  PULONG                 Key            );

*/
void EmuApi::EmuNtWriteFileGather(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PFILE_SEGMENT_ELEMENT SegmentArray{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    union _FILE_SEGMENT_ELEMENT rlSegmentArray{};

    if(SegmentArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS NtWriteFileGatherResult = NtWriteFileGather((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PFILE_SEGMENT_ELEMENT)&rlSegmentArray,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWriteFileGatherResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    if(SegmentArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWriteFileGather\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtLoadDriver(
    IN  PUNICODE_STRING  DriverServiceName  );

*/
void EmuApi::EmuNtLoadDriver(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DriverServiceName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverServiceName);

    std::wstring rlwDriverServiceName;

    USHORT rlLengthDriverServiceName;

    USHORT rlMaxLengthDriverServiceName;
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName, &rlLengthDriverServiceName, sizeof(rlLengthDriverServiceName));
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName+16, &rlMaxLengthDriverServiceName, sizeof(rlMaxLengthDriverServiceName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, rlwDriverServiceName, true, rlLengthDriverServiceName)) { printf("Error when read DriverServiceName in NtLoadDriver"); _CrtDbgBreak(); }

    UNICODE_STRING stDriverServiceName{};
    stDriverServiceName.Length = rlLengthDriverServiceName;
    stDriverServiceName.MaximumLength = rlMaxLengthDriverServiceName;
    stDriverServiceName.Buffer = rlwDriverServiceName.data();


    NTSTATUS NtLoadDriverResult = NtLoadDriver((PUNICODE_STRING)&stDriverServiceName);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtLoadDriverResult);
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName, &stDriverServiceName.Length, sizeof(stDriverServiceName.Length));
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName+16, &stDriverServiceName.MaximumLength, sizeof(stDriverServiceName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, stDriverServiceName.Buffer, true, stDriverServiceName.Length)) { printf("Error when read DriverServiceName in NtLoadDriver"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtLoadDriver\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnloadDriver(
    IN  PUNICODE_STRING  DriverServiceName  );

*/
void EmuApi::EmuNtUnloadDriver(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DriverServiceName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverServiceName);

    std::wstring rlwDriverServiceName;

    USHORT rlLengthDriverServiceName;

    USHORT rlMaxLengthDriverServiceName;
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName, &rlLengthDriverServiceName, sizeof(rlLengthDriverServiceName));
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName+16, &rlMaxLengthDriverServiceName, sizeof(rlMaxLengthDriverServiceName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, rlwDriverServiceName, true, rlLengthDriverServiceName)) { printf("Error when read DriverServiceName in NtUnloadDriver"); _CrtDbgBreak(); }

    UNICODE_STRING stDriverServiceName{};
    stDriverServiceName.Length = rlLengthDriverServiceName;
    stDriverServiceName.MaximumLength = rlMaxLengthDriverServiceName;
    stDriverServiceName.Buffer = rlwDriverServiceName.data();


    NTSTATUS NtUnloadDriverResult = NtUnloadDriver((PUNICODE_STRING)&stDriverServiceName);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnloadDriverResult);
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName, &stDriverServiceName.Length, sizeof(stDriverServiceName.Length));
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName+16, &stDriverServiceName.MaximumLength, sizeof(stDriverServiceName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, stDriverServiceName.Buffer, true, stDriverServiceName.Length)) { printf("Error when read DriverServiceName in NtUnloadDriver"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnloadDriver\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateIoCompletion(
    OUT         PHANDLE             IoCompletionHandle  ,
    IN          ACCESS_MASK         DesiredAccess       ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes    ,
    IN          ULONG               Count               );

*/
void EmuApi::EmuNtCreateIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    HANDLE dpIoCompletionHandle{};

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Count);


    NTSTATUS NtCreateIoCompletionResult = NtCreateIoCompletion((PHANDLE)dpIoCompletionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)Count);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &Count);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenIoCompletion(
    OUT  PHANDLE             IoCompletionHandle  ,
    IN   ACCESS_MASK         DesiredAccess       ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes    );

*/
void EmuApi::EmuNtOpenIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    HANDLE dpIoCompletionHandle{};

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenIoCompletionResult = NtOpenIoCompletion((PHANDLE)dpIoCompletionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryIoCompletion(
    IN           HANDLE                           IoCompletionHandle             ,
    IN           IO_COMPLETION_INFORMATION_CLASS  IoCompletionInformationClass   ,
    OUT          PVOID                            IoCompletionInformation        ,
    IN           ULONG                            IoCompletionInformationLength  ,
    OUTOPTIONAL  PULONG                           ReturnLength                   );

*/
void EmuApi::EmuNtQueryIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &IoCompletionInformationClass);

    PVOID IoCompletionInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &IoCompletionInformation);

    ULONG IoCompletionInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &IoCompletionInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryIoCompletionResult = NtQueryIoCompletion((HANDLE)IoCompletionHandle,(IO_COMPLETION_INFORMATION_CLASS)IoCompletionInformationClass,(PVOID)&IoCompletionInformation,(ULONG)IoCompletionInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &IoCompletionInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &IoCompletionInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &IoCompletionInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetIoCompletion(
    IN          HANDLE     IoCompletionHandle   ,
    IN          PVOID      KeyContext           ,
    INOPTIONAL  PVOID      ApcContext           ,
    IN          NTSTATUS   IoStatus             ,
    IN          ULONG_PTR  IoStatusInformation  );

*/
void EmuApi::EmuNtSetIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    PVOID KeyContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyContext);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcContext);

    NTSTATUS IoStatus{};
    uc_reg_read(uc, UC_X86_REG_R9D, &IoStatus);

    ULONG_PTR IoStatusInformation{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusInformation, sizeof(IoStatusInformation));


    NTSTATUS NtSetIoCompletionResult = NtSetIoCompletion((HANDLE)IoCompletionHandle,(PVOID)&KeyContext,(PVOID)&ApcContext,(NTSTATUS)IoStatus,(ULONG_PTR)IoStatusInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyContext);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcContext);
    uc_reg_write(uc, UC_X86_REG_R9D, &IoStatus);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusInformation, sizeof(IoStatusInformation));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRemoveIoCompletion(
    IN          HANDLE            IoCompletionHandle  ,
    OUT         PVOID *           KeyContext          ,
    OUT         PVOID *           ApcContext          ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock       ,
    INOPTIONAL  PLARGE_INTEGER    Timeout             );

*/
void EmuApi::EmuNtRemoveIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    PVOID * KeyContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyContext);

    PVOID * dpKeyContext{};

    if(KeyContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyContext, &dpKeyContext, sizeof(dpKeyContext));
    }

    PVOID * ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcContext);

    PVOID * dpApcContext{};

    if(ApcContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ApcContext, &dpApcContext, sizeof(dpApcContext));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtRemoveIoCompletionResult = NtRemoveIoCompletion((HANDLE)IoCompletionHandle,(PVOID *)&dpKeyContext,(PVOID *)&dpApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRemoveIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyContext);

    if(KeyContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyContext, &dpKeyContext, sizeof(dpKeyContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ApcContext);

    if(ApcContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ApcContext, &dpApcContext, sizeof(dpApcContext));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRemoveIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCallbackReturn(
    IN   PVOID     OutputBuffer  ,
    ,IN  ULONG     OutputLength  ,
    IN   NTSTATUS  Status        );

*/
void EmuApi::EmuNtCallbackReturn(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID OutputBuffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &OutputBuffer);

    ULONG OutputLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &OutputLength);

    NTSTATUS Status{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Status);


    NTSTATUS NtCallbackReturnResult = NtCallbackReturn((PVOID)&OutputBuffer,(ULONG)OutputLength,(NTSTATUS)Status);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCallbackReturnResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &OutputBuffer);
    uc_reg_write(uc, UC_X86_REG_EDX, &OutputLength);
    uc_reg_write(uc, UC_X86_REG_R8D, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCallbackReturn\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryDebugFilterState(
    IN  ULONG  ComponentId  ,
    IN  ULONG  Level        );

*/
void EmuApi::EmuNtQueryDebugFilterState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);


    NTSTATUS NtQueryDebugFilterStateResult = NtQueryDebugFilterState((ULONG)ComponentId,(ULONG)Level);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryDebugFilterStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryDebugFilterState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetDebugFilterState(
    IN  ULONG    ComponentId  ,
    IN  ULONG    Level        ,
    IN  BOOLEAN  State        );

*/
void EmuApi::EmuNtSetDebugFilterState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);

    BOOLEAN State{};
    uc_reg_read(uc, UC_X86_REG_R8B, &State);


    NTSTATUS NtSetDebugFilterStateResult = NtSetDebugFilterState((ULONG)ComponentId,(ULONG)Level,(BOOLEAN)State);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetDebugFilterStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    uc_reg_write(uc, UC_X86_REG_R8B, &State);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetDebugFilterState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtYieldExecution(VOID);

*/
void EmuApi::EmuNtYieldExecution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS NtYieldExecutionResult = NtYieldExecution();


    uc_reg_write(uc, UC_X86_REG_EAX, &NtYieldExecutionResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtYieldExecution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreatePort(
    OUT         PHANDLE             PortHandle               ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes         ,
    IN          ULONG               MaxConnectionInfoLength  ,
    IN          ULONG               MaxMessageLength         ,
    INOPTIONAL  ULONG               MaxPoolUsage             );

*/
void EmuApi::EmuNtCreatePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG MaxConnectionInfoLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);

    ULONG MaxMessageLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MaxMessageLength);

    ULONG MaxPoolUsage{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));


    NTSTATUS NtCreatePortResult = NtCreatePort((PHANDLE)dpPortHandle,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)MaxConnectionInfoLength,(ULONG)MaxMessageLength,(ULONG)MaxPoolUsage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreatePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);
    uc_reg_write(uc, UC_X86_REG_R9D, &MaxMessageLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreatePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateWaitablePort(
    OUT         PHANDLE             PortHandle               ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes         ,
    IN          ULONG               MaxConnectionInfoLength  ,
    IN          ULONG               MaxMessageLength         ,
    INOPTIONAL  ULONG               MaxPoolUsage             );

*/
void EmuApi::EmuNtCreateWaitablePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG MaxConnectionInfoLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);

    ULONG MaxMessageLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MaxMessageLength);

    ULONG MaxPoolUsage{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));


    NTSTATUS NtCreateWaitablePortResult = NtCreateWaitablePort((PHANDLE)dpPortHandle,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)MaxConnectionInfoLength,(ULONG)MaxMessageLength,(ULONG)MaxPoolUsage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateWaitablePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);
    uc_reg_write(uc, UC_X86_REG_R9D, &MaxMessageLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateWaitablePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtConnectPort(
    OUT            PHANDLE                       PortHandle                   ,
    IN             PUNICODE_STRING               PortName                     ,
    IN             PSECURITY_QUALITY_OF_SERVICE  SecurityQos                  ,
    INOUTOPTIONAL  PPORT_VIEW                    ClientView                   ,
    INOUTOPTIONAL  PREMOTE_PORT_VIEW             ServerView                   ,
    OUTOPTIONAL    PULONG                        MaxMessageLength             ,
    INOUTOPTIONAL  PVOID                         ConnectionInformation        ,
    INOUTOPTIONAL  PULONG                        ConnectionInformationLength  );

*/
void EmuApi::EmuNtConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    PUNICODE_STRING PortName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortName);

    std::wstring rlwPortName;

    USHORT rlLengthPortName;

    USHORT rlMaxLengthPortName;
    uc_mem_read(uc, (DWORD_PTR)PortName, &rlLengthPortName, sizeof(rlLengthPortName));
    uc_mem_read(uc, (DWORD_PTR)PortName+16, &rlMaxLengthPortName, sizeof(rlMaxLengthPortName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, rlwPortName, true, rlLengthPortName)) { printf("Error when read PortName in NtConnectPort"); _CrtDbgBreak(); }

    UNICODE_STRING stPortName{};
    stPortName.Length = rlLengthPortName;
    stPortName.MaximumLength = rlMaxLengthPortName;
    stPortName.Buffer = rlwPortName.data();

    PSECURITY_QUALITY_OF_SERVICE SecurityQos{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityQos);

    SECURITY_QUALITY_OF_SERVICE stSecurityQos{};

    if(SecurityQos != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }

    PPORT_VIEW ClientView{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientView);

    PORT_VIEW stClientView{};

    if(ClientView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }

    PREMOTE_PORT_VIEW ServerView{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    REMOTE_PORT_VIEW stServerView{};

    if(ServerView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }

    PULONG MaxMessageLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &MaxMessageLength, sizeof(MaxMessageLength));

    ULONG rlMaxMessageLength{};

    if(MaxMessageLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }

    PVOID ConnectionInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ConnectionInformation, sizeof(ConnectionInformation));

    PULONG ConnectionInformationLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    ULONG rlConnectionInformationLength{};

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }


    NTSTATUS NtConnectPortResult = NtConnectPort((PHANDLE)dpPortHandle,(PUNICODE_STRING)&stPortName,(PSECURITY_QUALITY_OF_SERVICE)&stSecurityQos,(PPORT_VIEW)&stClientView,(PREMOTE_PORT_VIEW)&stServerView,(PULONG)&rlMaxMessageLength,(PVOID)&ConnectionInformation,(PULONG)&rlConnectionInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_mem_write(uc, (DWORD_PTR)PortName, &stPortName.Length, sizeof(stPortName.Length));
    uc_mem_write(uc, (DWORD_PTR)PortName+16, &stPortName.MaximumLength, sizeof(stPortName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, stPortName.Buffer, true, stPortName.Length)) { printf("Error when read PortName in NtConnectPort"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityQos);

    if(SecurityQos != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientView);

    if(ClientView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    if(ServerView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &MaxMessageLength, sizeof(MaxMessageLength));

    if(MaxMessageLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ConnectionInformation, sizeof(ConnectionInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSecureConnectPort(
    OUT            PHANDLE                       PortHandle                   ,
    IN             PUNICODE_STRING               PortName                     ,
    IN             PSECURITY_QUALITY_OF_SERVICE  SecurityQos                  ,
    INOUTOPTIONAL  PPORT_VIEW                    ClientView                   ,
    INOPTIONAL     PSID                          RequiredServerSid            ,
    INOUTOPTIONAL  PREMOTE_PORT_VIEW             ServerView                   ,
    OUTOPTIONAL    PULONG                        MaxMessageLength             ,
    INOUTOPTIONAL  PVOID                         ConnectionInformation        ,
    INOUTOPTIONAL  PULONG                        ConnectionInformationLength  );

*/
void EmuApi::EmuNtSecureConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    PUNICODE_STRING PortName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortName);

    std::wstring rlwPortName;

    USHORT rlLengthPortName;

    USHORT rlMaxLengthPortName;
    uc_mem_read(uc, (DWORD_PTR)PortName, &rlLengthPortName, sizeof(rlLengthPortName));
    uc_mem_read(uc, (DWORD_PTR)PortName+16, &rlMaxLengthPortName, sizeof(rlMaxLengthPortName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, rlwPortName, true, rlLengthPortName)) { printf("Error when read PortName in NtSecureConnectPort"); _CrtDbgBreak(); }

    UNICODE_STRING stPortName{};
    stPortName.Length = rlLengthPortName;
    stPortName.MaximumLength = rlMaxLengthPortName;
    stPortName.Buffer = rlwPortName.data();

    PSECURITY_QUALITY_OF_SERVICE SecurityQos{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityQos);

    SECURITY_QUALITY_OF_SERVICE stSecurityQos{};

    if(SecurityQos != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }

    PPORT_VIEW ClientView{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientView);

    PORT_VIEW stClientView{};

    if(ClientView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }

    PSID RequiredServerSid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RequiredServerSid, sizeof(RequiredServerSid));

    PREMOTE_PORT_VIEW ServerView{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ServerView, sizeof(ServerView));

    REMOTE_PORT_VIEW stServerView{};

    if(ServerView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }

    PULONG MaxMessageLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &MaxMessageLength, sizeof(MaxMessageLength));

    ULONG rlMaxMessageLength{};

    if(MaxMessageLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }

    PVOID ConnectionInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ConnectionInformation, sizeof(ConnectionInformation));

    PULONG ConnectionInformationLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    ULONG rlConnectionInformationLength{};

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }


    NTSTATUS NtSecureConnectPortResult = NtSecureConnectPort((PHANDLE)dpPortHandle,(PUNICODE_STRING)&stPortName,(PSECURITY_QUALITY_OF_SERVICE)&stSecurityQos,(PPORT_VIEW)&stClientView,(PSID)&RequiredServerSid,(PREMOTE_PORT_VIEW)&stServerView,(PULONG)&rlMaxMessageLength,(PVOID)&ConnectionInformation,(PULONG)&rlConnectionInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSecureConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_mem_write(uc, (DWORD_PTR)PortName, &stPortName.Length, sizeof(stPortName.Length));
    uc_mem_write(uc, (DWORD_PTR)PortName+16, &stPortName.MaximumLength, sizeof(stPortName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, stPortName.Buffer, true, stPortName.Length)) { printf("Error when read PortName in NtSecureConnectPort"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityQos);

    if(SecurityQos != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientView);

    if(ClientView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RequiredServerSid, sizeof(RequiredServerSid));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ServerView, sizeof(ServerView));

    if(ServerView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &MaxMessageLength, sizeof(MaxMessageLength));

    if(MaxMessageLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ConnectionInformation, sizeof(ConnectionInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSecureConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtListenPort(
    IN   HANDLE         PortHandle         ,
    OUT  PPORT_MESSAGE  ConnectionRequest  );

*/
void EmuApi::EmuNtListenPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE ConnectionRequest{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ConnectionRequest);

    PORT_MESSAGE stConnectionRequest{};

    if(ConnectionRequest != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }


    NTSTATUS NtListenPortResult = NtListenPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stConnectionRequest);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtListenPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ConnectionRequest);

    if(ConnectionRequest != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtListenPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAcceptConnectPort(
    OUT            PHANDLE            PortHandle         ,
    INOPTIONAL     PVOID              PortContext        ,
    IN             PPORT_MESSAGE      ConnectionRequest  ,
    IN             BOOLEAN            AcceptConnection   ,
    INOUTOPTIONAL  PPORT_VIEW         ServerView         ,
    OUTOPTIONAL    PREMOTE_PORT_VIEW  ClientView         );

*/
void EmuApi::EmuNtAcceptConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    PVOID PortContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortContext);

    PPORT_MESSAGE ConnectionRequest{};
    uc_reg_read(uc, UC_X86_REG_R8, &ConnectionRequest);

    PORT_MESSAGE stConnectionRequest{};

    if(ConnectionRequest != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }

    BOOLEAN AcceptConnection{};
    uc_reg_read(uc, UC_X86_REG_R9B, &AcceptConnection);

    PPORT_VIEW ServerView{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    PORT_VIEW stServerView{};

    if(ServerView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }

    PREMOTE_PORT_VIEW ClientView{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ClientView, sizeof(ClientView));

    REMOTE_PORT_VIEW stClientView{};

    if(ClientView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }


    NTSTATUS NtAcceptConnectPortResult = NtAcceptConnectPort((PHANDLE)dpPortHandle,(PVOID)&PortContext,(PPORT_MESSAGE)&stConnectionRequest,(BOOLEAN)AcceptConnection,(PPORT_VIEW)&stServerView,(PREMOTE_PORT_VIEW)&stClientView);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAcceptConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PortContext);
    uc_reg_write(uc, UC_X86_REG_R8, &ConnectionRequest);

    if(ConnectionRequest != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &AcceptConnection);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    if(ServerView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ClientView, sizeof(ClientView));

    if(ClientView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAcceptConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCompleteConnectPort(
    IN  HANDLE  PortHandle  );

*/
void EmuApi::EmuNtCompleteConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);


    NTSTATUS NtCompleteConnectPortResult = NtCompleteConnectPort((HANDLE)PortHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCompleteConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCompleteConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRequestPort(
    IN  HANDLE         PortHandle      ,
    IN  PPORT_MESSAGE  RequestMessage  );

*/
void EmuApi::EmuNtRequestPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE RequestMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RequestMessage);

    PORT_MESSAGE stRequestMessage{};

    if(RequestMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }


    NTSTATUS NtRequestPortResult = NtRequestPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stRequestMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRequestPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &RequestMessage);

    if(RequestMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRequestPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRequestWaitReplyPort(
    IN   HANDLE         PortHandle      ,
    IN   PPORT_MESSAGE  RequestMessage  ,
    OUT  PPORT_MESSAGE  ReplyMessage    );

*/
void EmuApi::EmuNtRequestWaitReplyPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE RequestMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RequestMessage);

    PORT_MESSAGE stRequestMessage{};

    if(RequestMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }


    NTSTATUS NtRequestWaitReplyPortResult = NtRequestWaitReplyPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stRequestMessage,(PPORT_MESSAGE)&stReplyMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRequestWaitReplyPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &RequestMessage);

    if(RequestMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRequestWaitReplyPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReplyPort(
    IN  HANDLE         PortHandle    ,
    IN  PPORT_MESSAGE  ReplyMessage  );

*/
void EmuApi::EmuNtReplyPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }


    NTSTATUS NtReplyPortResult = NtReplyPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stReplyMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReplyPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReplyPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReplyWaitReplyPort(
    IN     HANDLE         PortHandle    ,
    INOUT  PPORT_MESSAGE  ReplyMessage  );

*/
void EmuApi::EmuNtReplyWaitReplyPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }


    NTSTATUS NtReplyWaitReplyPortResult = NtReplyWaitReplyPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stReplyMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReplyWaitReplyPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReplyWaitReplyPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReplyWaitReceivePort(
    IN           HANDLE         PortHandle      ,
    OUTOPTIONAL  PVOID *        PortContext     ,
    INOPTIONAL   PPORT_MESSAGE  ReplyMessage    ,
    OUT          PPORT_MESSAGE  ReceiveMessage  );

*/
void EmuApi::EmuNtReplyWaitReceivePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PVOID * PortContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortContext);

    PVOID * dpPortContext{};

    if(PortContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }

    PPORT_MESSAGE ReceiveMessage{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReceiveMessage);

    PORT_MESSAGE stReceiveMessage{};

    if(ReceiveMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }


    NTSTATUS NtReplyWaitReceivePortResult = NtReplyWaitReceivePort((HANDLE)PortHandle,(PVOID *)&dpPortContext,(PPORT_MESSAGE)&stReplyMessage,(PPORT_MESSAGE)&stReceiveMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReplyWaitReceivePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PortContext);

    if(PortContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ReceiveMessage);

    if(ReceiveMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReplyWaitReceivePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReplyWaitReceivePortEx(
    IN           HANDLE          PortHandle      ,
    OUTOPTIONAL  PVOID *         PortContext     ,
    INOPTIONAL   PPORT_MESSAGE   ReplyMessage    ,
    OUT          PPORT_MESSAGE   ReceiveMessage  ,
    INOPTIONAL   PLARGE_INTEGER  Timeout         );

*/
void EmuApi::EmuNtReplyWaitReceivePortEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PVOID * PortContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortContext);

    PVOID * dpPortContext{};

    if(PortContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }

    PPORT_MESSAGE ReceiveMessage{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReceiveMessage);

    PORT_MESSAGE stReceiveMessage{};

    if(ReceiveMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtReplyWaitReceivePortExResult = NtReplyWaitReceivePortEx((HANDLE)PortHandle,(PVOID *)&dpPortContext,(PPORT_MESSAGE)&stReplyMessage,(PPORT_MESSAGE)&stReceiveMessage,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReplyWaitReceivePortExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PortContext);

    if(PortContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ReceiveMessage);

    if(ReceiveMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReplyWaitReceivePortEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtImpersonateClientOfPort(
    IN  HANDLE         PortHandle  ,
    IN  PPORT_MESSAGE  Message     );

*/
void EmuApi::EmuNtImpersonateClientOfPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE Message{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Message);

    PORT_MESSAGE stMessage{};

    if(Message != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }


    NTSTATUS NtImpersonateClientOfPortResult = NtImpersonateClientOfPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtImpersonateClientOfPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Message);

    if(Message != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtImpersonateClientOfPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReadRequestData(
    IN           HANDLE         PortHandle         ,
    IN           PPORT_MESSAGE  Message            ,
    IN           ULONG          DataEntryIndex     ,
    OUT          PVOID          Buffer             ,
    IN           SIZE_T         BufferSize         ,
    OUTOPTIONAL  PSIZE_T        NumberOfBytesRead  );

*/
void EmuApi::EmuNtReadRequestData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE Message{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Message);

    PORT_MESSAGE stMessage{};

    if(Message != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }

    ULONG DataEntryIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DataEntryIndex);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);

    SIZE_T BufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));

    PSIZE_T NumberOfBytesRead{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    ULONG_PTR rlNumberOfBytesRead{};

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }


    NTSTATUS NtReadRequestDataResult = NtReadRequestData((HANDLE)PortHandle,(PPORT_MESSAGE)&stMessage,(ULONG)DataEntryIndex,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesRead);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReadRequestDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Message);

    if(Message != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &DataEntryIndex);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReadRequestData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWriteRequestData(
    IN           HANDLE         PortHandle            ,
    IN           PPORT_MESSAGE  Message               ,
    IN           ULONG          DataEntryIndex        ,
    IN           PVOID          Buffer                ,
    IN           SIZE_T         BufferSize            ,
    OUTOPTIONAL  PSIZE_T        NumberOfBytesWritten  );

*/
void EmuApi::EmuNtWriteRequestData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE Message{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Message);

    PORT_MESSAGE stMessage{};

    if(Message != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }

    ULONG DataEntryIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DataEntryIndex);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);

    SIZE_T BufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));

    PSIZE_T NumberOfBytesWritten{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    ULONG_PTR rlNumberOfBytesWritten{};

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }


    NTSTATUS NtWriteRequestDataResult = NtWriteRequestData((HANDLE)PortHandle,(PPORT_MESSAGE)&stMessage,(ULONG)DataEntryIndex,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesWritten);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWriteRequestDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Message);

    if(Message != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &DataEntryIndex);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWriteRequestData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationPort(
    IN           HANDLE                  PortHandle            ,
    IN           PORT_INFORMATION_CLASS  PortInformationClass  ,
    OUT          PVOID                   PortInformation       ,
    IN           ULONG                   Length                ,
    OUTOPTIONAL  PULONG                  ReturnLength          );

*/
void EmuApi::EmuNtQueryInformationPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PORT_INFORMATION_CLASS PortInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &PortInformationClass);

    PVOID PortInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &PortInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryInformationPortResult = NtQueryInformationPort((HANDLE)PortHandle,(PORT_INFORMATION_CLASS)PortInformationClass,(PVOID)&PortInformation,(ULONG)Length,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &PortInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &PortInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateSection(
    OUT         PHANDLE             SectionHandle          ,
    IN          ACCESS_MASK         DesiredAccess          ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes       ,
    INOPTIONAL  PLARGE_INTEGER      MaximumSize            ,
    IN          ULONG               SectionPageProtection  ,
    IN          ULONG               AllocationAttributes   ,
    INOPTIONAL  HANDLE              FileHandle             );

*/
void EmuApi::EmuNtCreateSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    HANDLE dpSectionHandle{};

    if(SectionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PLARGE_INTEGER MaximumSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &MaximumSize);

    LARGE_INTEGER rlMaximumSize{};

    if(MaximumSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }

    ULONG SectionPageProtection{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SectionPageProtection, sizeof(SectionPageProtection));

    ULONG AllocationAttributes{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AllocationAttributes, sizeof(AllocationAttributes));

    HANDLE FileHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &FileHandle, sizeof(FileHandle));


    NTSTATUS NtCreateSectionResult = NtCreateSection((PHANDLE)dpSectionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PLARGE_INTEGER)&rlMaximumSize,(ULONG)SectionPageProtection,(ULONG)AllocationAttributes,(HANDLE)FileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);

    if(SectionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &MaximumSize);

    if(MaximumSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SectionPageProtection, sizeof(SectionPageProtection));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AllocationAttributes, sizeof(AllocationAttributes));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &FileHandle, sizeof(FileHandle));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenSection(
    OUT  PHANDLE             SectionHandle     ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    HANDLE dpSectionHandle{};

    if(SectionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenSectionResult = NtOpenSection((PHANDLE)dpSectionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);

    if(SectionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtMapViewOfSection(
    IN             HANDLE           SectionHandle       ,
    IN             HANDLE           ProcessHandle       ,
    INOUT          PVOID *          BaseAddress         ,
    IN             ULONG_PTR        ZeroBits            ,
    IN             SIZE_T           CommitSize          ,
    INOUTOPTIONAL  PLARGE_INTEGER   SectionOffset       ,
    INOUT          PSIZE_T          ViewSize            ,
    IN             SECTION_INHERIT  InheritDisposition  ,
    IN             ULONG            AllocationType      ,
    IN             ULONG            Win32Protect        );

*/
void EmuApi::EmuNtMapViewOfSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    ULONG_PTR ZeroBits{};
    uc_reg_read(uc, UC_X86_REG_R9, &ZeroBits);

    SIZE_T CommitSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CommitSize, sizeof(CommitSize));

    PLARGE_INTEGER SectionOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SectionOffset, sizeof(SectionOffset));

    LARGE_INTEGER rlSectionOffset{};

    if(SectionOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SectionOffset, &rlSectionOffset, sizeof(rlSectionOffset));
    }

    PSIZE_T ViewSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ViewSize, sizeof(ViewSize));

    ULONG_PTR rlViewSize{};

    if(ViewSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ViewSize, &rlViewSize, sizeof(rlViewSize));
    }

    SECTION_INHERIT InheritDisposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &InheritDisposition, sizeof(InheritDisposition));

    ULONG AllocationType{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &AllocationType, sizeof(AllocationType));

    ULONG Win32Protect{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Win32Protect, sizeof(Win32Protect));


    NTSTATUS NtMapViewOfSectionResult = NtMapViewOfSection((HANDLE)SectionHandle,(HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(ULONG_PTR)ZeroBits,(SIZE_T)CommitSize,(PLARGE_INTEGER)&rlSectionOffset,(PSIZE_T)&rlViewSize,(SECTION_INHERIT)InheritDisposition,(ULONG)AllocationType,(ULONG)Win32Protect);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtMapViewOfSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ZeroBits);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CommitSize, sizeof(CommitSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SectionOffset, sizeof(SectionOffset));

    if(SectionOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SectionOffset, &rlSectionOffset, sizeof(rlSectionOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ViewSize, sizeof(ViewSize));

    if(ViewSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ViewSize, &rlViewSize, sizeof(rlViewSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &InheritDisposition, sizeof(InheritDisposition));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &AllocationType, sizeof(AllocationType));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Win32Protect, sizeof(Win32Protect));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtMapViewOfSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnmapViewOfSection(
    IN  HANDLE  ProcessHandle  ,
    IN  PVOID   BaseAddress    );

*/
void EmuApi::EmuNtUnmapViewOfSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);


    NTSTATUS NtUnmapViewOfSectionResult = NtUnmapViewOfSection((HANDLE)ProcessHandle,(PVOID)&BaseAddress);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnmapViewOfSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnmapViewOfSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtExtendSection(
    IN     HANDLE          SectionHandle   ,
    INOUT  PLARGE_INTEGER  NewSectionSize  );

*/
void EmuApi::EmuNtExtendSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    PLARGE_INTEGER NewSectionSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NewSectionSize);

    LARGE_INTEGER rlNewSectionSize{};

    if(NewSectionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewSectionSize, &rlNewSectionSize, sizeof(rlNewSectionSize));
    }


    NTSTATUS NtExtendSectionResult = NtExtendSection((HANDLE)SectionHandle,(PLARGE_INTEGER)&rlNewSectionSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtExtendSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &NewSectionSize);

    if(NewSectionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewSectionSize, &rlNewSectionSize, sizeof(rlNewSectionSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtExtendSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAreMappedFilesTheSame(
    IN  PVOID  File1MappedAsAnImage  ,
    IN  PVOID  File2MappedAsFile     );

*/
void EmuApi::EmuNtAreMappedFilesTheSame(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID File1MappedAsAnImage{};
    uc_reg_read(uc, UC_X86_REG_RCX, &File1MappedAsAnImage);

    PVOID File2MappedAsFile{};
    uc_reg_read(uc, UC_X86_REG_RDX, &File2MappedAsFile);


    NTSTATUS NtAreMappedFilesTheSameResult = NtAreMappedFilesTheSame((PVOID)&File1MappedAsAnImage,(PVOID)&File2MappedAsFile);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAreMappedFilesTheSameResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &File1MappedAsAnImage);
    uc_reg_write(uc, UC_X86_REG_RDX, &File2MappedAsFile);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAreMappedFilesTheSame\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAllocateVirtualMemory(
    IN     HANDLE     ProcessHandle   ,
    INOUT  PVOID *    BaseAddress     ,
    IN     ULONG_PTR  ZeroBits        ,
    INOUT  PSIZE_T    RegionSize      ,
    IN     ULONG      AllocationType  ,
    IN     ULONG      Protect         );

*/
void EmuApi::EmuNtAllocateVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    ULONG_PTR ZeroBits{};
    uc_reg_read(uc, UC_X86_REG_R8, &ZeroBits);

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG AllocationType{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AllocationType, sizeof(AllocationType));

    ULONG Protect{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Protect, sizeof(Protect));


    NTSTATUS NtAllocateVirtualMemoryResult = NtAllocateVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(ULONG_PTR)ZeroBits,(PSIZE_T)&rlRegionSize,(ULONG)AllocationType,(ULONG)Protect);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAllocateVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ZeroBits);
    uc_reg_write(uc, UC_X86_REG_R9, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AllocationType, sizeof(AllocationType));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Protect, sizeof(Protect));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAllocateVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFreeVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    FreeType       );

*/
void EmuApi::EmuNtFreeVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG FreeType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &FreeType);


    NTSTATUS NtFreeVirtualMemoryResult = NtFreeVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)FreeType);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFreeVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &FreeType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFreeVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReadVirtualMemory(
    IN           HANDLE   ProcessHandle      ,
    INOPTIONAL   PVOID    BaseAddress        ,
    OUT          PVOID    Buffer             ,
    IN           SIZE_T   BufferSize         ,
    OUTOPTIONAL  PSIZE_T  NumberOfBytesRead  );

*/
void EmuApi::EmuNtReadVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    SIZE_T BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &BufferSize);

    PSIZE_T NumberOfBytesRead{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    ULONG_PTR rlNumberOfBytesRead{};

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }


    NTSTATUS NtReadVirtualMemoryResult = NtReadVirtualMemory((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesRead);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReadVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9, &BufferSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReadVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWriteVirtualMemory(
    IN                     HANDLE        ProcessHandle         ,
    INOPTIONAL             PVOID         BaseAddress           ,
                           const void *  Buffer                ,
    INCONSTVOID*Buffer,IN  SIZE_T        BufferSize            ,
    OUTOPTIONAL            PSIZE_T       NumberOfBytesWritten  );

*/
void EmuApi::EmuNtWriteVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    SIZE_T BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &BufferSize);

    PSIZE_T NumberOfBytesWritten{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    ULONG_PTR rlNumberOfBytesWritten{};

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }


    NTSTATUS NtWriteVirtualMemoryResult = NtWriteVirtualMemory((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesWritten);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWriteVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9, &BufferSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWriteVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFlushVirtualMemory(
    IN     HANDLE            ProcessHandle  ,
    INOUT  PVOID *           BaseAddress    ,
    INOUT  PSIZE_T           RegionSize     ,
    OUT    PIO_STATUS_BLOCK  IoStatus       );

*/
void EmuApi::EmuNtFlushVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    PIO_STATUS_BLOCK IoStatus{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatus);

    IO_STATUS_BLOCK stIoStatus{};

    if(IoStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatus, &stIoStatus, sizeof(stIoStatus));
    }


    NTSTATUS NtFlushVirtualMemoryResult = NtFlushVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(PIO_STATUS_BLOCK)&stIoStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFlushVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatus);

    if(IoStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatus, &stIoStatus, sizeof(stIoStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFlushVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtLockVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    MapType        );

*/
void EmuApi::EmuNtLockVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG MapType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MapType);


    NTSTATUS NtLockVirtualMemoryResult = NtLockVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)MapType);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtLockVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &MapType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtLockVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnlockVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    MapType        );

*/
void EmuApi::EmuNtUnlockVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG MapType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MapType);


    NTSTATUS NtUnlockVirtualMemoryResult = NtUnlockVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)MapType);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnlockVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &MapType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnlockVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtProtectVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    NewProtect     ,
    OUT    PULONG   OldProtect     );

*/
void EmuApi::EmuNtProtectVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG NewProtect{};
    uc_reg_read(uc, UC_X86_REG_R9D, &NewProtect);

    PULONG OldProtect{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &OldProtect, sizeof(OldProtect));

    ULONG rlOldProtect{};

    if(OldProtect != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldProtect, &rlOldProtect, sizeof(rlOldProtect));
    }


    NTSTATUS NtProtectVirtualMemoryResult = NtProtectVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)NewProtect,(PULONG)&rlOldProtect);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtProtectVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &NewProtect);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &OldProtect, sizeof(OldProtect));

    if(OldProtect != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldProtect, &rlOldProtect, sizeof(rlOldProtect));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtProtectVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryVirtualMemory(
    IN           HANDLE                    ProcessHandle            ,
    IN           PVOID                     BaseAddress              ,
    IN           MEMORY_INFORMATION_CLASS  MemoryInformationClass   ,
    OUT          PVOID                     MemoryInformation        ,
    IN           SIZE_T                    MemoryInformationLength  ,
    OUTOPTIONAL  PSIZE_T                   ReturnLength             );

*/
void EmuApi::EmuNtQueryVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    MEMORY_INFORMATION_CLASS MemoryInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MemoryInformationClass);

    PVOID MemoryInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &MemoryInformation);

    SIZE_T MemoryInformationLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MemoryInformationLength, sizeof(MemoryInformationLength));

    PSIZE_T ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG_PTR rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryVirtualMemoryResult = NtQueryVirtualMemory((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(MEMORY_INFORMATION_CLASS)MemoryInformationClass,(PVOID)&MemoryInformation,(SIZE_T)MemoryInformationLength,(PSIZE_T)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8D, &MemoryInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &MemoryInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MemoryInformationLength, sizeof(MemoryInformationLength));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySection(
    IN           HANDLE                     SectionHandle             ,
    IN           SECTION_INFORMATION_CLASS  SectionInformationClass   ,
    OUT          PVOID                      SectionInformation        ,
    IN           SIZE_T                     SectionInformationLength  ,
    OUTOPTIONAL  PSIZE_T                    ReturnLength              );

*/
void EmuApi::EmuNtQuerySection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    SECTION_INFORMATION_CLASS SectionInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SectionInformationClass);

    PVOID SectionInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &SectionInformation);

    SIZE_T SectionInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &SectionInformationLength);

    PSIZE_T ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG_PTR rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQuerySectionResult = NtQuerySection((HANDLE)SectionHandle,(SECTION_INFORMATION_CLASS)SectionInformationClass,(PVOID)&SectionInformation,(SIZE_T)SectionInformationLength,(PSIZE_T)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SectionInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &SectionInformation);
    uc_reg_write(uc, UC_X86_REG_R9, &SectionInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtMapUserPhysicalPages(
    IN          PVOID       VirtualAddress  ,
    IN          ULONG_PTR   NumberOfPages   ,
    INOPTIONAL  PULONG_PTR  UserPfnArray    );

*/
void EmuApi::EmuNtMapUserPhysicalPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID VirtualAddress{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VirtualAddress);

    ULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS NtMapUserPhysicalPagesResult = NtMapUserPhysicalPages((PVOID)&VirtualAddress,(ULONG_PTR)NumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtMapUserPhysicalPagesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &VirtualAddress);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtMapUserPhysicalPages\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtMapUserPhysicalPagesScatter(
    IN          PVOID *     VirtualAddresses  ,
    IN          ULONG_PTR   NumberOfPages     ,
    INOPTIONAL  PULONG_PTR  UserPfnArray      );

*/
void EmuApi::EmuNtMapUserPhysicalPagesScatter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * VirtualAddresses{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VirtualAddresses);

    PVOID * dpVirtualAddresses{};

    if(VirtualAddresses != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VirtualAddresses, &dpVirtualAddresses, sizeof(dpVirtualAddresses));
    }

    ULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS NtMapUserPhysicalPagesScatterResult = NtMapUserPhysicalPagesScatter((PVOID *)&dpVirtualAddresses,(ULONG_PTR)NumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtMapUserPhysicalPagesScatterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &VirtualAddresses);

    if(VirtualAddresses != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VirtualAddresses, &dpVirtualAddresses, sizeof(dpVirtualAddresses));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtMapUserPhysicalPagesScatter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAllocateUserPhysicalPages(
    IN     HANDLE      ProcessHandle  ,
    INOUT  PULONG_PTR  NumberOfPages  ,
    OUT    PULONG_PTR  UserPfnArray   );

*/
void EmuApi::EmuNtAllocateUserPhysicalPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    unsigned long long rlNumberOfPages{};

    if(NumberOfPages != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS NtAllocateUserPhysicalPagesResult = NtAllocateUserPhysicalPages((HANDLE)ProcessHandle,(PULONG_PTR)&rlNumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAllocateUserPhysicalPagesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);

    if(NumberOfPages != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAllocateUserPhysicalPages\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFreeUserPhysicalPages(
    IN     HANDLE      ProcessHandle  ,
    INOUT  PULONG_PTR  NumberOfPages  ,
    IN     PULONG_PTR  UserPfnArray   );

*/
void EmuApi::EmuNtFreeUserPhysicalPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    unsigned long long rlNumberOfPages{};

    if(NumberOfPages != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS NtFreeUserPhysicalPagesResult = NtFreeUserPhysicalPages((HANDLE)ProcessHandle,(PULONG_PTR)&rlNumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFreeUserPhysicalPagesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);

    if(NumberOfPages != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFreeUserPhysicalPages\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtGetWriteWatch(
    IN     HANDLE      ProcessHandle              ,
    IN     ULONG       Flags                      ,
    IN     PVOID       BaseAddress                ,
    IN     SIZE_T      RegionSize                 ,
    OUT    PVOID *     UserAddressArray           ,
    INOUT  PULONG_PTR  EntriesInUserAddressArray  ,
    OUT    PULONG      Granularity                );

*/
void EmuApi::EmuNtGetWriteWatch(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    SIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &RegionSize);

    PVOID * UserAddressArray{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &UserAddressArray, sizeof(UserAddressArray));

    PVOID * dpUserAddressArray{};

    if(UserAddressArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserAddressArray, &dpUserAddressArray, sizeof(dpUserAddressArray));
    }

    PULONG_PTR EntriesInUserAddressArray{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &EntriesInUserAddressArray, sizeof(EntriesInUserAddressArray));

    unsigned long long rlEntriesInUserAddressArray{};

    if(EntriesInUserAddressArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EntriesInUserAddressArray, &rlEntriesInUserAddressArray, sizeof(rlEntriesInUserAddressArray));
    }

    PULONG Granularity{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Granularity, sizeof(Granularity));

    ULONG rlGranularity{};

    if(Granularity != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Granularity, &rlGranularity, sizeof(rlGranularity));
    }


    NTSTATUS NtGetWriteWatchResult = NtGetWriteWatch((HANDLE)ProcessHandle,(ULONG)Flags,(PVOID)&BaseAddress,(SIZE_T)RegionSize,(PVOID *)&dpUserAddressArray,(PULONG_PTR)&rlEntriesInUserAddressArray,(PULONG)&rlGranularity);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtGetWriteWatchResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R9, &RegionSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &UserAddressArray, sizeof(UserAddressArray));

    if(UserAddressArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserAddressArray, &dpUserAddressArray, sizeof(dpUserAddressArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &EntriesInUserAddressArray, sizeof(EntriesInUserAddressArray));

    if(EntriesInUserAddressArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EntriesInUserAddressArray, &rlEntriesInUserAddressArray, sizeof(rlEntriesInUserAddressArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Granularity, sizeof(Granularity));

    if(Granularity != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Granularity, &rlGranularity, sizeof(rlGranularity));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtGetWriteWatch\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtResetWriteWatch(
    IN  HANDLE  ProcessHandle  ,
    IN  PVOID   BaseAddress    ,
    IN  SIZE_T  RegionSize     );

*/
void EmuApi::EmuNtResetWriteWatch(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    SIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);


    NTSTATUS NtResetWriteWatchResult = NtResetWriteWatch((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(SIZE_T)RegionSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtResetWriteWatchResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtResetWriteWatch\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreatePagingFile(
    IN  PUNICODE_STRING  PageFileName  ,
    IN  PLARGE_INTEGER   MinimumSize   ,
    IN  PLARGE_INTEGER   MaximumSize   ,
    IN  ULONG            Priority      );

*/
void EmuApi::EmuNtCreatePagingFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING PageFileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PageFileName);

    std::wstring rlwPageFileName;

    USHORT rlLengthPageFileName;

    USHORT rlMaxLengthPageFileName;
    uc_mem_read(uc, (DWORD_PTR)PageFileName, &rlLengthPageFileName, sizeof(rlLengthPageFileName));
    uc_mem_read(uc, (DWORD_PTR)PageFileName+16, &rlMaxLengthPageFileName, sizeof(rlMaxLengthPageFileName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PageFileName+64, rlwPageFileName, true, rlLengthPageFileName)) { printf("Error when read PageFileName in NtCreatePagingFile"); _CrtDbgBreak(); }

    UNICODE_STRING stPageFileName{};
    stPageFileName.Length = rlLengthPageFileName;
    stPageFileName.MaximumLength = rlMaxLengthPageFileName;
    stPageFileName.Buffer = rlwPageFileName.data();

    PLARGE_INTEGER MinimumSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &MinimumSize);

    LARGE_INTEGER rlMinimumSize{};

    if(MinimumSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MinimumSize, &rlMinimumSize, sizeof(rlMinimumSize));
    }

    PLARGE_INTEGER MaximumSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &MaximumSize);

    LARGE_INTEGER rlMaximumSize{};

    if(MaximumSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }

    ULONG Priority{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Priority);


    NTSTATUS NtCreatePagingFileResult = NtCreatePagingFile((PUNICODE_STRING)&stPageFileName,(PLARGE_INTEGER)&rlMinimumSize,(PLARGE_INTEGER)&rlMaximumSize,(ULONG)Priority);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreatePagingFileResult);
    uc_mem_write(uc, (DWORD_PTR)PageFileName, &stPageFileName.Length, sizeof(stPageFileName.Length));
    uc_mem_write(uc, (DWORD_PTR)PageFileName+16, &stPageFileName.MaximumLength, sizeof(stPageFileName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PageFileName+64, stPageFileName.Buffer, true, stPageFileName.Length)) { printf("Error when read PageFileName in NtCreatePagingFile"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &MinimumSize);

    if(MinimumSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MinimumSize, &rlMinimumSize, sizeof(rlMinimumSize));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &MaximumSize);

    if(MaximumSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &Priority);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreatePagingFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFlushInstructionCache(
    IN          HANDLE  ProcessHandle  ,
    INOPTIONAL  PVOID   BaseAddress    ,
    IN          SIZE_T  Length         );

*/
void EmuApi::EmuNtFlushInstructionCache(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    SIZE_T Length{};
    uc_reg_read(uc, UC_X86_REG_R8, &Length);


    NTSTATUS NtFlushInstructionCacheResult = NtFlushInstructionCache((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(SIZE_T)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFlushInstructionCacheResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFlushInstructionCache\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFlushWriteBuffer(VOID);

*/
void EmuApi::EmuNtFlushWriteBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS NtFlushWriteBufferResult = NtFlushWriteBuffer();


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFlushWriteBufferResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFlushWriteBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryObject(
    IN   HANDLE                    Handle                   ,
    IN   OBJECT_INFORMATION_CLASS  ObjectInformationClass   ,
    OUT  PVOID                     ObjectInformation        ,
    IN   ULONG                     ObjectInformationLength  ,
    OUT  PULONG                    ReturnLength             );

*/
void EmuApi::EmuNtQueryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    OBJECT_INFORMATION_CLASS ObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ObjectInformationClass);

    PVOID ObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectInformation);

    ULONG ObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ObjectInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryObjectResult = NtQueryObject((HANDLE)Handle,(OBJECT_INFORMATION_CLASS)ObjectInformationClass,(PVOID)&ObjectInformation,(ULONG)ObjectInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ObjectInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationObject(
    IN  HANDLE                    Handle                   ,
    IN  OBJECT_INFORMATION_CLASS  ObjectInformationClass   ,
    IN  PVOID                     ObjectInformation        ,
    IN  ULONG                     ObjectInformationLength  );

*/
void EmuApi::EmuNtSetInformationObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    OBJECT_INFORMATION_CLASS ObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ObjectInformationClass);

    PVOID ObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectInformation);

    ULONG ObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ObjectInformationLength);


    NTSTATUS NtSetInformationObjectResult = NtSetInformationObject((HANDLE)Handle,(OBJECT_INFORMATION_CLASS)ObjectInformationClass,(PVOID)&ObjectInformation,(ULONG)ObjectInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ObjectInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDuplicateObject(
    IN          HANDLE       SourceProcessHandle  ,
    IN          HANDLE       SourceHandle         ,
    INOPTIONAL  HANDLE       TargetProcessHandle  ,
    OUT         PHANDLE      TargetHandle         ,
    IN          ACCESS_MASK  DesiredAccess        ,
    IN          ULONG        HandleAttributes     ,
    IN          ULONG        Options              );

*/
void EmuApi::EmuNtDuplicateObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SourceProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SourceProcessHandle);

    HANDLE SourceHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceHandle);

    HANDLE TargetProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &TargetProcessHandle);

    HANDLE TargetHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TargetHandle);

    HANDLE dpTargetHandle{};

    if(TargetHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetHandle, &dpTargetHandle, sizeof(dpTargetHandle));
    }

    ACCESS_MASK DesiredAccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &DesiredAccess, sizeof(DesiredAccess));

    ULONG HandleAttributes{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &HandleAttributes, sizeof(HandleAttributes));

    ULONG Options{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Options, sizeof(Options));


    NTSTATUS NtDuplicateObjectResult = NtDuplicateObject((HANDLE)SourceProcessHandle,(HANDLE)SourceHandle,(HANDLE)TargetProcessHandle,(PHANDLE)dpTargetHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(ULONG)Options);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDuplicateObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SourceProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &TargetProcessHandle);
    uc_reg_write(uc, UC_X86_REG_R9, &TargetHandle);

    if(TargetHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetHandle, &dpTargetHandle, sizeof(dpTargetHandle));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &HandleAttributes, sizeof(HandleAttributes));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Options, sizeof(Options));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDuplicateObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtMakeTemporaryObject(
    IN  HANDLE  Handle  );

*/
void EmuApi::EmuNtMakeTemporaryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    NTSTATUS NtMakeTemporaryObjectResult = NtMakeTemporaryObject((HANDLE)Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtMakeTemporaryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtMakeTemporaryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtMakePermanentObject(
    IN  HANDLE  Handle  );

*/
void EmuApi::EmuNtMakePermanentObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    NTSTATUS NtMakePermanentObjectResult = NtMakePermanentObject((HANDLE)Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtMakePermanentObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtMakePermanentObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSignalAndWaitForSingleObject(
    IN          HANDLE          SignalHandle  ,
    IN          HANDLE          WaitHandle    ,
    IN          BOOLEAN         Alertable     ,
    INOPTIONAL  PLARGE_INTEGER  Timeout       );

*/
void EmuApi::EmuNtSignalAndWaitForSingleObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SignalHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SignalHandle);

    HANDLE WaitHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &WaitHandle);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R9, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtSignalAndWaitForSingleObjectResult = NtSignalAndWaitForSingleObject((HANDLE)SignalHandle,(HANDLE)WaitHandle,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSignalAndWaitForSingleObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SignalHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &WaitHandle);
    uc_reg_write(uc, UC_X86_REG_R8B, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R9, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSignalAndWaitForSingleObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWaitForSingleObject(
    IN          HANDLE          Handle     ,
    IN          BOOLEAN         Alertable  ,
    INOPTIONAL  PLARGE_INTEGER  Timeout    );

*/
void EmuApi::EmuNtWaitForSingleObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_DL, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R8, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtWaitForSingleObjectResult = NtWaitForSingleObject((HANDLE)Handle,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWaitForSingleObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_DL, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R8, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWaitForSingleObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWaitForMultipleObjects(
    IN          ULONG           Count      ,
    IN          HANDLE *        Handles    ,
    IN          WAIT_TYPE       WaitType   ,
    IN          BOOLEAN         Alertable  ,
    INOPTIONAL  PLARGE_INTEGER  Timeout    );

*/
void EmuApi::EmuNtWaitForMultipleObjects(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Count);

    PHANDLE Handles{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handles);

    HANDLE rlHandles{};

    if(Handles != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }

    WAIT_TYPE WaitType{};
    uc_reg_read(uc, UC_X86_REG_R8D, &WaitType);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R9B, &Alertable);

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtWaitForMultipleObjectsResult = NtWaitForMultipleObjects((ULONG)Count,(HANDLE *)rlHandles,(WAIT_TYPE)WaitType,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWaitForMultipleObjectsResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Count);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handles);

    if(Handles != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &WaitType);
    uc_reg_write(uc, UC_X86_REG_R9B, &Alertable);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWaitForMultipleObjects\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtWaitForMultipleObjects32(
    IN          ULONG           Count      ,
    IN          LONG *          Handles    ,
    IN          WAIT_TYPE       WaitType   ,
    IN          BOOLEAN         Alertable  ,
    INOPTIONAL  PLARGE_INTEGER  Timeout    );

*/
void EmuApi::EmuNtWaitForMultipleObjects32(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Count);

    PLONG Handles{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handles);

    LONG rlHandles{};

    if(Handles != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }

    WAIT_TYPE WaitType{};
    uc_reg_read(uc, UC_X86_REG_R8D, &WaitType);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R9B, &Alertable);

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS NtWaitForMultipleObjects32Result = NtWaitForMultipleObjects32((ULONG)Count,(LONG *)&rlHandles,(WAIT_TYPE)WaitType,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtWaitForMultipleObjects32Result);
    uc_reg_write(uc, UC_X86_REG_ECX, &Count);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handles);

    if(Handles != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &WaitType);
    uc_reg_write(uc, UC_X86_REG_R9B, &Alertable);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtWaitForMultipleObjects32\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetSecurityObject(
    IN  HANDLE                Handle               ,
    IN  SECURITY_INFORMATION  SecurityInformation  ,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor   );

*/
void EmuApi::EmuNtSetSecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SecurityInformation);

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityDescriptor);


    NTSTATUS NtSetSecurityObjectResult = NtSetSecurityObject((HANDLE)Handle,(SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&SecurityDescriptor);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetSecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityDescriptor);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetSecurityObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySecurityObject(
    IN   HANDLE                Handle               ,
    IN   SECURITY_INFORMATION  SecurityInformation  ,
    OUT  PSECURITY_DESCRIPTOR  SecurityDescriptor   ,
    IN   ULONG                 Length               ,
    OUT  PULONG                LengthNeeded         );

*/
void EmuApi::EmuNtQuerySecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SecurityInformation);

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityDescriptor);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    PULONG LengthNeeded{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &LengthNeeded, sizeof(LengthNeeded));

    ULONG rlLengthNeeded{};

    if(LengthNeeded != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LengthNeeded, &rlLengthNeeded, sizeof(rlLengthNeeded));
    }


    NTSTATUS NtQuerySecurityObjectResult = NtQuerySecurityObject((HANDLE)Handle,(SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(ULONG)Length,(PULONG)&rlLengthNeeded);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &LengthNeeded, sizeof(LengthNeeded));

    if(LengthNeeded != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LengthNeeded, &rlLengthNeeded, sizeof(rlLengthNeeded));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySecurityObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtClose(
    IN  HANDLE  Handle  );

*/
void EmuApi::EmuNtClose(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    NTSTATUS NtCloseResult = NtClose((HANDLE)Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCloseResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtClose\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateDirectoryObject(
    OUT  PHANDLE             DirectoryHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtCreateDirectoryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DirectoryHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DirectoryHandle);

    HANDLE dpDirectoryHandle{};

    if(DirectoryHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtCreateDirectoryObjectResult = NtCreateDirectoryObject((PHANDLE)dpDirectoryHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateDirectoryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DirectoryHandle);

    if(DirectoryHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateDirectoryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenDirectoryObject(
    OUT  PHANDLE             DirectoryHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenDirectoryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DirectoryHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DirectoryHandle);

    HANDLE dpDirectoryHandle{};

    if(DirectoryHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenDirectoryObjectResult = NtOpenDirectoryObject((PHANDLE)dpDirectoryHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenDirectoryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DirectoryHandle);

    if(DirectoryHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenDirectoryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryDirectoryObject(
    IN     HANDLE   DirectoryHandle    ,
    OUT    PVOID    Buffer             ,
    IN     ULONG    Length             ,
    IN     BOOLEAN  ReturnSingleEntry  ,
    IN     BOOLEAN  RestartScan        ,
    INOUT  PULONG   Context            ,
    OUT    PULONG   ReturnLength       );

*/
void EmuApi::EmuNtQueryDirectoryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DirectoryHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DirectoryHandle);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Length);

    BOOLEAN ReturnSingleEntry{};
    uc_reg_read(uc, UC_X86_REG_R9B, &ReturnSingleEntry);

    BOOLEAN RestartScan{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RestartScan, sizeof(RestartScan));

    PULONG Context{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Context, sizeof(Context));

    ULONG rlContext{};

    if(Context != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Context, &rlContext, sizeof(rlContext));
    }

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryDirectoryObjectResult = NtQueryDirectoryObject((HANDLE)DirectoryHandle,(PVOID)&Buffer,(ULONG)Length,(BOOLEAN)ReturnSingleEntry,(BOOLEAN)RestartScan,(PULONG)&rlContext,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryDirectoryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DirectoryHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &Length);
    uc_reg_write(uc, UC_X86_REG_R9B, &ReturnSingleEntry);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RestartScan, sizeof(RestartScan));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Context, sizeof(Context));

    if(Context != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Context, &rlContext, sizeof(rlContext));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryDirectoryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateSymbolicLinkObject(
    OUT  PHANDLE             LinkHandle        ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN   PUNICODE_STRING     LinkTarget        );

*/
void EmuApi::EmuNtCreateSymbolicLinkObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LinkHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LinkHandle);

    HANDLE dpLinkHandle{};

    if(LinkHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PUNICODE_STRING LinkTarget{};
    uc_reg_read(uc, UC_X86_REG_R9, &LinkTarget);

    std::wstring rlwLinkTarget;

    USHORT rlLengthLinkTarget;

    USHORT rlMaxLengthLinkTarget;
    uc_mem_read(uc, (DWORD_PTR)LinkTarget, &rlLengthLinkTarget, sizeof(rlLengthLinkTarget));
    uc_mem_read(uc, (DWORD_PTR)LinkTarget+16, &rlMaxLengthLinkTarget, sizeof(rlMaxLengthLinkTarget));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, rlwLinkTarget, true, rlLengthLinkTarget)) { printf("Error when read LinkTarget in NtCreateSymbolicLinkObject"); _CrtDbgBreak(); }

    UNICODE_STRING stLinkTarget{};
    stLinkTarget.Length = rlLengthLinkTarget;
    stLinkTarget.MaximumLength = rlMaxLengthLinkTarget;
    stLinkTarget.Buffer = rlwLinkTarget.data();


    NTSTATUS NtCreateSymbolicLinkObjectResult = NtCreateSymbolicLinkObject((PHANDLE)dpLinkHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PUNICODE_STRING)&stLinkTarget);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateSymbolicLinkObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LinkHandle);

    if(LinkHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_mem_write(uc, (DWORD_PTR)LinkTarget, &stLinkTarget.Length, sizeof(stLinkTarget.Length));
    uc_mem_write(uc, (DWORD_PTR)LinkTarget+16, &stLinkTarget.MaximumLength, sizeof(stLinkTarget.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, stLinkTarget.Buffer, true, stLinkTarget.Length)) { printf("Error when read LinkTarget in NtCreateSymbolicLinkObject"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateSymbolicLinkObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenSymbolicLinkObject(
    OUT  PHANDLE             LinkHandle        ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenSymbolicLinkObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LinkHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LinkHandle);

    HANDLE dpLinkHandle{};

    if(LinkHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenSymbolicLinkObjectResult = NtOpenSymbolicLinkObject((PHANDLE)dpLinkHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenSymbolicLinkObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LinkHandle);

    if(LinkHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenSymbolicLinkObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQuerySymbolicLinkObject(
    IN     HANDLE           LinkHandle      ,
    INOUT  PUNICODE_STRING  LinkTarget      ,
    OUT    PULONG           ReturnedLength  );

*/
void EmuApi::EmuNtQuerySymbolicLinkObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LinkHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LinkHandle);

    PUNICODE_STRING LinkTarget{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LinkTarget);

    std::wstring rlwLinkTarget;

    USHORT rlLengthLinkTarget;

    USHORT rlMaxLengthLinkTarget;
    uc_mem_read(uc, (DWORD_PTR)LinkTarget, &rlLengthLinkTarget, sizeof(rlLengthLinkTarget));
    uc_mem_read(uc, (DWORD_PTR)LinkTarget+16, &rlMaxLengthLinkTarget, sizeof(rlMaxLengthLinkTarget));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, rlwLinkTarget, true, rlLengthLinkTarget)) { printf("Error when read LinkTarget in NtQuerySymbolicLinkObject"); _CrtDbgBreak(); }

    UNICODE_STRING stLinkTarget{};
    stLinkTarget.Length = rlLengthLinkTarget;
    stLinkTarget.MaximumLength = rlMaxLengthLinkTarget;
    stLinkTarget.Buffer = rlwLinkTarget.data();

    PULONG ReturnedLength{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReturnedLength);

    ULONG rlReturnedLength{};

    if(ReturnedLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnedLength, &rlReturnedLength, sizeof(rlReturnedLength));
    }


    NTSTATUS NtQuerySymbolicLinkObjectResult = NtQuerySymbolicLinkObject((HANDLE)LinkHandle,(PUNICODE_STRING)&stLinkTarget,(PULONG)&rlReturnedLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQuerySymbolicLinkObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LinkHandle);
    uc_mem_write(uc, (DWORD_PTR)LinkTarget, &stLinkTarget.Length, sizeof(stLinkTarget.Length));
    uc_mem_write(uc, (DWORD_PTR)LinkTarget+16, &stLinkTarget.MaximumLength, sizeof(stLinkTarget.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, stLinkTarget.Buffer, true, stLinkTarget.Length)) { printf("Error when read LinkTarget in NtQuerySymbolicLinkObject"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &ReturnedLength);

    if(ReturnedLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnedLength, &rlReturnedLength, sizeof(rlReturnedLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQuerySymbolicLinkObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS  PnPControlClass       ,
    INOUT  PVOID                   PnPControlData        ,
    IN     ULONG                   PnPControlDataLength  );

*/
void EmuApi::EmuNtPlugPlayControl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLUGPLAY_CONTROL_CLASS PnPControlClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &PnPControlClass);

    PVOID PnPControlData{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PnPControlData);

    ULONG PnPControlDataLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &PnPControlDataLength);


    NTSTATUS NtPlugPlayControlResult = NtPlugPlayControl((PLUGPLAY_CONTROL_CLASS)PnPControlClass,(PVOID)&PnPControlData,(ULONG)PnPControlDataLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtPlugPlayControlResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &PnPControlClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &PnPControlData);
    uc_reg_write(uc, UC_X86_REG_R8D, &PnPControlDataLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtPlugPlayControl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtPowerInformation(
    IN           POWER_INFORMATION_LEVEL  InformationLevel    ,
    INOPTIONAL   PVOID                    InputBuffer         ,
    IN           ULONG                    InputBufferLength   ,
    OUTOPTIONAL  PVOID                    OutputBuffer        ,
    IN           ULONG                    OutputBufferLength  );

*/
void EmuApi::EmuNtPowerInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POWER_INFORMATION_LEVEL InformationLevel{};
    uc_reg_read(uc, UC_X86_REG_ECX, &InformationLevel);

    PVOID InputBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &InputBuffer);

    ULONG InputBufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InputBufferLength);

    PVOID OutputBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutputBuffer);

    ULONG OutputBufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));


    NTSTATUS NtPowerInformationResult = NtPowerInformation((POWER_INFORMATION_LEVEL)InformationLevel,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtPowerInformationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &InformationLevel);
    uc_reg_write(uc, UC_X86_REG_RDX, &InputBuffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &InputBufferLength);
    uc_reg_write(uc, UC_X86_REG_R9, &OutputBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtPowerInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetThreadExecutionState(
    IN   EXECUTION_STATE    esFlags        ,
    OUT  EXECUTION_STATE *  PreviousFlags  );

*/
void EmuApi::EmuNtSetThreadExecutionState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    EXECUTION_STATE esFlags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &esFlags);

    PEXECUTION_STATE PreviousFlags{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousFlags);

    DWORD rlPreviousFlags{};

    if(PreviousFlags != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousFlags, &rlPreviousFlags, sizeof(rlPreviousFlags));
    }


    NTSTATUS NtSetThreadExecutionStateResult = NtSetThreadExecutionState((EXECUTION_STATE)esFlags,(EXECUTION_STATE *)&rlPreviousFlags);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetThreadExecutionStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &esFlags);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousFlags);

    if(PreviousFlags != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousFlags, &rlPreviousFlags, sizeof(rlPreviousFlags));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetThreadExecutionState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateProcess(
    OUT         PHANDLE             ProcessHandle       ,
    IN          ACCESS_MASK         DesiredAccess       ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes    ,
    IN          HANDLE              ParentProcess       ,
    IN          BOOLEAN             InheritObjectTable  ,
    INOPTIONAL  HANDLE              SectionHandle       ,
    INOPTIONAL  HANDLE              DebugPort           ,
    INOPTIONAL  HANDLE              ExceptionPort       );

*/
void EmuApi::EmuNtCreateProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE dpProcessHandle{};

    if(ProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    HANDLE ParentProcess{};
    uc_reg_read(uc, UC_X86_REG_R9, &ParentProcess);

    BOOLEAN InheritObjectTable{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &InheritObjectTable, sizeof(InheritObjectTable));

    HANDLE SectionHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));

    HANDLE DebugPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));

    HANDLE ExceptionPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));


    NTSTATUS NtCreateProcessResult = NtCreateProcess((PHANDLE)dpProcessHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(HANDLE)ParentProcess,(BOOLEAN)InheritObjectTable,(HANDLE)SectionHandle,(HANDLE)DebugPort,(HANDLE)ExceptionPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);

    if(ProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ParentProcess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &InheritObjectTable, sizeof(InheritObjectTable));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateProcessEx(
    OUT         PHANDLE             ProcessHandle     ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          HANDLE              ParentProcess     ,
    IN          ULONG               Flags             ,
    INOPTIONAL  HANDLE              SectionHandle     ,
    INOPTIONAL  HANDLE              DebugPort         ,
    INOPTIONAL  HANDLE              ExceptionPort     ,
    IN          ULONG               JobMemberLevel    );

*/
void EmuApi::EmuNtCreateProcessEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE dpProcessHandle{};

    if(ProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    HANDLE ParentProcess{};
    uc_reg_read(uc, UC_X86_REG_R9, &ParentProcess);

    ULONG Flags{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));

    HANDLE SectionHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));

    HANDLE DebugPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));

    HANDLE ExceptionPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));

    ULONG JobMemberLevel{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &JobMemberLevel, sizeof(JobMemberLevel));


    NTSTATUS NtCreateProcessExResult = NtCreateProcessEx((PHANDLE)dpProcessHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(HANDLE)ParentProcess,(ULONG)Flags,(HANDLE)SectionHandle,(HANDLE)DebugPort,(HANDLE)ExceptionPort,(ULONG)JobMemberLevel);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateProcessExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);

    if(ProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ParentProcess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &JobMemberLevel, sizeof(JobMemberLevel));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateProcessEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenProcess(
    OUT         PHANDLE             ProcessHandle     ,
    IN          ACCESS_MASK         DesiredAccess     ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes  ,
    INOPTIONAL  PCLIENT_ID          ClientId          );

*/
void EmuApi::EmuNtOpenProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE dpProcessHandle{};

    if(ProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PCLIENT_ID ClientId{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientId);

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }


    NTSTATUS NtOpenProcessResult = NtOpenProcess((PHANDLE)dpProcessHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PCLIENT_ID)&stClientId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);

    if(ProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientId);

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtTerminateProcess(
    INOPTIONAL  HANDLE    ProcessHandle  ,
    IN          NTSTATUS  ExitStatus     );

*/
void EmuApi::EmuNtTerminateProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ExitStatus);


    NTSTATUS NtTerminateProcessResult = NtTerminateProcess((HANDLE)ProcessHandle,(NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtTerminateProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtTerminateProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationProcess(
    IN           HANDLE            ProcessHandle             ,
    IN           PROCESSINFOCLASS  ProcessInformationClass   ,
    OUT          PVOID             ProcessInformation        ,
    IN           ULONG             ProcessInformationLength  ,
    OUTOPTIONAL  PULONG            ReturnLength              );

*/
void EmuApi::EmuNtQueryInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PROCESSINFOCLASS ProcessInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ProcessInformationClass);

    PVOID ProcessInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProcessInformation);

    ULONG ProcessInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ProcessInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryInformationProcessResult = NtQueryInformationProcess((HANDLE)ProcessHandle,(PROCESSINFOCLASS)ProcessInformationClass,(PVOID)&ProcessInformation,(ULONG)ProcessInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ProcessInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ProcessInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ProcessInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtGetNextProcess(
    IN   HANDLE       ProcessHandle     ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   ULONG        HandleAttributes  ,
    IN   ULONG        Flags             ,
    OUT  PHANDLE      NewProcessHandle  );

*/
void EmuApi::EmuNtGetNextProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HandleAttributes);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Flags);

    HANDLE NewProcessHandle{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NewProcessHandle, sizeof(NewProcessHandle));

    HANDLE dpNewProcessHandle{};

    if(NewProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewProcessHandle, &dpNewProcessHandle, sizeof(dpNewProcessHandle));
    }


    NTSTATUS NtGetNextProcessResult = NtGetNextProcess((HANDLE)ProcessHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(ULONG)Flags,(PHANDLE)dpNewProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtGetNextProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8D, &HandleAttributes);
    uc_reg_write(uc, UC_X86_REG_R9D, &Flags);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NewProcessHandle, sizeof(NewProcessHandle));

    if(NewProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewProcessHandle, &dpNewProcessHandle, sizeof(dpNewProcessHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtGetNextProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtGetNextThread(
    IN   HANDLE       ProcessHandle     ,
    IN   HANDLE       ThreadHandle      ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   ULONG        HandleAttributes  ,
    IN   ULONG        Flags             ,
    OUT  PHANDLE      NewThreadHandle   );

*/
void EmuApi::EmuNtGetNextThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DesiredAccess);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R9D, &HandleAttributes);

    ULONG Flags{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));

    HANDLE NewThreadHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NewThreadHandle, sizeof(NewThreadHandle));

    HANDLE dpNewThreadHandle{};

    if(NewThreadHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewThreadHandle, &dpNewThreadHandle, sizeof(dpNewThreadHandle));
    }


    NTSTATUS NtGetNextThreadResult = NtGetNextThread((HANDLE)ProcessHandle,(HANDLE)ThreadHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(ULONG)Flags,(PHANDLE)dpNewThreadHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtGetNextThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R9D, &HandleAttributes);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NewThreadHandle, sizeof(NewThreadHandle));

    if(NewThreadHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewThreadHandle, &dpNewThreadHandle, sizeof(dpNewThreadHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtGetNextThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryPortInformationProcess(VOID);

*/
void EmuApi::EmuNtQueryPortInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS NtQueryPortInformationProcessResult = NtQueryPortInformationProcess();


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryPortInformationProcessResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryPortInformationProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationProcess(
    IN  HANDLE            ProcessHandle             ,
    IN  PROCESSINFOCLASS  ProcessInformationClass   ,
    IN  PVOID             ProcessInformation        ,
    IN  ULONG             ProcessInformationLength  );

*/
void EmuApi::EmuNtSetInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PROCESSINFOCLASS ProcessInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ProcessInformationClass);

    PVOID ProcessInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProcessInformation);

    ULONG ProcessInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ProcessInformationLength);


    NTSTATUS NtSetInformationProcessResult = NtSetInformationProcess((HANDLE)ProcessHandle,(PROCESSINFOCLASS)ProcessInformationClass,(PVOID)&ProcessInformation,(ULONG)ProcessInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ProcessInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ProcessInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ProcessInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateThread(
    OUT         PHANDLE             ThreadHandle      ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          HANDLE              ProcessHandle     ,
    OUT         PCLIENT_ID          ClientId          ,
    IN          PCONTEXT            ThreadContext     ,
    IN          PINITIAL_TEB        InitialTeb        ,
    IN          BOOLEAN             CreateSuspended   );

*/
void EmuApi::EmuNtCreateThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    HANDLE dpThreadHandle{};

    if(ThreadHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProcessHandle);

    PCLIENT_ID ClientId{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ClientId, sizeof(ClientId));

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }

    PCONTEXT ThreadContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ThreadContext, sizeof(ThreadContext));

    CONTEXT stThreadContext{};

    if(ThreadContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }

    PINITIAL_TEB InitialTeb{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InitialTeb, sizeof(InitialTeb));

    INITIAL_TEB stInitialTeb{};

    if(InitialTeb != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InitialTeb, &stInitialTeb, sizeof(stInitialTeb));
    }

    BOOLEAN CreateSuspended{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CreateSuspended, sizeof(CreateSuspended));


    NTSTATUS NtCreateThreadResult = NtCreateThread((PHANDLE)dpThreadHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(HANDLE)ProcessHandle,(PCLIENT_ID)&stClientId,(PCONTEXT)&stThreadContext,(PINITIAL_TEB)&stInitialTeb,(BOOLEAN)CreateSuspended);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);

    if(ThreadHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ProcessHandle);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ClientId, sizeof(ClientId));

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ThreadContext, sizeof(ThreadContext));

    if(ThreadContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InitialTeb, sizeof(InitialTeb));

    if(InitialTeb != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InitialTeb, &stInitialTeb, sizeof(stInitialTeb));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CreateSuspended, sizeof(CreateSuspended));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenThread(
    OUT         PHANDLE             ThreadHandle      ,
    IN          ACCESS_MASK         DesiredAccess     ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes  ,
    INOPTIONAL  PCLIENT_ID          ClientId          );

*/
void EmuApi::EmuNtOpenThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    HANDLE dpThreadHandle{};

    if(ThreadHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PCLIENT_ID ClientId{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientId);

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }


    NTSTATUS NtOpenThreadResult = NtOpenThread((PHANDLE)dpThreadHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PCLIENT_ID)&stClientId);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);

    if(ThreadHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientId);

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtTerminateThread(
    INOPTIONAL  HANDLE    ThreadHandle  ,
    IN          NTSTATUS  ExitStatus    );

*/
void EmuApi::EmuNtTerminateThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ExitStatus);


    NTSTATUS NtTerminateThreadResult = NtTerminateThread((HANDLE)ThreadHandle,(NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtTerminateThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtTerminateThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSuspendThread(
    IN           HANDLE  ThreadHandle          ,
    OUTOPTIONAL  PULONG  PreviousSuspendCount  );

*/
void EmuApi::EmuNtSuspendThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PULONG PreviousSuspendCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    ULONG rlPreviousSuspendCount{};

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }


    NTSTATUS NtSuspendThreadResult = NtSuspendThread((HANDLE)ThreadHandle,(PULONG)&rlPreviousSuspendCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSuspendThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSuspendThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtResumeThread(
    IN           HANDLE  ThreadHandle          ,
    OUTOPTIONAL  PULONG  PreviousSuspendCount  );

*/
void EmuApi::EmuNtResumeThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PULONG PreviousSuspendCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    ULONG rlPreviousSuspendCount{};

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }


    NTSTATUS NtResumeThreadResult = NtResumeThread((HANDLE)ThreadHandle,(PULONG)&rlPreviousSuspendCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtResumeThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtResumeThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSuspendProcess(
      HANDLE  ProcessHandle  );

*/
void EmuApi::EmuNtSuspendProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);


    NTSTATUS NtSuspendProcessResult = NtSuspendProcess((HANDLE)ProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSuspendProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSuspendProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtResumeProcess(
    IN  HANDLE  ProcessHandle  );

*/
void EmuApi::EmuNtResumeProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);


    NTSTATUS NtResumeProcessResult = NtResumeProcess((HANDLE)ProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtResumeProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtResumeProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtGetContextThread(
    IN     HANDLE    ThreadHandle   ,
    INOUT  PCONTEXT  ThreadContext  );

*/
void EmuApi::EmuNtGetContextThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PCONTEXT ThreadContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadContext);

    CONTEXT stThreadContext{};

    if(ThreadContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }


    NTSTATUS NtGetContextThreadResult = NtGetContextThread((HANDLE)ThreadHandle,(PCONTEXT)&stThreadContext);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtGetContextThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadContext);

    if(ThreadContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtGetContextThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetContextThread(
    IN  HANDLE    ThreadHandle   ,
    IN  PCONTEXT  ThreadContext  );

*/
void EmuApi::EmuNtSetContextThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PCONTEXT ThreadContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadContext);

    CONTEXT stThreadContext{};

    if(ThreadContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }


    NTSTATUS NtSetContextThreadResult = NtSetContextThread((HANDLE)ThreadHandle,(PCONTEXT)&stThreadContext);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetContextThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadContext);

    if(ThreadContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetContextThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationThread(
    IN           HANDLE           ThreadHandle             ,
    IN           THREADINFOCLASS  ThreadInformationClass   ,
    OUT          PVOID            ThreadInformation        ,
    IN           ULONG            ThreadInformationLength  ,
    OUTOPTIONAL  PULONG           ReturnLength             );

*/
void EmuApi::EmuNtQueryInformationThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    THREADINFOCLASS ThreadInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ThreadInformationClass);

    PVOID ThreadInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ThreadInformation);

    ULONG ThreadInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ThreadInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryInformationThreadResult = NtQueryInformationThread((HANDLE)ThreadHandle,(THREADINFOCLASS)ThreadInformationClass,(PVOID)&ThreadInformation,(ULONG)ThreadInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ThreadInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ThreadInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ThreadInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationThread(
    IN  HANDLE           ThreadHandle             ,
    IN  THREADINFOCLASS  ThreadInformationClass   ,
    IN  PVOID            ThreadInformation        ,
    IN  ULONG            ThreadInformationLength  );

*/
void EmuApi::EmuNtSetInformationThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    THREADINFOCLASS ThreadInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ThreadInformationClass);

    PVOID ThreadInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ThreadInformation);

    ULONG ThreadInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ThreadInformationLength);


    NTSTATUS NtSetInformationThreadResult = NtSetInformationThread((HANDLE)ThreadHandle,(THREADINFOCLASS)ThreadInformationClass,(PVOID)&ThreadInformation,(ULONG)ThreadInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ThreadInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ThreadInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ThreadInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAlertThread(
    IN  HANDLE  ThreadHandle  );

*/
void EmuApi::EmuNtAlertThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);


    NTSTATUS NtAlertThreadResult = NtAlertThread((HANDLE)ThreadHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAlertThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAlertThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAlertResumeThread(
    IN           HANDLE  ThreadHandle          ,
    OUTOPTIONAL  PULONG  PreviousSuspendCount  );

*/
void EmuApi::EmuNtAlertResumeThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PULONG PreviousSuspendCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    ULONG rlPreviousSuspendCount{};

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }


    NTSTATUS NtAlertResumeThreadResult = NtAlertResumeThread((HANDLE)ThreadHandle,(PULONG)&rlPreviousSuspendCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAlertResumeThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAlertResumeThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtImpersonateThread(
    IN  HANDLE                        ServerThreadHandle  ,
    IN  HANDLE                        ClientThreadHandle  ,
    IN  PSECURITY_QUALITY_OF_SERVICE  SecurityQos         );

*/
void EmuApi::EmuNtImpersonateThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ServerThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ServerThreadHandle);

    HANDLE ClientThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ClientThreadHandle);

    PSECURITY_QUALITY_OF_SERVICE SecurityQos{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityQos);

    SECURITY_QUALITY_OF_SERVICE stSecurityQos{};

    if(SecurityQos != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }


    NTSTATUS NtImpersonateThreadResult = NtImpersonateThread((HANDLE)ServerThreadHandle,(HANDLE)ClientThreadHandle,(PSECURITY_QUALITY_OF_SERVICE)&stSecurityQos);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtImpersonateThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ServerThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ClientThreadHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityQos);

    if(SecurityQos != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtImpersonateThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtTestAlert(VOID);

*/
void EmuApi::EmuNtTestAlert(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS NtTestAlertResult = NtTestAlert();


    uc_reg_write(uc, UC_X86_REG_EAX, &NtTestAlertResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtTestAlert\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRegisterThreadTerminatePort(
    IN  HANDLE  PortHandle  );

*/
void EmuApi::EmuNtRegisterThreadTerminatePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);


    NTSTATUS NtRegisterThreadTerminatePortResult = NtRegisterThreadTerminatePort((HANDLE)PortHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRegisterThreadTerminatePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRegisterThreadTerminatePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetLdtEntries(
    IN  ULONG  Selector0  ,
    IN  ULONG  Entry0Low  ,
    IN  ULONG  Entry0Hi   ,
    IN  ULONG  Selector1  ,
    IN  ULONG  Entry1Low  ,
    IN  ULONG  Entry1Hi   );

*/
void EmuApi::EmuNtSetLdtEntries(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Selector0{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Selector0);

    ULONG Entry0Low{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Entry0Low);

    ULONG Entry0Hi{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Entry0Hi);

    ULONG Selector1{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Selector1);

    ULONG Entry1Low{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Entry1Low, sizeof(Entry1Low));

    ULONG Entry1Hi{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Entry1Hi, sizeof(Entry1Hi));


    NTSTATUS NtSetLdtEntriesResult = NtSetLdtEntries((ULONG)Selector0,(ULONG)Entry0Low,(ULONG)Entry0Hi,(ULONG)Selector1,(ULONG)Entry1Low,(ULONG)Entry1Hi);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetLdtEntriesResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Selector0);
    uc_reg_write(uc, UC_X86_REG_EDX, &Entry0Low);
    uc_reg_write(uc, UC_X86_REG_R8D, &Entry0Hi);
    uc_reg_write(uc, UC_X86_REG_R9D, &Selector1);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Entry1Low, sizeof(Entry1Low));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Entry1Hi, sizeof(Entry1Hi));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetLdtEntries\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueueApcThread(
    IN          HANDLE           ThreadHandle  ,
    IN          PPS_APC_ROUTINE  ApcRoutine    ,
    INOPTIONAL  PVOID            ApcArgument1  ,
    INOPTIONAL  PVOID            ApcArgument2  ,
    INOPTIONAL  PVOID            ApcArgument3  );

*/
void EmuApi::EmuNtQueueApcThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PPS_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ApcRoutine);

    PVOID ApcArgument1{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcArgument1);

    PVOID ApcArgument2{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcArgument2);

    PVOID ApcArgument3{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ApcArgument3, sizeof(ApcArgument3));


    NTSTATUS NtQueueApcThreadResult = NtQueueApcThread((HANDLE)ThreadHandle,(PPS_APC_ROUTINE)ApcRoutine,(PVOID)&ApcArgument1,(PVOID)&ApcArgument2,(PVOID)&ApcArgument3);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueueApcThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcArgument1);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcArgument2);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ApcArgument3, sizeof(ApcArgument3));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueueApcThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateJobObject(
    OUT         PHANDLE             JobHandle         ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtCreateJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    HANDLE dpJobHandle{};

    if(JobHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtCreateJobObjectResult = NtCreateJobObject((PHANDLE)dpJobHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);

    if(JobHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenJobObject(
    OUT  PHANDLE             JobHandle         ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    HANDLE dpJobHandle{};

    if(JobHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenJobObjectResult = NtOpenJobObject((PHANDLE)dpJobHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);

    if(JobHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAssignProcessToJobObject(
    IN  HANDLE  JobHandle      ,
    IN  HANDLE  ProcessHandle  );

*/
void EmuApi::EmuNtAssignProcessToJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcessHandle);


    NTSTATUS NtAssignProcessToJobObjectResult = NtAssignProcessToJobObject((HANDLE)JobHandle,(HANDLE)ProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAssignProcessToJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcessHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAssignProcessToJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtTerminateJobObject(
    IN  HANDLE    JobHandle   ,
    IN  NTSTATUS  ExitStatus  );

*/
void EmuApi::EmuNtTerminateJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ExitStatus);


    NTSTATUS NtTerminateJobObjectResult = NtTerminateJobObject((HANDLE)JobHandle,(NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtTerminateJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtTerminateJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtIsProcessInJob(
    IN          HANDLE  ProcessHandle  ,
    INOPTIONAL  HANDLE  JobHandle      );

*/
void EmuApi::EmuNtIsProcessInJob(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &JobHandle);


    NTSTATUS NtIsProcessInJobResult = NtIsProcessInJob((HANDLE)ProcessHandle,(HANDLE)JobHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtIsProcessInJobResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &JobHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtIsProcessInJob\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateJobSet(
    IN  ULONG           NumJob      ,
    IN  PJOB_SET_ARRAY  UserJobSet  ,
    IN  ULONG           Flags       );

*/
void EmuApi::EmuNtCreateJobSet(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG NumJob{};
    uc_reg_read(uc, UC_X86_REG_ECX, &NumJob);

    PJOB_SET_ARRAY UserJobSet{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UserJobSet);

    JOB_SET_ARRAY stUserJobSet{};

    if(UserJobSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserJobSet, &stUserJobSet, sizeof(stUserJobSet));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS NtCreateJobSetResult = NtCreateJobSet((ULONG)NumJob,(PJOB_SET_ARRAY)&stUserJobSet,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateJobSetResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &NumJob);
    uc_reg_write(uc, UC_X86_REG_RDX, &UserJobSet);

    if(UserJobSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserJobSet, &stUserJobSet, sizeof(stUserJobSet));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateJobSet\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationJobObject(
    INOPTIONAL   HANDLE              JobHandle                   ,
    IN           JOBOBJECTINFOCLASS  JobObjectInformationClass   ,
    OUT          PVOID               JobObjectInformation        ,
    IN           ULONG               JobObjectInformationLength  ,
    OUTOPTIONAL  PULONG              ReturnLength                );

*/
void EmuApi::EmuNtQueryInformationJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    JOBOBJECTINFOCLASS JobObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &JobObjectInformationClass);

    PVOID JobObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &JobObjectInformation);

    ULONG JobObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &JobObjectInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryInformationJobObjectResult = NtQueryInformationJobObject((HANDLE)JobHandle,(JOBOBJECTINFOCLASS)JobObjectInformationClass,(PVOID)&JobObjectInformation,(ULONG)JobObjectInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &JobObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &JobObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &JobObjectInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationJobObject(
    IN  HANDLE              JobHandle                   ,
    IN  JOBOBJECTINFOCLASS  JobObjectInformationClass   ,
    IN  PVOID               JobObjectInformation        ,
    IN  ULONG               JobObjectInformationLength  );

*/
void EmuApi::EmuNtSetInformationJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    JOBOBJECTINFOCLASS JobObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &JobObjectInformationClass);

    PVOID JobObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &JobObjectInformation);

    ULONG JobObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &JobObjectInformationLength);


    NTSTATUS NtSetInformationJobObjectResult = NtSetInformationJobObject((HANDLE)JobHandle,(JOBOBJECTINFOCLASS)JobObjectInformationClass,(PVOID)&JobObjectInformation,(ULONG)JobObjectInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &JobObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &JobObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &JobObjectInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateKey(
    OUT          PHANDLE             KeyHandle         ,
    IN           ACCESS_MASK         DesiredAccess     ,
    IN           POBJECT_ATTRIBUTES  ObjectAttributes  ,
                 ULONG               TitleIndex        ,
    INOPTIONAL   PUNICODE_STRING     Class             ,
    IN           ULONG               CreateOptions     ,
    OUTOPTIONAL  PULONG              Disposition       );

*/
void EmuApi::EmuNtCreateKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE dpKeyHandle{};

    if(KeyHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG TitleIndex{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TitleIndex);

    PUNICODE_STRING Class{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Class, sizeof(Class));

    std::wstring rlwClass;

    USHORT rlLengthClass;

    USHORT rlMaxLengthClass;
    uc_mem_read(uc, (DWORD_PTR)Class, &rlLengthClass, sizeof(rlLengthClass));
    uc_mem_read(uc, (DWORD_PTR)Class+16, &rlMaxLengthClass, sizeof(rlMaxLengthClass));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Class+64, rlwClass, true, rlLengthClass)) { printf("Error when read Class in NtCreateKey"); _CrtDbgBreak(); }

    UNICODE_STRING stClass{};
    stClass.Length = rlLengthClass;
    stClass.MaximumLength = rlMaxLengthClass;
    stClass.Buffer = rlwClass.data();

    ULONG CreateOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CreateOptions, sizeof(CreateOptions));

    PULONG Disposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Disposition, sizeof(Disposition));

    ULONG rlDisposition{};

    if(Disposition != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Disposition, &rlDisposition, sizeof(rlDisposition));
    }


    NTSTATUS NtCreateKeyResult = NtCreateKey((PHANDLE)dpKeyHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)TitleIndex,(PUNICODE_STRING)&stClass,(ULONG)CreateOptions,(PULONG)&rlDisposition);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);

    if(KeyHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &TitleIndex);
    uc_mem_write(uc, (DWORD_PTR)Class, &stClass.Length, sizeof(stClass.Length));
    uc_mem_write(uc, (DWORD_PTR)Class+16, &stClass.MaximumLength, sizeof(stClass.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Class+64, stClass.Buffer, true, stClass.Length)) { printf("Error when read Class in NtCreateKey"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Disposition, sizeof(Disposition));

    if(Disposition != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Disposition, &rlDisposition, sizeof(rlDisposition));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteKey(
    IN  HANDLE  KeyHandle  );

*/
void EmuApi::EmuNtDeleteKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);


    NTSTATUS NtDeleteKeyResult = NtDeleteKey((HANDLE)KeyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteValueKey(
    IN  HANDLE           KeyHandle  ,
    IN  PUNICODE_STRING  ValueName  );

*/
void EmuApi::EmuNtDeleteValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING ValueName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueName);

    std::wstring rlwValueName;

    USHORT rlLengthValueName;

    USHORT rlMaxLengthValueName;
    uc_mem_read(uc, (DWORD_PTR)ValueName, &rlLengthValueName, sizeof(rlLengthValueName));
    uc_mem_read(uc, (DWORD_PTR)ValueName+16, &rlMaxLengthValueName, sizeof(rlMaxLengthValueName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, rlwValueName, true, rlLengthValueName)) { printf("Error when read ValueName in NtDeleteValueKey"); _CrtDbgBreak(); }

    UNICODE_STRING stValueName{};
    stValueName.Length = rlLengthValueName;
    stValueName.MaximumLength = rlMaxLengthValueName;
    stValueName.Buffer = rlwValueName.data();


    NTSTATUS NtDeleteValueKeyResult = NtDeleteValueKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stValueName);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)ValueName, &stValueName.Length, sizeof(stValueName.Length));
    uc_mem_write(uc, (DWORD_PTR)ValueName+16, &stValueName.MaximumLength, sizeof(stValueName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, stValueName.Buffer, true, stValueName.Length)) { printf("Error when read ValueName in NtDeleteValueKey"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtEnumerateKey(
    IN           HANDLE                 KeyHandle            ,
    IN           ULONG                  Index                ,
    IN           KEY_INFORMATION_CLASS  KeyInformationClass  ,
    OUTOPTIONAL  PVOID                  KeyInformation       ,
    IN           ULONG                  Length               ,
    OUT          PULONG                 ResultLength         );

*/
void EmuApi::EmuNtEnumerateKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    ULONG Index{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Index);

    KEY_INFORMATION_CLASS KeyInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &KeyInformationClass);

    PVOID KeyInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &KeyInformation);

    ULONG Length{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));

    PULONG ResultLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS NtEnumerateKeyResult = NtEnumerateKey((HANDLE)KeyHandle,(ULONG)Index,(KEY_INFORMATION_CLASS)KeyInformationClass,(PVOID)&KeyInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtEnumerateKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Index);
    uc_reg_write(uc, UC_X86_REG_R8D, &KeyInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &KeyInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtEnumerateKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtEnumerateValueKey(
    IN           HANDLE                       KeyHandle                 ,
    IN           ULONG                        Index                     ,
    IN           KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass  ,
    OUTOPTIONAL  PVOID                        KeyValueInformation       ,
    IN           ULONG                        Length                    ,
    OUT          PULONG                       ResultLength              );

*/
void EmuApi::EmuNtEnumerateValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    ULONG Index{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Index);

    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &KeyValueInformationClass);

    PVOID KeyValueInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &KeyValueInformation);

    ULONG Length{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));

    PULONG ResultLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS NtEnumerateValueKeyResult = NtEnumerateValueKey((HANDLE)KeyHandle,(ULONG)Index,(KEY_VALUE_INFORMATION_CLASS)KeyValueInformationClass,(PVOID)&KeyValueInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtEnumerateValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Index);
    uc_reg_write(uc, UC_X86_REG_R8D, &KeyValueInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &KeyValueInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtEnumerateValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFlushKey(
    IN  HANDLE  KeyHandle  );

*/
void EmuApi::EmuNtFlushKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);


    NTSTATUS NtFlushKeyResult = NtFlushKey((HANDLE)KeyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFlushKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFlushKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtInitializeRegistry(
    IN  USHORT  BootCondition  );

*/
void EmuApi::EmuNtInitializeRegistry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT BootCondition{};
    uc_reg_read(uc, UC_X86_REG_CX, &BootCondition);


    NTSTATUS NtInitializeRegistryResult = NtInitializeRegistry((USHORT)BootCondition);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtInitializeRegistryResult);
    uc_reg_write(uc, UC_X86_REG_CX, &BootCondition);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtInitializeRegistry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtNotifyChangeKey(
    IN           HANDLE            KeyHandle         ,
    INOPTIONAL   HANDLE            Event             ,
    INOPTIONAL   PIO_APC_ROUTINE   ApcRoutine        ,
    INOPTIONAL   PVOID             ApcContext        ,
    OUT          PIO_STATUS_BLOCK  IoStatusBlock     ,
    IN           ULONG             CompletionFilter  ,
    IN           BOOLEAN           WatchTree         ,
    OUTOPTIONAL  PVOID             Buffer            ,
    IN           ULONG             BufferSize        ,
    IN           BOOLEAN           Asynchronous      );

*/
void EmuApi::EmuNtNotifyChangeKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG CompletionFilter{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CompletionFilter, sizeof(CompletionFilter));

    BOOLEAN WatchTree{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &WatchTree, sizeof(WatchTree));

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Buffer, sizeof(Buffer));

    ULONG BufferSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &BufferSize, sizeof(BufferSize));

    BOOLEAN Asynchronous{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Asynchronous, sizeof(Asynchronous));


    NTSTATUS NtNotifyChangeKeyResult = NtNotifyChangeKey((HANDLE)KeyHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)CompletionFilter,(BOOLEAN)WatchTree,(PVOID)&Buffer,(ULONG)BufferSize,(BOOLEAN)Asynchronous);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtNotifyChangeKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &CompletionFilter, sizeof(CompletionFilter));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &WatchTree, sizeof(WatchTree));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Asynchronous, sizeof(Asynchronous));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtNotifyChangeKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtNotifyChangeMultipleKeys(
    IN           HANDLE               MasterKeyHandle   ,
    INOPTIONAL   ULONG                Count             ,
    INOPTIONAL   OBJECT_ATTRIBUTES *  SlaveObjects      ,
    INOPTIONAL   HANDLE               Event             ,
    INOPTIONAL   PIO_APC_ROUTINE      ApcRoutine        ,
    INOPTIONAL   PVOID                ApcContext        ,
    OUT          PIO_STATUS_BLOCK     IoStatusBlock     ,
    IN           ULONG                CompletionFilter  ,
    IN           BOOLEAN              WatchTree         ,
    OUTOPTIONAL  PVOID                Buffer            ,
    IN           ULONG                BufferSize        ,
    IN           BOOLEAN              Asynchronous      );

*/
void EmuApi::EmuNtNotifyChangeMultipleKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MasterKeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MasterKeyHandle);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);

    POBJECT_ATTRIBUTES SlaveObjects{};
    uc_reg_read(uc, UC_X86_REG_R8, &SlaveObjects);

    OBJECT_ATTRIBUTES rlSlaveObjects{};

    if(SlaveObjects != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SlaveObjects, &rlSlaveObjects, sizeof(rlSlaveObjects));
    }

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_R9, &Event);

    PIO_APC_ROUTINE ApcRoutine{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ApcRoutine, sizeof(ApcRoutine));

    PVOID ApcContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ApcContext, sizeof(ApcContext));

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG CompletionFilter{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));

    BOOLEAN WatchTree{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Buffer, sizeof(Buffer));

    ULONG BufferSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &BufferSize, sizeof(BufferSize));

    BOOLEAN Asynchronous{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &Asynchronous, sizeof(Asynchronous));


    NTSTATUS NtNotifyChangeMultipleKeysResult = NtNotifyChangeMultipleKeys((HANDLE)MasterKeyHandle,(ULONG)Count,(OBJECT_ATTRIBUTES *)&rlSlaveObjects,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)CompletionFilter,(BOOLEAN)WatchTree,(PVOID)&Buffer,(ULONG)BufferSize,(BOOLEAN)Asynchronous);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtNotifyChangeMultipleKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MasterKeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    uc_reg_write(uc, UC_X86_REG_R8, &SlaveObjects);

    if(SlaveObjects != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SlaveObjects, &rlSlaveObjects, sizeof(rlSlaveObjects));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Event);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ApcRoutine, sizeof(ApcRoutine));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ApcContext, sizeof(ApcContext));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &Asynchronous, sizeof(Asynchronous));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtNotifyChangeMultipleKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenKey(
    OUT  PHANDLE             KeyHandle         ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuNtOpenKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE dpKeyHandle{};

    if(KeyHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS NtOpenKeyResult = NtOpenKey((PHANDLE)dpKeyHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);

    if(KeyHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryKey(
    IN           HANDLE                 KeyHandle            ,
    IN           KEY_INFORMATION_CLASS  KeyInformationClass  ,
    OUTOPTIONAL  PVOID                  KeyInformation       ,
    IN           ULONG                  Length               ,
    OUT          PULONG                 ResultLength         );

*/
void EmuApi::EmuNtQueryKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    KEY_INFORMATION_CLASS KeyInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &KeyInformationClass);

    PVOID KeyInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &KeyInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    PULONG ResultLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS NtQueryKeyResult = NtQueryKey((HANDLE)KeyHandle,(KEY_INFORMATION_CLASS)KeyInformationClass,(PVOID)&KeyInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &KeyInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &KeyInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryValueKey(
    IN           HANDLE                       KeyHandle                 ,
    IN           PUNICODE_STRING              ValueName                 ,
    IN           KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass  ,
    OUTOPTIONAL  PVOID                        KeyValueInformation       ,
    IN           ULONG                        Length                    ,
    OUT          PULONG                       ResultLength              );

*/
void EmuApi::EmuNtQueryValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING ValueName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueName);

    std::wstring rlwValueName;

    USHORT rlLengthValueName;

    USHORT rlMaxLengthValueName;
    uc_mem_read(uc, (DWORD_PTR)ValueName, &rlLengthValueName, sizeof(rlLengthValueName));
    uc_mem_read(uc, (DWORD_PTR)ValueName+16, &rlMaxLengthValueName, sizeof(rlMaxLengthValueName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, rlwValueName, true, rlLengthValueName)) { printf("Error when read ValueName in NtQueryValueKey"); _CrtDbgBreak(); }

    UNICODE_STRING stValueName{};
    stValueName.Length = rlLengthValueName;
    stValueName.MaximumLength = rlMaxLengthValueName;
    stValueName.Buffer = rlwValueName.data();

    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &KeyValueInformationClass);

    PVOID KeyValueInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &KeyValueInformation);

    ULONG Length{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));

    PULONG ResultLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS NtQueryValueKeyResult = NtQueryValueKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stValueName,(KEY_VALUE_INFORMATION_CLASS)KeyValueInformationClass,(PVOID)&KeyValueInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)ValueName, &stValueName.Length, sizeof(stValueName.Length));
    uc_mem_write(uc, (DWORD_PTR)ValueName+16, &stValueName.MaximumLength, sizeof(stValueName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, stValueName.Buffer, true, stValueName.Length)) { printf("Error when read ValueName in NtQueryValueKey"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &KeyValueInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &KeyValueInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryMultipleValueKey(
    IN           HANDLE            KeyHandle             ,
    INOUT        PKEY_VALUE_ENTRY  ValueEntries          ,
    IN           ULONG             EntryCount            ,
    OUT          PVOID             ValueBuffer           ,
    INOUT        PULONG            BufferLength          ,
    OUTOPTIONAL  PULONG            RequiredBufferLength  );

*/
void EmuApi::EmuNtQueryMultipleValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PKEY_VALUE_ENTRY ValueEntries{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueEntries);

    KEY_VALUE_ENTRY stValueEntries{};

    if(ValueEntries != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ValueEntries, &stValueEntries, sizeof(stValueEntries));
    }

    ULONG EntryCount{};
    uc_reg_read(uc, UC_X86_REG_R8D, &EntryCount);

    PVOID ValueBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &ValueBuffer);

    PULONG BufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BufferLength, sizeof(BufferLength));

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }

    PULONG RequiredBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &RequiredBufferLength, sizeof(RequiredBufferLength));

    ULONG rlRequiredBufferLength{};

    if(RequiredBufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequiredBufferLength, &rlRequiredBufferLength, sizeof(rlRequiredBufferLength));
    }


    NTSTATUS NtQueryMultipleValueKeyResult = NtQueryMultipleValueKey((HANDLE)KeyHandle,(PKEY_VALUE_ENTRY)&stValueEntries,(ULONG)EntryCount,(PVOID)&ValueBuffer,(PULONG)&rlBufferLength,(PULONG)&rlRequiredBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryMultipleValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ValueEntries);

    if(ValueEntries != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ValueEntries, &stValueEntries, sizeof(stValueEntries));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &EntryCount);
    uc_reg_write(uc, UC_X86_REG_R9, &ValueBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BufferLength, sizeof(BufferLength));

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &RequiredBufferLength, sizeof(RequiredBufferLength));

    if(RequiredBufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequiredBufferLength, &rlRequiredBufferLength, sizeof(rlRequiredBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryMultipleValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtReplaceKey(
    IN  POBJECT_ATTRIBUTES  NewFile       ,
    IN  HANDLE              TargetHandle  ,
    IN  POBJECT_ATTRIBUTES  OldFile       );

*/
void EmuApi::EmuNtReplaceKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES NewFile{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NewFile);

    OBJECT_ATTRIBUTES rlNewFile{};

    if(NewFile != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewFile, &rlNewFile, sizeof(rlNewFile));
    }

    HANDLE TargetHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TargetHandle);

    POBJECT_ATTRIBUTES OldFile{};
    uc_reg_read(uc, UC_X86_REG_R8, &OldFile);

    OBJECT_ATTRIBUTES rlOldFile{};

    if(OldFile != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldFile, &rlOldFile, sizeof(rlOldFile));
    }


    NTSTATUS NtReplaceKeyResult = NtReplaceKey((POBJECT_ATTRIBUTES)&rlNewFile,(HANDLE)TargetHandle,(POBJECT_ATTRIBUTES)&rlOldFile);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtReplaceKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NewFile);

    if(NewFile != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewFile, &rlNewFile, sizeof(rlNewFile));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &TargetHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &OldFile);

    if(OldFile != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldFile, &rlOldFile, sizeof(rlOldFile));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtReplaceKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRenameKey(
    IN  HANDLE           KeyHandle  ,
    IN  PUNICODE_STRING  NewName    );

*/
void EmuApi::EmuNtRenameKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING NewName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NewName);

    std::wstring rlwNewName;

    USHORT rlLengthNewName;

    USHORT rlMaxLengthNewName;
    uc_mem_read(uc, (DWORD_PTR)NewName, &rlLengthNewName, sizeof(rlLengthNewName));
    uc_mem_read(uc, (DWORD_PTR)NewName+16, &rlMaxLengthNewName, sizeof(rlMaxLengthNewName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)NewName+64, rlwNewName, true, rlLengthNewName)) { printf("Error when read NewName in NtRenameKey"); _CrtDbgBreak(); }

    UNICODE_STRING stNewName{};
    stNewName.Length = rlLengthNewName;
    stNewName.MaximumLength = rlMaxLengthNewName;
    stNewName.Buffer = rlwNewName.data();


    NTSTATUS NtRenameKeyResult = NtRenameKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stNewName);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRenameKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)NewName, &stNewName.Length, sizeof(stNewName.Length));
    uc_mem_write(uc, (DWORD_PTR)NewName+16, &stNewName.MaximumLength, sizeof(stNewName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)NewName+64, stNewName.Buffer, true, stNewName.Length)) { printf("Error when read NewName in NtRenameKey"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRenameKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCompactKeys(
    IN  ULONG     Count     ,
    IN  HANDLE *  KeyArray  );

*/
void EmuApi::EmuNtCompactKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Count);

    PHANDLE KeyArray{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyArray);

    HANDLE rlKeyArray{};

    if(KeyArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyArray, &rlKeyArray, sizeof(rlKeyArray));
    }


    NTSTATUS NtCompactKeysResult = NtCompactKeys((ULONG)Count,(HANDLE *)rlKeyArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCompactKeysResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Count);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyArray);

    if(KeyArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyArray, &rlKeyArray, sizeof(rlKeyArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCompactKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCompressKey(
    IN  HANDLE  Key  );

*/
void EmuApi::EmuNtCompressKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Key{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Key);


    NTSTATUS NtCompressKeyResult = NtCompressKey((HANDLE)Key);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCompressKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Key);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCompressKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRestoreKey(
    IN  HANDLE  KeyHandle   ,
    IN  HANDLE  FileHandle  ,
    IN  ULONG   Flags       );

*/
void EmuApi::EmuNtRestoreKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS NtRestoreKeyResult = NtRestoreKey((HANDLE)KeyHandle,(HANDLE)FileHandle,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRestoreKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRestoreKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSaveKey(
    IN  HANDLE  KeyHandle   ,
    IN  HANDLE  FileHandle  );

*/
void EmuApi::EmuNtSaveKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileHandle);


    NTSTATUS NtSaveKeyResult = NtSaveKey((HANDLE)KeyHandle,(HANDLE)FileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSaveKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &FileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSaveKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSaveKeyEx(
    IN  HANDLE  KeyHandle   ,
    IN  HANDLE  FileHandle  ,
    IN  ULONG   Format      );

*/
void EmuApi::EmuNtSaveKeyEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileHandle);

    ULONG Format{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Format);


    NTSTATUS NtSaveKeyExResult = NtSaveKeyEx((HANDLE)KeyHandle,(HANDLE)FileHandle,(ULONG)Format);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSaveKeyExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &Format);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSaveKeyEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSaveMergedKeys(
    IN  HANDLE  HighPrecedenceKeyHandle  ,
    IN  HANDLE  LowPrecedenceKeyHandle   ,
    IN  HANDLE  FileHandle               );

*/
void EmuApi::EmuNtSaveMergedKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE HighPrecedenceKeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HighPrecedenceKeyHandle);

    HANDLE LowPrecedenceKeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LowPrecedenceKeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &FileHandle);


    NTSTATUS NtSaveMergedKeysResult = NtSaveMergedKeys((HANDLE)HighPrecedenceKeyHandle,(HANDLE)LowPrecedenceKeyHandle,(HANDLE)FileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSaveMergedKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HighPrecedenceKeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &LowPrecedenceKeyHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &FileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSaveMergedKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetValueKey(
    IN          HANDLE           KeyHandle   ,
    IN          PUNICODE_STRING  ValueName   ,
    INOPTIONAL  ULONG            TitleIndex  ,
    IN          ULONG            Type        ,
    INOPTIONAL  PVOID            Data        ,
    IN          ULONG            DataSize    );

*/
void EmuApi::EmuNtSetValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING ValueName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueName);

    std::wstring rlwValueName;

    USHORT rlLengthValueName;

    USHORT rlMaxLengthValueName;
    uc_mem_read(uc, (DWORD_PTR)ValueName, &rlLengthValueName, sizeof(rlLengthValueName));
    uc_mem_read(uc, (DWORD_PTR)ValueName+16, &rlMaxLengthValueName, sizeof(rlMaxLengthValueName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, rlwValueName, true, rlLengthValueName)) { printf("Error when read ValueName in NtSetValueKey"); _CrtDbgBreak(); }

    UNICODE_STRING stValueName{};
    stValueName.Length = rlLengthValueName;
    stValueName.MaximumLength = rlMaxLengthValueName;
    stValueName.Buffer = rlwValueName.data();

    ULONG TitleIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &TitleIndex);

    ULONG Type{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Type);

    PVOID Data{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Data, sizeof(Data));

    ULONG DataSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &DataSize, sizeof(DataSize));


    NTSTATUS NtSetValueKeyResult = NtSetValueKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stValueName,(ULONG)TitleIndex,(ULONG)Type,(PVOID)&Data,(ULONG)DataSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)ValueName, &stValueName.Length, sizeof(stValueName.Length));
    uc_mem_write(uc, (DWORD_PTR)ValueName+16, &stValueName.MaximumLength, sizeof(stValueName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, stValueName.Buffer, true, stValueName.Length)) { printf("Error when read ValueName in NtSetValueKey"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &TitleIndex);
    uc_reg_write(uc, UC_X86_REG_R9D, &Type);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Data, sizeof(Data));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &DataSize, sizeof(DataSize));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnloadKey(
    IN  POBJECT_ATTRIBUTES  TargetKey  );

*/
void EmuApi::EmuNtUnloadKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }


    NTSTATUS NtUnloadKeyResult = NtUnloadKey((POBJECT_ATTRIBUTES)&rlTargetKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnloadKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnloadKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnloadKey2(
    IN  POBJECT_ATTRIBUTES  TargetKey  ,
    IN  ULONG               Flags      );

*/
void EmuApi::EmuNtUnloadKey2(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);


    NTSTATUS NtUnloadKey2Result = NtUnloadKey2((POBJECT_ATTRIBUTES)&rlTargetKey,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnloadKey2Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnloadKey2\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtUnloadKeyEx(
    IN          POBJECT_ATTRIBUTES  TargetKey  ,
    INOPTIONAL  HANDLE              Event      );

*/
void EmuApi::EmuNtUnloadKeyEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);


    NTSTATUS NtUnloadKeyExResult = NtUnloadKeyEx((POBJECT_ATTRIBUTES)&rlTargetKey,(HANDLE)Event);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtUnloadKeyExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtUnloadKeyEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationKey(
    IN  HANDLE                     KeyHandle                ,
    IN  KEY_SET_INFORMATION_CLASS  KeySetInformationClass   ,
    IN  PVOID                      KeySetInformation        ,
    IN  ULONG                      KeySetInformationLength  );

*/
void EmuApi::EmuNtSetInformationKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    KEY_SET_INFORMATION_CLASS KeySetInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &KeySetInformationClass);

    PVOID KeySetInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &KeySetInformation);

    ULONG KeySetInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &KeySetInformationLength);


    NTSTATUS NtSetInformationKeyResult = NtSetInformationKey((HANDLE)KeyHandle,(KEY_SET_INFORMATION_CLASS)KeySetInformationClass,(PVOID)&KeySetInformation,(ULONG)KeySetInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &KeySetInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &KeySetInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &KeySetInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryOpenSubKeys(
    IN   POBJECT_ATTRIBUTES  TargetKey    ,
    OUT  PULONG              HandleCount  );

*/
void EmuApi::EmuNtQueryOpenSubKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    PULONG HandleCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleCount);

    ULONG rlHandleCount{};

    if(HandleCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleCount, &rlHandleCount, sizeof(rlHandleCount));
    }


    NTSTATUS NtQueryOpenSubKeysResult = NtQueryOpenSubKeys((POBJECT_ATTRIBUTES)&rlTargetKey,(PULONG)&rlHandleCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryOpenSubKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleCount);

    if(HandleCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleCount, &rlHandleCount, sizeof(rlHandleCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryOpenSubKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryOpenSubKeysEx(
    IN   POBJECT_ATTRIBUTES  TargetKey     ,
    IN   ULONG               BufferLength  ,
    OUT  PVOID               Buffer        ,
    OUT  PULONG              RequiredSize  );

*/
void EmuApi::EmuNtQueryOpenSubKeysEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    ULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BufferLength);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PULONG RequiredSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &RequiredSize);

    ULONG rlRequiredSize{};

    if(RequiredSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequiredSize, &rlRequiredSize, sizeof(rlRequiredSize));
    }


    NTSTATUS NtQueryOpenSubKeysExResult = NtQueryOpenSubKeysEx((POBJECT_ATTRIBUTES)&rlTargetKey,(ULONG)BufferLength,(PVOID)&Buffer,(PULONG)&rlRequiredSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryOpenSubKeysExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &BufferLength);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9, &RequiredSize);

    if(RequiredSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequiredSize, &rlRequiredSize, sizeof(rlRequiredSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryOpenSubKeysEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtLockRegistryKey(
    IN  HANDLE  KeyHandle  );

*/
void EmuApi::EmuNtLockRegistryKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);


    NTSTATUS NtLockRegistryKeyResult = NtLockRegistryKey((HANDLE)KeyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtLockRegistryKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtLockRegistryKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtLockProductActivationKeys(
    INOUTOPTIONAL  ULONG *  pPrivateVer  ,
    OUTOPTIONAL    ULONG *  pSafeMode    );

*/
void EmuApi::EmuNtLockProductActivationKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG pPrivateVer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &pPrivateVer);

    ULONG rlpPrivateVer{};

    if(pPrivateVer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pPrivateVer, &rlpPrivateVer, sizeof(rlpPrivateVer));
    }

    PULONG pSafeMode{};
    uc_reg_read(uc, UC_X86_REG_RDX, &pSafeMode);

    ULONG rlpSafeMode{};

    if(pSafeMode != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pSafeMode, &rlpSafeMode, sizeof(rlpSafeMode));
    }


    NTSTATUS NtLockProductActivationKeysResult = NtLockProductActivationKeys((ULONG *)&rlpPrivateVer,(ULONG *)&rlpSafeMode);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtLockProductActivationKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &pPrivateVer);

    if(pPrivateVer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pPrivateVer, &rlpPrivateVer, sizeof(rlpPrivateVer));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &pSafeMode);

    if(pSafeMode != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pSafeMode, &rlpSafeMode, sizeof(rlpSafeMode));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtLockProductActivationKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheck(
    IN     PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN     HANDLE                ClientToken         ,
    IN     ACCESS_MASK           DesiredAccess       ,
    IN     PGENERIC_MAPPING      GenericMapping      ,
    OUT    PPRIVILEGE_SET        PrivilegeSet        ,
    INOUT  PULONG                PrivilegeSetLength  ,
    OUT    PACCESS_MASK          GrantedAccess       ,
    OUT    PNTSTATUS             AccessStatus        );

*/
void EmuApi::EmuNtAccessCheck(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DesiredAccess);

    PGENERIC_MAPPING GenericMapping{};
    uc_reg_read(uc, UC_X86_REG_R9, &GenericMapping);

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    PPRIVILEGE_SET PrivilegeSet{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &PrivilegeSet, sizeof(PrivilegeSet));

    PRIVILEGE_SET stPrivilegeSet{};

    if(PrivilegeSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }

    PULONG PrivilegeSetLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    ULONG rlPrivilegeSetLength{};

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }


    NTSTATUS NtAccessCheckResult = NtAccessCheck((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(PGENERIC_MAPPING)&rlGenericMapping,(PPRIVILEGE_SET)&stPrivilegeSet,(PULONG)&rlPrivilegeSetLength,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R8D, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R9, &GenericMapping);

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &PrivilegeSet, sizeof(PrivilegeSet));

    if(PrivilegeSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheck\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheckByType(
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          HANDLE                ClientToken           ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    OUT         PPRIVILEGE_SET        PrivilegeSet          ,
    INOUT       PULONG                PrivilegeSetLength    ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          );

*/
void EmuApi::EmuNtAccessCheckByType(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID PrincipalSelfSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PrincipalSelfSid);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    POBJECT_TYPE_LIST ObjectTypeList{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    PPRIVILEGE_SET PrivilegeSet{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    PRIVILEGE_SET stPrivilegeSet{};

    if(PrivilegeSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }

    PULONG PrivilegeSetLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    ULONG rlPrivilegeSetLength{};

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }


    NTSTATUS NtAccessCheckByTypeResult = NtAccessCheckByType((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(PPRIVILEGE_SET)&stPrivilegeSet,(PULONG)&rlPrivilegeSetLength,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckByTypeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &PrincipalSelfSid);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    if(PrivilegeSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheckByType\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheckByTypeResultList(
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          HANDLE                ClientToken           ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    OUT         PPRIVILEGE_SET        PrivilegeSet          ,
    INOUT       PULONG                PrivilegeSetLength    ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          );

*/
void EmuApi::EmuNtAccessCheckByTypeResultList(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID PrincipalSelfSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PrincipalSelfSid);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    POBJECT_TYPE_LIST ObjectTypeList{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    PPRIVILEGE_SET PrivilegeSet{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    PRIVILEGE_SET stPrivilegeSet{};

    if(PrivilegeSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }

    PULONG PrivilegeSetLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    ULONG rlPrivilegeSetLength{};

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }


    NTSTATUS NtAccessCheckByTypeResultListResult = NtAccessCheckByTypeResultList((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(PPRIVILEGE_SET)&stPrivilegeSet,(PULONG)&rlPrivilegeSetLength,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckByTypeResultListResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &PrincipalSelfSid);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    if(PrivilegeSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheckByTypeResultList\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCreateToken(
    OUT         PHANDLE               TokenHandle       ,
    IN          ACCESS_MASK           DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES    ObjectAttributes  ,
    IN          TOKEN_TYPE            TokenType         ,
    IN          PLUID                 AuthenticationId  ,
    IN          PLARGE_INTEGER        ExpirationTime    ,
    IN          PTOKEN_USER           User              ,
    IN          PTOKEN_GROUPS         Groups            ,
    IN          PTOKEN_PRIVILEGES     Privileges        ,
    INOPTIONAL  PTOKEN_OWNER          Owner             ,
    IN          PTOKEN_PRIMARY_GROUP  PrimaryGroup      ,
    INOPTIONAL  PTOKEN_DEFAULT_DACL   DefaultDacl       ,
    IN          PTOKEN_SOURCE         TokenSource       );

*/
void EmuApi::EmuNtCreateToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    TOKEN_TYPE TokenType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TokenType);

    PLUID AuthenticationId{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AuthenticationId, sizeof(AuthenticationId));

    LUID stAuthenticationId{};

    if(AuthenticationId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AuthenticationId, &stAuthenticationId, sizeof(stAuthenticationId));
    }

    PLARGE_INTEGER ExpirationTime{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ExpirationTime, sizeof(ExpirationTime));

    LARGE_INTEGER rlExpirationTime{};

    if(ExpirationTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ExpirationTime, &rlExpirationTime, sizeof(rlExpirationTime));
    }

    PTOKEN_USER User{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &User, sizeof(User));

    TOKEN_USER stUser{};

    if(User != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)User, &stUser, sizeof(stUser));
    }

    PTOKEN_GROUPS Groups{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Groups, sizeof(Groups));

    TOKEN_GROUPS stGroups{};

    if(Groups != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Groups, &stGroups, sizeof(stGroups));
    }

    PTOKEN_PRIVILEGES Privileges{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    TOKEN_PRIVILEGES stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    PTOKEN_OWNER Owner{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Owner, sizeof(Owner));

    TOKEN_OWNER stOwner{};

    if(Owner != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Owner, &stOwner, sizeof(stOwner));
    }

    PTOKEN_PRIMARY_GROUP PrimaryGroup{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &PrimaryGroup, sizeof(PrimaryGroup));

    TOKEN_PRIMARY_GROUP stPrimaryGroup{};

    if(PrimaryGroup != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrimaryGroup, &stPrimaryGroup, sizeof(stPrimaryGroup));
    }

    PTOKEN_DEFAULT_DACL DefaultDacl{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &DefaultDacl, sizeof(DefaultDacl));

    TOKEN_DEFAULT_DACL stDefaultDacl{};

    if(DefaultDacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultDacl, &stDefaultDacl, sizeof(stDefaultDacl));
    }

    PTOKEN_SOURCE FnTokenSource{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &FnTokenSource, sizeof(FnTokenSource));

    TOKEN_SOURCE stTokenSource{};

    if(FnTokenSource != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FnTokenSource, &stTokenSource, sizeof(FnTokenSource));
    }


    NTSTATUS NtCreateTokenResult = NtCreateToken((PHANDLE)dpTokenHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(TOKEN_TYPE)TokenType,(PLUID)&stAuthenticationId,(PLARGE_INTEGER)&rlExpirationTime,(PTOKEN_USER)&stUser,(PTOKEN_GROUPS)&stGroups,(PTOKEN_PRIVILEGES)&stPrivileges,(PTOKEN_OWNER)&stOwner,(PTOKEN_PRIMARY_GROUP)&stPrimaryGroup,(PTOKEN_DEFAULT_DACL)&stDefaultDacl,(PTOKEN_SOURCE)&stTokenSource);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCreateTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &TokenType);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AuthenticationId, sizeof(AuthenticationId));

    if(AuthenticationId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AuthenticationId, &stAuthenticationId, sizeof(stAuthenticationId));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ExpirationTime, sizeof(ExpirationTime));

    if(ExpirationTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ExpirationTime, &rlExpirationTime, sizeof(rlExpirationTime));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &User, sizeof(User));

    if(User != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)User, &stUser, sizeof(stUser));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Groups, sizeof(Groups));

    if(Groups != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Groups, &stGroups, sizeof(stGroups));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Owner, sizeof(Owner));

    if(Owner != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Owner, &stOwner, sizeof(stOwner));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &PrimaryGroup, sizeof(PrimaryGroup));

    if(PrimaryGroup != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrimaryGroup, &stPrimaryGroup, sizeof(stPrimaryGroup));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+96, &DefaultDacl, sizeof(DefaultDacl));

    if(DefaultDacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultDacl, &stDefaultDacl, sizeof(stDefaultDacl));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &FnTokenSource, sizeof(FnTokenSource));

    if(FnTokenSource != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FnTokenSource, &stTokenSource, sizeof(stTokenSource));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCreateToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCompareTokens(
    IN   HANDLE    FirstTokenHandle   ,
    IN   HANDLE    SecondTokenHandle  ,
    OUT  PBOOLEAN  Equal              );

*/
void EmuApi::EmuNtCompareTokens(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FirstTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FirstTokenHandle);

    HANDLE SecondTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SecondTokenHandle);

    PBOOLEAN Equal{};
    uc_reg_read(uc, UC_X86_REG_R8, &Equal);

    BOOLEAN rlEqual{};

    if(Equal != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Equal, &rlEqual, sizeof(rlEqual));
    }


    NTSTATUS NtCompareTokensResult = NtCompareTokens((HANDLE)FirstTokenHandle,(HANDLE)SecondTokenHandle,(PBOOLEAN)&rlEqual);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCompareTokensResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FirstTokenHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &SecondTokenHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &Equal);

    if(Equal != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Equal, &rlEqual, sizeof(rlEqual));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCompareTokens\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenThreadToken(
    IN   HANDLE       ThreadHandle   ,
    IN   ACCESS_MASK  DesiredAccess  ,
    IN   BOOLEAN      OpenAsSelf     ,
    OUT  PHANDLE      TokenHandle    );

*/
void EmuApi::EmuNtOpenThreadToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    BOOLEAN OpenAsSelf{};
    uc_reg_read(uc, UC_X86_REG_R8B, &OpenAsSelf);

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS NtOpenThreadTokenResult = NtOpenThreadToken((HANDLE)ThreadHandle,(ACCESS_MASK)DesiredAccess,(BOOLEAN)OpenAsSelf,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenThreadTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8B, &OpenAsSelf);
    uc_reg_write(uc, UC_X86_REG_R9, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenThreadToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenThreadTokenEx(
    IN   HANDLE       ThreadHandle      ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   BOOLEAN      OpenAsSelf        ,
    IN   ULONG        HandleAttributes  ,
    OUT  PHANDLE      TokenHandle       );

*/
void EmuApi::EmuNtOpenThreadTokenEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    BOOLEAN OpenAsSelf{};
    uc_reg_read(uc, UC_X86_REG_R8B, &OpenAsSelf);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R9D, &HandleAttributes);

    HANDLE TokenHandle{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TokenHandle, sizeof(TokenHandle));

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS NtOpenThreadTokenExResult = NtOpenThreadTokenEx((HANDLE)ThreadHandle,(ACCESS_MASK)DesiredAccess,(BOOLEAN)OpenAsSelf,(ULONG)HandleAttributes,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenThreadTokenExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8B, &OpenAsSelf);
    uc_reg_write(uc, UC_X86_REG_R9D, &HandleAttributes);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TokenHandle, sizeof(TokenHandle));

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenThreadTokenEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenProcessToken(
    IN   HANDLE       ProcessHandle  ,
    IN   ACCESS_MASK  DesiredAccess  ,
    OUT  PHANDLE      TokenHandle    );

*/
void EmuApi::EmuNtOpenProcessToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS NtOpenProcessTokenResult = NtOpenProcessToken((HANDLE)ProcessHandle,(ACCESS_MASK)DesiredAccess,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenProcessTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenProcessToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenProcessTokenEx(
    IN   HANDLE       ProcessHandle     ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   ULONG        HandleAttributes  ,
    OUT  PHANDLE      TokenHandle       );

*/
void EmuApi::EmuNtOpenProcessTokenEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HandleAttributes);

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS NtOpenProcessTokenExResult = NtOpenProcessTokenEx((HANDLE)ProcessHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenProcessTokenExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8D, &HandleAttributes);
    uc_reg_write(uc, UC_X86_REG_R9, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenProcessTokenEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDuplicateToken(
    IN   HANDLE              ExistingTokenHandle  ,
    IN   ACCESS_MASK         DesiredAccess        ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes     ,
    IN   BOOLEAN             EffectiveOnly        ,
    IN   TOKEN_TYPE          TokenType            ,
    OUT  PHANDLE             NewTokenHandle       );

*/
void EmuApi::EmuNtDuplicateToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ExistingTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExistingTokenHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    BOOLEAN EffectiveOnly{};
    uc_reg_read(uc, UC_X86_REG_R9B, &EffectiveOnly);

    TOKEN_TYPE TokenType{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TokenType, sizeof(TokenType));

    HANDLE NewTokenHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    HANDLE dpNewTokenHandle{};

    if(NewTokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }


    NTSTATUS NtDuplicateTokenResult = NtDuplicateToken((HANDLE)ExistingTokenHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(BOOLEAN)EffectiveOnly,(TOKEN_TYPE)TokenType,(PHANDLE)dpNewTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDuplicateTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExistingTokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &EffectiveOnly);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TokenType, sizeof(TokenType));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    if(NewTokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDuplicateToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtFilterToken(
    IN          HANDLE             ExistingTokenHandle  ,
    IN          ULONG              Flags                ,
    INOPTIONAL  PTOKEN_GROUPS      SidsToDisable        ,
    INOPTIONAL  PTOKEN_PRIVILEGES  PrivilegesToDelete   ,
    INOPTIONAL  PTOKEN_GROUPS      RestrictedSids       ,
    OUT         PHANDLE            NewTokenHandle       );

*/
void EmuApi::EmuNtFilterToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ExistingTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExistingTokenHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PTOKEN_GROUPS SidsToDisable{};
    uc_reg_read(uc, UC_X86_REG_R8, &SidsToDisable);

    TOKEN_GROUPS stSidsToDisable{};

    if(SidsToDisable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SidsToDisable, &stSidsToDisable, sizeof(stSidsToDisable));
    }

    PTOKEN_PRIVILEGES PrivilegesToDelete{};
    uc_reg_read(uc, UC_X86_REG_R9, &PrivilegesToDelete);

    TOKEN_PRIVILEGES stPrivilegesToDelete{};

    if(PrivilegesToDelete != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegesToDelete, &stPrivilegesToDelete, sizeof(stPrivilegesToDelete));
    }

    PTOKEN_GROUPS RestrictedSids{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RestrictedSids, sizeof(RestrictedSids));

    TOKEN_GROUPS stRestrictedSids{};

    if(RestrictedSids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RestrictedSids, &stRestrictedSids, sizeof(stRestrictedSids));
    }

    HANDLE NewTokenHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    HANDLE dpNewTokenHandle{};

    if(NewTokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }


    NTSTATUS NtFilterTokenResult = NtFilterToken((HANDLE)ExistingTokenHandle,(ULONG)Flags,(PTOKEN_GROUPS)&stSidsToDisable,(PTOKEN_PRIVILEGES)&stPrivilegesToDelete,(PTOKEN_GROUPS)&stRestrictedSids,(PHANDLE)dpNewTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtFilterTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExistingTokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &SidsToDisable);

    if(SidsToDisable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SidsToDisable, &stSidsToDisable, sizeof(stSidsToDisable));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &PrivilegesToDelete);

    if(PrivilegesToDelete != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegesToDelete, &stPrivilegesToDelete, sizeof(stPrivilegesToDelete));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RestrictedSids, sizeof(RestrictedSids));

    if(RestrictedSids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RestrictedSids, &stRestrictedSids, sizeof(stRestrictedSids));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    if(NewTokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtFilterToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtImpersonateAnonymousToken(
    IN  HANDLE  ThreadHandle  );

*/
void EmuApi::EmuNtImpersonateAnonymousToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);


    NTSTATUS NtImpersonateAnonymousTokenResult = NtImpersonateAnonymousToken((HANDLE)ThreadHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtImpersonateAnonymousTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtImpersonateAnonymousToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtQueryInformationToken(
    IN   HANDLE                   TokenHandle             ,
    IN   TOKEN_INFORMATION_CLASS  TokenInformationClass   ,
    OUT  PVOID                    TokenInformation        ,
    IN   ULONG                    TokenInformationLength  ,
    OUT  PULONG                   ReturnLength            );

*/
void EmuApi::EmuNtQueryInformationToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    TOKEN_INFORMATION_CLASS TokenInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TokenInformationClass);

    PVOID TokenInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &TokenInformation);

    ULONG TokenInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TokenInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtQueryInformationTokenResult = NtQueryInformationToken((HANDLE)TokenHandle,(TOKEN_INFORMATION_CLASS)TokenInformationClass,(PVOID)&TokenInformation,(ULONG)TokenInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtQueryInformationTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &TokenInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &TokenInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &TokenInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtQueryInformationToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtSetInformationToken(
    IN  HANDLE                   TokenHandle             ,
    IN  TOKEN_INFORMATION_CLASS  TokenInformationClass   ,
    IN  PVOID                    TokenInformation        ,
    IN  ULONG                    TokenInformationLength  );

*/
void EmuApi::EmuNtSetInformationToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    TOKEN_INFORMATION_CLASS TokenInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TokenInformationClass);

    PVOID TokenInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &TokenInformation);

    ULONG TokenInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TokenInformationLength);


    NTSTATUS NtSetInformationTokenResult = NtSetInformationToken((HANDLE)TokenHandle,(TOKEN_INFORMATION_CLASS)TokenInformationClass,(PVOID)&TokenInformation,(ULONG)TokenInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtSetInformationTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &TokenInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &TokenInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &TokenInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtSetInformationToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAdjustPrivilegesToken(
    IN           HANDLE             TokenHandle           ,
    IN           BOOLEAN            DisableAllPrivileges  ,
    INOPTIONAL   PTOKEN_PRIVILEGES  NewState              ,
    INOPTIONAL   ULONG              BufferLength          ,
    OUT          PTOKEN_PRIVILEGES  PreviousState         ,
    OUTOPTIONAL  PULONG             ReturnLength          );

*/
void EmuApi::EmuNtAdjustPrivilegesToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    BOOLEAN DisableAllPrivileges{};
    uc_reg_read(uc, UC_X86_REG_DL, &DisableAllPrivileges);

    PTOKEN_PRIVILEGES NewState{};
    uc_reg_read(uc, UC_X86_REG_R8, &NewState);

    TOKEN_PRIVILEGES stNewState{};

    if(NewState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }

    ULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &BufferLength);

    PTOKEN_PRIVILEGES PreviousState{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    TOKEN_PRIVILEGES stPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtAdjustPrivilegesTokenResult = NtAdjustPrivilegesToken((HANDLE)TokenHandle,(BOOLEAN)DisableAllPrivileges,(PTOKEN_PRIVILEGES)&stNewState,(ULONG)BufferLength,(PTOKEN_PRIVILEGES)&stPreviousState,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAdjustPrivilegesTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_DL, &DisableAllPrivileges);
    uc_reg_write(uc, UC_X86_REG_R8, &NewState);

    if(NewState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &BufferLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAdjustPrivilegesToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAdjustGroupsToken(
    IN          HANDLE         TokenHandle     ,
    IN          BOOLEAN        ResetToDefault  ,
    IN          PTOKEN_GROUPS  NewState        ,
    INOPTIONAL  ULONG          BufferLength    ,
    OUT         PTOKEN_GROUPS  PreviousState   ,
    OUT         PULONG         ReturnLength    );

*/
void EmuApi::EmuNtAdjustGroupsToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    BOOLEAN ResetToDefault{};
    uc_reg_read(uc, UC_X86_REG_DL, &ResetToDefault);

    PTOKEN_GROUPS NewState{};
    uc_reg_read(uc, UC_X86_REG_R8, &NewState);

    TOKEN_GROUPS stNewState{};

    if(NewState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }

    ULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &BufferLength);

    PTOKEN_GROUPS PreviousState{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    TOKEN_GROUPS stPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS NtAdjustGroupsTokenResult = NtAdjustGroupsToken((HANDLE)TokenHandle,(BOOLEAN)ResetToDefault,(PTOKEN_GROUPS)&stNewState,(ULONG)BufferLength,(PTOKEN_GROUPS)&stPreviousState,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAdjustGroupsTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_DL, &ResetToDefault);
    uc_reg_write(uc, UC_X86_REG_R8, &NewState);

    if(NewState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &BufferLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAdjustGroupsToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtPrivilegeCheck(
    IN     HANDLE          ClientToken         ,
    INOUT  PPRIVILEGE_SET  RequiredPrivileges  ,
    OUT    PBOOLEAN        Result              );

*/
void EmuApi::EmuNtPrivilegeCheck(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ClientToken);

    PPRIVILEGE_SET RequiredPrivileges{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RequiredPrivileges);

    PRIVILEGE_SET stRequiredPrivileges{};

    if(RequiredPrivileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequiredPrivileges, &stRequiredPrivileges, sizeof(stRequiredPrivileges));
    }

    PBOOLEAN Result{};
    uc_reg_read(uc, UC_X86_REG_R8, &Result);

    BOOLEAN rlResult{};

    if(Result != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }


    NTSTATUS NtPrivilegeCheckResult = NtPrivilegeCheck((HANDLE)ClientToken,(PPRIVILEGE_SET)&stRequiredPrivileges,(PBOOLEAN)&rlResult);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtPrivilegeCheckResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_RDX, &RequiredPrivileges);

    if(RequiredPrivileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequiredPrivileges, &stRequiredPrivileges, sizeof(stRequiredPrivileges));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Result);

    if(Result != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtPrivilegeCheck\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheckAndAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName       ,
    INOPTIONAL  PVOID                 HandleId            ,
    IN          PUNICODE_STRING       ObjectTypeName      ,
    IN          PUNICODE_STRING       ObjectName          ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN          ACCESS_MASK           DesiredAccess       ,
    IN          PGENERIC_MAPPING      GenericMapping      ,
    IN          BOOLEAN               ObjectCreation      ,
    OUT         PACCESS_MASK          GrantedAccess       ,
    OUT         PNTSTATUS             AccessStatus        ,
    OUT         PBOOLEAN              GenerateOnClose     );

*/
void EmuApi::EmuNtAccessCheckAndAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in NtAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in NtAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &DesiredAccess, sizeof(DesiredAccess));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS NtAccessCheckAndAuditAlarmResult = NtAccessCheckAndAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(ACCESS_MASK)DesiredAccess,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckAndAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in NtAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in NtAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheckAndAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheckByTypeAndAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName         ,
    INOPTIONAL  PVOID                 HandleId              ,
    IN          PUNICODE_STRING       ObjectTypeName        ,
    IN          PUNICODE_STRING       ObjectName            ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          AUDIT_EVENT_TYPE      AuditType             ,
    IN          ULONG                 Flags                 ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    IN          BOOLEAN               ObjectCreation        ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          ,
    OUT         PBOOLEAN              GenerateOnClose       );

*/
void EmuApi::EmuNtAccessCheckByTypeAndAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in NtAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in NtAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    PSID PrincipalSelfSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));

    AUDIT_EVENT_TYPE AuditType{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));

    POBJECT_TYPE_LIST ObjectTypeList{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS NtAccessCheckByTypeAndAuditAlarmResult = NtAccessCheckByTypeAndAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(ACCESS_MASK)DesiredAccess,(AUDIT_EVENT_TYPE)AuditType,(ULONG)Flags,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckByTypeAndAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in NtAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in NtAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheckByTypeAndAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheckByTypeResultListAndAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName         ,
    INOPTIONAL  PVOID                 HandleId              ,
    IN          PUNICODE_STRING       ObjectTypeName        ,
    IN          PUNICODE_STRING       ObjectName            ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          AUDIT_EVENT_TYPE      AuditType             ,
    IN          ULONG                 Flags                 ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    IN          BOOLEAN               ObjectCreation        ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          ,
    OUT         PBOOLEAN              GenerateOnClose       );

*/
void EmuApi::EmuNtAccessCheckByTypeResultListAndAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in NtAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in NtAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    PSID PrincipalSelfSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));

    AUDIT_EVENT_TYPE AuditType{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));

    POBJECT_TYPE_LIST ObjectTypeList{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmResult = NtAccessCheckByTypeResultListAndAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(ACCESS_MASK)DesiredAccess,(AUDIT_EVENT_TYPE)AuditType,(ULONG)Flags,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckByTypeResultListAndAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in NtAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in NtAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheckByTypeResultListAndAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
    IN          PUNICODE_STRING       SubsystemName         ,
    INOPTIONAL  PVOID                 HandleId              ,
    IN          HANDLE                ClientToken           ,
    IN          PUNICODE_STRING       ObjectTypeName        ,
    IN          PUNICODE_STRING       ObjectName            ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          AUDIT_EVENT_TYPE      AuditType             ,
    IN          ULONG                 Flags                 ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    IN          BOOLEAN               ObjectCreation        ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          ,
    OUT         PBOOLEAN              GenerateOnClose       );

*/
void EmuApi::EmuNtAccessCheckByTypeResultListAndAuditAlarmByHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in NtAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectName, sizeof(ObjectName));

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in NtAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SecurityDescriptor, sizeof(SecurityDescriptor));

    PSID PrincipalSelfSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &PrincipalSelfSid, sizeof(PrincipalSelfSid));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &DesiredAccess, sizeof(DesiredAccess));

    AUDIT_EVENT_TYPE AuditType{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &AuditType, sizeof(AuditType));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Flags, sizeof(Flags));

    POBJECT_TYPE_LIST ObjectTypeList{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+120, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+128, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+136, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandleResult = NtAccessCheckByTypeResultListAndAuditAlarmByHandle((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(HANDLE)ClientToken,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(ACCESS_MASK)DesiredAccess,(AUDIT_EVENT_TYPE)AuditType,(ULONG)Flags,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtAccessCheckByTypeResultListAndAuditAlarmByHandleResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in NtAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in NtAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtAccessCheckByTypeResultListAndAuditAlarmByHandle\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtOpenObjectAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName       ,
    INOPTIONAL  PVOID                 HandleId            ,
    IN          PUNICODE_STRING       ObjectTypeName      ,
    IN          PUNICODE_STRING       ObjectName          ,
    INOPTIONAL  PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN          HANDLE                ClientToken         ,
    IN          ACCESS_MASK           DesiredAccess       ,
    IN          ACCESS_MASK           GrantedAccess       ,
    INOPTIONAL  PPRIVILEGE_SET        Privileges          ,
    IN          BOOLEAN               ObjectCreation      ,
    IN          BOOLEAN               AccessGranted       ,
    OUT         PBOOLEAN              GenerateOnClose     );

*/
void EmuApi::EmuNtOpenObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtOpenObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in NtOpenObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in NtOpenObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    HANDLE ClientToken{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ClientToken, sizeof(ClientToken));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));

    ACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &GrantedAccess, sizeof(GrantedAccess));

    PPRIVILEGE_SET Privileges{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    PRIVILEGE_SET stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ObjectCreation, sizeof(ObjectCreation));

    BOOLEAN AccessGranted{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &AccessGranted, sizeof(AccessGranted));

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS NtOpenObjectAuditAlarmResult = NtOpenObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(ACCESS_MASK)GrantedAccess,(PPRIVILEGE_SET)&stPrivileges,(BOOLEAN)ObjectCreation,(BOOLEAN)AccessGranted,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtOpenObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtOpenObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in NtOpenObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in NtOpenObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ClientToken, sizeof(ClientToken));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &GrantedAccess, sizeof(GrantedAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &AccessGranted, sizeof(AccessGranted));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtOpenObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtPrivilegeObjectAuditAlarm(
    IN          PUNICODE_STRING  SubsystemName  ,
    INOPTIONAL  PVOID            HandleId       ,
    IN          HANDLE           ClientToken    ,
    IN          ACCESS_MASK      DesiredAccess  ,
    IN          PPRIVILEGE_SET   Privileges     ,
    IN          BOOLEAN          AccessGranted  );

*/
void EmuApi::EmuNtPrivilegeObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtPrivilegeObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    PPRIVILEGE_SET Privileges{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Privileges, sizeof(Privileges));

    PRIVILEGE_SET stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    BOOLEAN AccessGranted{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AccessGranted, sizeof(AccessGranted));


    NTSTATUS NtPrivilegeObjectAuditAlarmResult = NtPrivilegeObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(PPRIVILEGE_SET)&stPrivileges,(BOOLEAN)AccessGranted);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtPrivilegeObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtPrivilegeObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Privileges, sizeof(Privileges));

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AccessGranted, sizeof(AccessGranted));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtPrivilegeObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtCloseObjectAuditAlarm(
    IN          PUNICODE_STRING  SubsystemName    ,
    INOPTIONAL  PVOID            HandleId         ,
    IN          BOOLEAN          GenerateOnClose  );

*/
void EmuApi::EmuNtCloseObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtCloseObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    BOOLEAN GenerateOnClose{};
    uc_reg_read(uc, UC_X86_REG_R8B, &GenerateOnClose);


    NTSTATUS NtCloseObjectAuditAlarmResult = NtCloseObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(BOOLEAN)GenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtCloseObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtCloseObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8B, &GenerateOnClose);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtCloseObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtDeleteObjectAuditAlarm(
    IN          PUNICODE_STRING  SubsystemName    ,
    INOPTIONAL  PVOID            HandleId         ,
    IN          BOOLEAN          GenerateOnClose  );

*/
void EmuApi::EmuNtDeleteObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtDeleteObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    BOOLEAN GenerateOnClose{};
    uc_reg_read(uc, UC_X86_REG_R8B, &GenerateOnClose);


    NTSTATUS NtDeleteObjectAuditAlarmResult = NtDeleteObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(BOOLEAN)GenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtDeleteObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtDeleteObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8B, &GenerateOnClose);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtDeleteObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtPrivilegedServiceAuditAlarm(
    IN  PUNICODE_STRING  SubsystemName  ,
    IN  PUNICODE_STRING  ServiceName    ,
    IN  HANDLE           ClientToken    ,
    IN  PPRIVILEGE_SET   Privileges     ,
    IN  BOOLEAN          AccessGranted  );

*/
void EmuApi::EmuNtPrivilegedServiceAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in NtPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PUNICODE_STRING ServiceName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ServiceName);

    std::wstring rlwServiceName;

    USHORT rlLengthServiceName;

    USHORT rlMaxLengthServiceName;
    uc_mem_read(uc, (DWORD_PTR)ServiceName, &rlLengthServiceName, sizeof(rlLengthServiceName));
    uc_mem_read(uc, (DWORD_PTR)ServiceName+16, &rlMaxLengthServiceName, sizeof(rlMaxLengthServiceName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ServiceName+64, rlwServiceName, true, rlLengthServiceName)) { printf("Error when read ServiceName in NtPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stServiceName{};
    stServiceName.Length = rlLengthServiceName;
    stServiceName.MaximumLength = rlMaxLengthServiceName;
    stServiceName.Buffer = rlwServiceName.data();

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    PPRIVILEGE_SET Privileges{};
    uc_reg_read(uc, UC_X86_REG_R9, &Privileges);

    PRIVILEGE_SET stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    BOOLEAN AccessGranted{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AccessGranted, sizeof(AccessGranted));


    NTSTATUS NtPrivilegedServiceAuditAlarmResult = NtPrivilegedServiceAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PUNICODE_STRING)&stServiceName,(HANDLE)ClientToken,(PPRIVILEGE_SET)&stPrivileges,(BOOLEAN)AccessGranted);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtPrivilegedServiceAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in NtPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ServiceName, &stServiceName.Length, sizeof(stServiceName.Length));
    uc_mem_write(uc, (DWORD_PTR)ServiceName+16, &stServiceName.MaximumLength, sizeof(stServiceName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ServiceName+64, stServiceName.Buffer, true, stServiceName.Length)) { printf("Error when read ServiceName in NtPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9, &Privileges);

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AccessGranted, sizeof(AccessGranted));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtPrivilegedServiceAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtContinue(
    IN  PCONTEXT  ContextRecord  ,
    IN  BOOLEAN   TestAlert      );

*/
void EmuApi::EmuNtContinue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCONTEXT ContextRecord{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ContextRecord);

    CONTEXT stContextRecord{};

    if(ContextRecord != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }

    BOOLEAN TestAlert{};
    uc_reg_read(uc, UC_X86_REG_DL, &TestAlert);


    NTSTATUS NtContinueResult = NtContinue((PCONTEXT)&stContextRecord,(BOOLEAN)TestAlert);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtContinueResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ContextRecord);

    if(ContextRecord != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }
    uc_reg_write(uc, UC_X86_REG_DL, &TestAlert);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtContinue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
NtRaiseException(
    IN  PEXCEPTION_RECORD  ExceptionRecord  ,
    IN  PCONTEXT           ContextRecord    ,
    IN  BOOLEAN            FirstChance      );

*/
void EmuApi::EmuNtRaiseException(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEXCEPTION_RECORD ExceptionRecord{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExceptionRecord);

    EXCEPTION_RECORD rlExceptionRecord{};

    if(ExceptionRecord != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ExceptionRecord, &rlExceptionRecord, sizeof(rlExceptionRecord));
    }

    PCONTEXT ContextRecord{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ContextRecord);

    CONTEXT stContextRecord{};

    if(ContextRecord != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }

    BOOLEAN FirstChance{};
    uc_reg_read(uc, UC_X86_REG_R8B, &FirstChance);


    NTSTATUS NtRaiseExceptionResult = NtRaiseException((PEXCEPTION_RECORD)&rlExceptionRecord,(PCONTEXT)&stContextRecord,(BOOLEAN)FirstChance);


    uc_reg_write(uc, UC_X86_REG_EAX, &NtRaiseExceptionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExceptionRecord);

    if(ExceptionRecord != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ExceptionRecord, &rlExceptionRecord, sizeof(rlExceptionRecord));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ContextRecord);

    if(ContextRecord != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &FirstChance);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuNtRaiseException\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDelayExecution(
    IN  BOOLEAN         Alertable      ,
    IN  PLARGE_INTEGER  DelayInterval  );

*/
void EmuApi::EmuZwDelayExecution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_CL, &Alertable);

    PLARGE_INTEGER DelayInterval{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DelayInterval);

    LARGE_INTEGER rlDelayInterval{};

    if(DelayInterval != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DelayInterval, &rlDelayInterval, sizeof(rlDelayInterval));
    }


    NTSTATUS ZwDelayExecutionResult = ZwDelayExecution((BOOLEAN)Alertable,(PLARGE_INTEGER)&rlDelayInterval);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDelayExecutionResult);
    uc_reg_write(uc, UC_X86_REG_CL, &Alertable);
    uc_reg_write(uc, UC_X86_REG_RDX, &DelayInterval);

    if(DelayInterval != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DelayInterval, &rlDelayInterval, sizeof(rlDelayInterval));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDelayExecution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySystemEnvironmentValue(
    IN           PUNICODE_STRING  VariableName   ,
    OUT          PWSTR            VariableValue  ,
    IN           USHORT           ValueLength    ,
    OUTOPTIONAL  PUSHORT          ReturnLength   );

*/
void EmuApi::EmuZwQuerySystemEnvironmentValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in ZwQuerySystemEnvironmentValue"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    PWSTR VariableValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VariableValue);

    std::wstring rlwVariableValue;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableValue, rlwVariableValue)) { printf("Error when read VariableValue in ZwQuerySystemEnvironmentValue"); _CrtDbgBreak(); }

    USHORT ValueLength{};
    uc_reg_read(uc, UC_X86_REG_R8W, &ValueLength);

    PUSHORT ReturnLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReturnLength);

    USHORT rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQuerySystemEnvironmentValueResult = ZwQuerySystemEnvironmentValue((PUNICODE_STRING)&stVariableName,(PWSTR)rlwVariableValue.data(),(USHORT)ValueLength,(PUSHORT)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySystemEnvironmentValueResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in ZwQuerySystemEnvironmentValue"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableValue, rlwVariableValue)) { printf("Error when read VariableValue in ZwQuerySystemEnvironmentValue"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8W, &ValueLength);
    uc_reg_write(uc, UC_X86_REG_R9, &ReturnLength);

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySystemEnvironmentValue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetSystemEnvironmentValue(
    IN  PUNICODE_STRING  VariableName   ,
    IN  PUNICODE_STRING  VariableValue  );

*/
void EmuApi::EmuZwSetSystemEnvironmentValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in ZwSetSystemEnvironmentValue"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    PUNICODE_STRING VariableValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VariableValue);

    std::wstring rlwVariableValue;

    USHORT rlLengthVariableValue;

    USHORT rlMaxLengthVariableValue;
    uc_mem_read(uc, (DWORD_PTR)VariableValue, &rlLengthVariableValue, sizeof(rlLengthVariableValue));
    uc_mem_read(uc, (DWORD_PTR)VariableValue+16, &rlMaxLengthVariableValue, sizeof(rlMaxLengthVariableValue));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableValue+64, rlwVariableValue, true, rlLengthVariableValue)) { printf("Error when read VariableValue in ZwSetSystemEnvironmentValue"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableValue{};
    stVariableValue.Length = rlLengthVariableValue;
    stVariableValue.MaximumLength = rlMaxLengthVariableValue;
    stVariableValue.Buffer = rlwVariableValue.data();


    NTSTATUS ZwSetSystemEnvironmentValueResult = ZwSetSystemEnvironmentValue((PUNICODE_STRING)&stVariableName,(PUNICODE_STRING)&stVariableValue);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetSystemEnvironmentValueResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in ZwSetSystemEnvironmentValue"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)VariableValue, &stVariableValue.Length, sizeof(stVariableValue.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableValue+16, &stVariableValue.MaximumLength, sizeof(stVariableValue.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableValue+64, stVariableValue.Buffer, true, stVariableValue.Length)) { printf("Error when read VariableValue in ZwSetSystemEnvironmentValue"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetSystemEnvironmentValue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySystemEnvironmentValueEx(
    IN           PUNICODE_STRING  VariableName  ,
    IN           LPGUID           VendorGuid    ,
    OUTOPTIONAL  PVOID            Value         ,
    INOUT        PULONG           ValueLength   ,
    OUTOPTIONAL  PULONG           Attributes    );

*/
void EmuApi::EmuZwQuerySystemEnvironmentValueEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in ZwQuerySystemEnvironmentValueEx"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    LPGUID VendorGuid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VendorGuid);

    GUID rlVendorGuid{};

    if(VendorGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }

    PVOID Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    PULONG ValueLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ValueLength);

    ULONG rlValueLength{};

    if(ValueLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ValueLength, &rlValueLength, sizeof(rlValueLength));
    }

    PULONG Attributes{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));

    ULONG rlAttributes{};

    if(Attributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Attributes, &rlAttributes, sizeof(rlAttributes));
    }


    NTSTATUS ZwQuerySystemEnvironmentValueExResult = ZwQuerySystemEnvironmentValueEx((PUNICODE_STRING)&stVariableName,(LPGUID)&rlVendorGuid,(PVOID)&Value,(PULONG)&rlValueLength,(PULONG)&rlAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySystemEnvironmentValueExResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in ZwQuerySystemEnvironmentValueEx"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &VendorGuid);

    if(VendorGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Value);
    uc_reg_write(uc, UC_X86_REG_R9, &ValueLength);

    if(ValueLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ValueLength, &rlValueLength, sizeof(rlValueLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));

    if(Attributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Attributes, &rlAttributes, sizeof(rlAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySystemEnvironmentValueEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetSystemEnvironmentValueEx(
    IN          PUNICODE_STRING  VariableName  ,
    IN          LPGUID           VendorGuid    ,
    INOPTIONAL  PVOID            Value         ,
    IN          ULONG            ValueLength   ,
    IN          ULONG            Attributes    );

*/
void EmuApi::EmuZwSetSystemEnvironmentValueEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING VariableName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VariableName);

    std::wstring rlwVariableName;

    USHORT rlLengthVariableName;

    USHORT rlMaxLengthVariableName;
    uc_mem_read(uc, (DWORD_PTR)VariableName, &rlLengthVariableName, sizeof(rlLengthVariableName));
    uc_mem_read(uc, (DWORD_PTR)VariableName+16, &rlMaxLengthVariableName, sizeof(rlMaxLengthVariableName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, rlwVariableName, true, rlLengthVariableName)) { printf("Error when read VariableName in ZwSetSystemEnvironmentValueEx"); _CrtDbgBreak(); }

    UNICODE_STRING stVariableName{};
    stVariableName.Length = rlLengthVariableName;
    stVariableName.MaximumLength = rlMaxLengthVariableName;
    stVariableName.Buffer = rlwVariableName.data();

    LPGUID VendorGuid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &VendorGuid);

    GUID rlVendorGuid{};

    if(VendorGuid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }

    PVOID Value{};
    uc_reg_read(uc, UC_X86_REG_R8, &Value);

    ULONG ValueLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ValueLength);

    ULONG Attributes{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));


    NTSTATUS ZwSetSystemEnvironmentValueExResult = ZwSetSystemEnvironmentValueEx((PUNICODE_STRING)&stVariableName,(LPGUID)&rlVendorGuid,(PVOID)&Value,(ULONG)ValueLength,(ULONG)Attributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetSystemEnvironmentValueExResult);
    uc_mem_write(uc, (DWORD_PTR)VariableName, &stVariableName.Length, sizeof(stVariableName.Length));
    uc_mem_write(uc, (DWORD_PTR)VariableName+16, &stVariableName.MaximumLength, sizeof(stVariableName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)VariableName+64, stVariableName.Buffer, true, stVariableName.Length)) { printf("Error when read VariableName in ZwSetSystemEnvironmentValueEx"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &VendorGuid);

    if(VendorGuid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VendorGuid, &rlVendorGuid, sizeof(rlVendorGuid));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Value);
    uc_reg_write(uc, UC_X86_REG_R9D, &ValueLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Attributes, sizeof(Attributes));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetSystemEnvironmentValueEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwEnumerateSystemEnvironmentValuesEx(
    IN     ULONG   InformationClass  ,
    OUT    PVOID   Buffer            ,
    INOUT  PULONG  BufferLength      );

*/
void EmuApi::EmuZwEnumerateSystemEnvironmentValuesEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG InformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &InformationClass);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS ZwEnumerateSystemEnvironmentValuesExResult = ZwEnumerateSystemEnvironmentValuesEx((ULONG)InformationClass,(PVOID)&Buffer,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwEnumerateSystemEnvironmentValuesExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &InformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwEnumerateSystemEnvironmentValuesEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAddBootEntry(
    IN           PBOOT_ENTRY  BootEntry  ,
    OUTOPTIONAL  PULONG       Id         );

*/
void EmuApi::EmuZwAddBootEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_ENTRY BootEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootEntry);

    BOOT_ENTRY stBootEntry{};

    if(BootEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }

    PULONG Id{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Id);

    ULONG rlId{};

    if(Id != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }


    NTSTATUS ZwAddBootEntryResult = ZwAddBootEntry((PBOOT_ENTRY)&stBootEntry,(PULONG)&rlId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAddBootEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootEntry);

    if(BootEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Id);

    if(Id != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAddBootEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteBootEntry(
    IN  ULONG  Id  );

*/
void EmuApi::EmuZwDeleteBootEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Id{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Id);


    NTSTATUS ZwDeleteBootEntryResult = ZwDeleteBootEntry((ULONG)Id);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteBootEntryResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Id);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteBootEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwModifyBootEntry(
    IN  PBOOT_ENTRY  BootEntry  );

*/
void EmuApi::EmuZwModifyBootEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_ENTRY BootEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootEntry);

    BOOT_ENTRY stBootEntry{};

    if(BootEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }


    NTSTATUS ZwModifyBootEntryResult = ZwModifyBootEntry((PBOOT_ENTRY)&stBootEntry);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwModifyBootEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootEntry);

    if(BootEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootEntry, &stBootEntry, sizeof(stBootEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwModifyBootEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwEnumerateBootEntries(
    OUTOPTIONAL  PVOID   Buffer        ,
    INOUT        PULONG  BufferLength  );

*/
void EmuApi::EmuZwEnumerateBootEntries(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS ZwEnumerateBootEntriesResult = ZwEnumerateBootEntries((PVOID)&Buffer,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwEnumerateBootEntriesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_RDX, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwEnumerateBootEntries\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryBootEntryOrder(
    OUTOPTIONAL  PULONG  Ids    ,
    INOUT        PULONG  Count  );

*/
void EmuApi::EmuZwQueryBootEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    PULONG Count{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Count);

    ULONG rlCount{};

    if(Count != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }


    NTSTATUS ZwQueryBootEntryOrderResult = ZwQueryBootEntryOrder((PULONG)&rlIds,(PULONG)&rlCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryBootEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Count);

    if(Count != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryBootEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetBootEntryOrder(
    IN  PULONG  Ids    ,
    IN  ULONG   Count  );

*/
void EmuApi::EmuZwSetBootEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);


    NTSTATUS ZwSetBootEntryOrderResult = ZwSetBootEntryOrder((PULONG)&rlIds,(ULONG)Count);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetBootEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetBootEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryBootOptions(
    OUTOPTIONAL  PBOOT_OPTIONS  BootOptions        ,
    INOUT        PULONG         BootOptionsLength  );

*/
void EmuApi::EmuZwQueryBootOptions(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_OPTIONS BootOptions{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootOptions);

    BOOT_OPTIONS stBootOptions{};

    if(BootOptions != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }

    PULONG BootOptionsLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BootOptionsLength);

    ULONG rlBootOptionsLength{};

    if(BootOptionsLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootOptionsLength, &rlBootOptionsLength, sizeof(rlBootOptionsLength));
    }


    NTSTATUS ZwQueryBootOptionsResult = ZwQueryBootOptions((PBOOT_OPTIONS)&stBootOptions,(PULONG)&rlBootOptionsLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryBootOptionsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootOptions);

    if(BootOptions != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &BootOptionsLength);

    if(BootOptionsLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootOptionsLength, &rlBootOptionsLength, sizeof(rlBootOptionsLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryBootOptions\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetBootOptions(
    IN  PBOOT_OPTIONS  BootOptions     ,
    IN  ULONG          FieldsToChange  );

*/
void EmuApi::EmuZwSetBootOptions(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PBOOT_OPTIONS BootOptions{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BootOptions);

    BOOT_OPTIONS stBootOptions{};

    if(BootOptions != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }

    ULONG FieldsToChange{};
    uc_reg_read(uc, UC_X86_REG_EDX, &FieldsToChange);


    NTSTATUS ZwSetBootOptionsResult = ZwSetBootOptions((PBOOT_OPTIONS)&stBootOptions,(ULONG)FieldsToChange);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetBootOptionsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BootOptions);

    if(BootOptions != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BootOptions, &stBootOptions, sizeof(stBootOptions));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &FieldsToChange);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetBootOptions\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwTranslateFilePath(
    IN             PFILE_PATH  InputFilePath         ,
    IN             ULONG       OutputType            ,
    OUTOPTIONAL    PFILE_PATH  OutputFilePath        ,
    INOUTOPTIONAL  PULONG      OutputFilePathLength  );

*/
void EmuApi::EmuZwTranslateFilePath(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PFILE_PATH InputFilePath{};
    uc_reg_read(uc, UC_X86_REG_RCX, &InputFilePath);

    FILE_PATH stInputFilePath{};

    if(InputFilePath != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InputFilePath, &stInputFilePath, sizeof(stInputFilePath));
    }

    ULONG OutputType{};
    uc_reg_read(uc, UC_X86_REG_EDX, &OutputType);

    PFILE_PATH OutputFilePath{};
    uc_reg_read(uc, UC_X86_REG_R8, &OutputFilePath);

    FILE_PATH stOutputFilePath{};

    if(OutputFilePath != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OutputFilePath, &stOutputFilePath, sizeof(stOutputFilePath));
    }

    PULONG OutputFilePathLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutputFilePathLength);

    ULONG rlOutputFilePathLength{};

    if(OutputFilePathLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OutputFilePathLength, &rlOutputFilePathLength, sizeof(rlOutputFilePathLength));
    }


    NTSTATUS ZwTranslateFilePathResult = ZwTranslateFilePath((PFILE_PATH)&stInputFilePath,(ULONG)OutputType,(PFILE_PATH)&stOutputFilePath,(PULONG)&rlOutputFilePathLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwTranslateFilePathResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &InputFilePath);

    if(InputFilePath != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InputFilePath, &stInputFilePath, sizeof(stInputFilePath));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &OutputType);
    uc_reg_write(uc, UC_X86_REG_R8, &OutputFilePath);

    if(OutputFilePath != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OutputFilePath, &stOutputFilePath, sizeof(stOutputFilePath));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &OutputFilePathLength);

    if(OutputFilePathLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OutputFilePathLength, &rlOutputFilePathLength, sizeof(rlOutputFilePathLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwTranslateFilePath\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAddDriverEntry(
    IN           PEFI_DRIVER_ENTRY  DriverEntry  ,
    OUTOPTIONAL  PULONG             Id           );

*/
void EmuApi::EmuZwAddDriverEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEFI_DRIVER_ENTRY DriverEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverEntry);

    EFI_DRIVER_ENTRY stDriverEntry{};

    if(DriverEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }

    PULONG Id{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Id);

    ULONG rlId{};

    if(Id != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }


    NTSTATUS ZwAddDriverEntryResult = ZwAddDriverEntry((PEFI_DRIVER_ENTRY)&stDriverEntry,(PULONG)&rlId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAddDriverEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DriverEntry);

    if(DriverEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Id);

    if(Id != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Id, &rlId, sizeof(rlId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAddDriverEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteDriverEntry(
    IN  ULONG  Id  );

*/
void EmuApi::EmuZwDeleteDriverEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Id{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Id);


    NTSTATUS ZwDeleteDriverEntryResult = ZwDeleteDriverEntry((ULONG)Id);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteDriverEntryResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Id);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteDriverEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwModifyDriverEntry(
    IN  PEFI_DRIVER_ENTRY  DriverEntry  );

*/
void EmuApi::EmuZwModifyDriverEntry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEFI_DRIVER_ENTRY DriverEntry{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverEntry);

    EFI_DRIVER_ENTRY stDriverEntry{};

    if(DriverEntry != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }


    NTSTATUS ZwModifyDriverEntryResult = ZwModifyDriverEntry((PEFI_DRIVER_ENTRY)&stDriverEntry);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwModifyDriverEntryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DriverEntry);

    if(DriverEntry != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DriverEntry, &stDriverEntry, sizeof(stDriverEntry));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwModifyDriverEntry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwEnumerateDriverEntries(
    OUT    PVOID   Buffer        ,
    INOUT  PULONG  BufferLength  );

*/
void EmuApi::EmuZwEnumerateDriverEntries(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    PULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BufferLength);

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }


    NTSTATUS ZwEnumerateDriverEntriesResult = ZwEnumerateDriverEntries((PVOID)&Buffer,(PULONG)&rlBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwEnumerateDriverEntriesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_RDX, &BufferLength);

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwEnumerateDriverEntries\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryDriverEntryOrder(
    OUT    PULONG  Ids    ,
    INOUT  PULONG  Count  );

*/
void EmuApi::EmuZwQueryDriverEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    PULONG Count{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Count);

    ULONG rlCount{};

    if(Count != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }


    NTSTATUS ZwQueryDriverEntryOrderResult = ZwQueryDriverEntryOrder((PULONG)&rlIds,(PULONG)&rlCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryDriverEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Count);

    if(Count != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Count, &rlCount, sizeof(rlCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryDriverEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetDriverEntryOrder(
    IN  PULONG  Ids    ,
    IN  ULONG   Count  );

*/
void EmuApi::EmuZwSetDriverEntryOrder(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG Ids{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ids);

    ULONG rlIds{};

    if(Ids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);


    NTSTATUS ZwSetDriverEntryOrderResult = ZwSetDriverEntryOrder((PULONG)&rlIds,(ULONG)Count);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetDriverEntryOrderResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ids);

    if(Ids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Ids, &rlIds, sizeof(rlIds));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetDriverEntryOrder\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwClearEvent(
    IN  HANDLE  EventHandle  );

*/
void EmuApi::EmuZwClearEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);


    NTSTATUS ZwClearEventResult = ZwClearEvent((HANDLE)EventHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwClearEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwClearEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateEvent(
    OUT         PHANDLE             EventHandle       ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          EVENT_TYPE          EventType         ,
    IN          BOOLEAN             InitialState      );

*/
void EmuApi::EmuZwCreateEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    HANDLE dpEventHandle{};

    if(EventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    EVENT_TYPE EventType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &EventType);

    BOOLEAN InitialState{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &InitialState, sizeof(InitialState));


    NTSTATUS ZwCreateEventResult = ZwCreateEvent((PHANDLE)dpEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(EVENT_TYPE)EventType,(BOOLEAN)InitialState);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);

    if(EventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &EventType);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &InitialState, sizeof(InitialState));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenEvent(
    OUT  PHANDLE             EventHandle       ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    HANDLE dpEventHandle{};

    if(EventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenEventResult = ZwOpenEvent((PHANDLE)dpEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);

    if(EventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventHandle, &dpEventHandle, sizeof(dpEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwPulseEvent(
    IN           HANDLE  EventHandle    ,
    OUTOPTIONAL  PLONG   PreviousState  );

*/
void EmuApi::EmuZwPulseEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PLONG PreviousState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousState);

    LONG rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS ZwPulseEventResult = ZwPulseEvent((HANDLE)EventHandle,(PLONG)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwPulseEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousState);

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwPulseEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryEvent(
    IN           HANDLE                   EventHandle             ,
    IN           EVENT_INFORMATION_CLASS  EventInformationClass   ,
    OUT          PVOID                    EventInformation        ,
    IN           ULONG                    EventInformationLength  ,
    OUTOPTIONAL  PULONG                   ReturnLength            );

*/
void EmuApi::EmuZwQueryEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    EVENT_INFORMATION_CLASS EventInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &EventInformationClass);

    PVOID EventInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &EventInformation);

    ULONG EventInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &EventInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryEventResult = ZwQueryEvent((HANDLE)EventHandle,(EVENT_INFORMATION_CLASS)EventInformationClass,(PVOID)&EventInformation,(ULONG)EventInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &EventInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &EventInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &EventInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwResetEvent(
    IN           HANDLE  EventHandle    ,
    OUTOPTIONAL  PLONG   PreviousState  );

*/
void EmuApi::EmuZwResetEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PLONG PreviousState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousState);

    LONG rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS ZwResetEventResult = ZwResetEvent((HANDLE)EventHandle,(PLONG)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwResetEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousState);

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwResetEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetEvent(
    IN           HANDLE  EventHandle    ,
    OUTOPTIONAL  PLONG   PreviousState  );

*/
void EmuApi::EmuZwSetEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PLONG PreviousState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousState);

    LONG rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS ZwSetEventResult = ZwSetEvent((HANDLE)EventHandle,(PLONG)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousState);

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetEventBoostPriority(
    IN  HANDLE  EventHandle  );

*/
void EmuApi::EmuZwSetEventBoostPriority(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);


    NTSTATUS ZwSetEventBoostPriorityResult = ZwSetEventBoostPriority((HANDLE)EventHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetEventBoostPriorityResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetEventBoostPriority\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateEventPair(
    OUT         PHANDLE             EventPairHandle   ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwCreateEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);

    HANDLE dpEventPairHandle{};

    if(EventPairHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwCreateEventPairResult = ZwCreateEventPair((PHANDLE)dpEventPairHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);

    if(EventPairHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenEventPair(
    OUT  PHANDLE             EventPairHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);

    HANDLE dpEventPairHandle{};

    if(EventPairHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenEventPairResult = ZwOpenEventPair((PHANDLE)dpEventPairHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);

    if(EventPairHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventPairHandle, &dpEventPairHandle, sizeof(dpEventPairHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWaitLowEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuZwWaitLowEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS ZwWaitLowEventPairResult = ZwWaitLowEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWaitLowEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWaitLowEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWaitHighEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuZwWaitHighEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS ZwWaitHighEventPairResult = ZwWaitHighEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWaitHighEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWaitHighEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetLowWaitHighEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuZwSetLowWaitHighEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS ZwSetLowWaitHighEventPairResult = ZwSetLowWaitHighEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetLowWaitHighEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetLowWaitHighEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetHighWaitLowEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuZwSetHighWaitLowEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS ZwSetHighWaitLowEventPairResult = ZwSetHighWaitLowEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetHighWaitLowEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetHighWaitLowEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetLowEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuZwSetLowEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS ZwSetLowEventPairResult = ZwSetLowEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetLowEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetLowEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetHighEventPair(
    IN  HANDLE  EventPairHandle  );

*/
void EmuApi::EmuZwSetHighEventPair(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventPairHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventPairHandle);


    NTSTATUS ZwSetHighEventPairResult = ZwSetHighEventPair((HANDLE)EventPairHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetHighEventPairResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventPairHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetHighEventPair\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateMutant(
    OUT         PHANDLE             MutantHandle      ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          BOOLEAN             InitialOwner      );

*/
void EmuApi::EmuZwCreateMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    HANDLE dpMutantHandle{};

    if(MutantHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    BOOLEAN InitialOwner{};
    uc_reg_read(uc, UC_X86_REG_R9B, &InitialOwner);


    NTSTATUS ZwCreateMutantResult = ZwCreateMutant((PHANDLE)dpMutantHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(BOOLEAN)InitialOwner);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);

    if(MutantHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &InitialOwner);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenMutant(
    OUT  PHANDLE             MutantHandle      ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    HANDLE dpMutantHandle{};

    if(MutantHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenMutantResult = ZwOpenMutant((PHANDLE)dpMutantHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);

    if(MutantHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MutantHandle, &dpMutantHandle, sizeof(dpMutantHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryMutant(
    IN           HANDLE                    MutantHandle             ,
    IN           MUTANT_INFORMATION_CLASS  MutantInformationClass   ,
    OUT          PVOID                     MutantInformation        ,
    IN           ULONG                     MutantInformationLength  ,
    OUTOPTIONAL  PULONG                    ReturnLength             );

*/
void EmuApi::EmuZwQueryMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    MUTANT_INFORMATION_CLASS MutantInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &MutantInformationClass);

    PVOID MutantInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &MutantInformation);

    ULONG MutantInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MutantInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryMutantResult = ZwQueryMutant((HANDLE)MutantHandle,(MUTANT_INFORMATION_CLASS)MutantInformationClass,(PVOID)&MutantInformation,(ULONG)MutantInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &MutantInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &MutantInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &MutantInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReleaseMutant(
    IN           HANDLE  MutantHandle   ,
    OUTOPTIONAL  PLONG   PreviousCount  );

*/
void EmuApi::EmuZwReleaseMutant(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MutantHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MutantHandle);

    PLONG PreviousCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousCount);

    LONG rlPreviousCount{};

    if(PreviousCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }


    NTSTATUS ZwReleaseMutantResult = ZwReleaseMutant((HANDLE)MutantHandle,(PLONG)&rlPreviousCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReleaseMutantResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MutantHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousCount);

    if(PreviousCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReleaseMutant\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateSemaphore(
    OUT         PHANDLE             SemaphoreHandle   ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          LONG                InitialCount      ,
    IN          LONG                MaximumCount      );

*/
void EmuApi::EmuZwCreateSemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    HANDLE dpSemaphoreHandle{};

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    LONG InitialCount{};
    uc_reg_read(uc, UC_X86_REG_R9D, &InitialCount);

    LONG MaximumCount{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaximumCount, sizeof(MaximumCount));


    NTSTATUS ZwCreateSemaphoreResult = ZwCreateSemaphore((PHANDLE)dpSemaphoreHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(LONG)InitialCount,(LONG)MaximumCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateSemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &InitialCount);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaximumCount, sizeof(MaximumCount));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateSemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenSemaphore(
    OUT  PHANDLE             SemaphoreHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenSemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    HANDLE dpSemaphoreHandle{};

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenSemaphoreResult = ZwOpenSemaphore((PHANDLE)dpSemaphoreHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenSemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    if(SemaphoreHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SemaphoreHandle, &dpSemaphoreHandle, sizeof(dpSemaphoreHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenSemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySemaphore(
    IN           HANDLE                       SemaphoreHandle             ,
    IN           SEMAPHORE_INFORMATION_CLASS  SemaphoreInformationClass   ,
    OUT          PVOID                        SemaphoreInformation        ,
    IN           ULONG                        SemaphoreInformationLength  ,
    OUTOPTIONAL  PULONG                       ReturnLength                );

*/
void EmuApi::EmuZwQuerySemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SemaphoreInformationClass);

    PVOID SemaphoreInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &SemaphoreInformation);

    ULONG SemaphoreInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &SemaphoreInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQuerySemaphoreResult = ZwQuerySemaphore((HANDLE)SemaphoreHandle,(SEMAPHORE_INFORMATION_CLASS)SemaphoreInformationClass,(PVOID)&SemaphoreInformation,(ULONG)SemaphoreInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SemaphoreInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &SemaphoreInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &SemaphoreInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReleaseSemaphore(
    IN           HANDLE  SemaphoreHandle  ,
    IN           LONG    ReleaseCount     ,
    OUTOPTIONAL  PLONG   PreviousCount    );

*/
void EmuApi::EmuZwReleaseSemaphore(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SemaphoreHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SemaphoreHandle);

    LONG ReleaseCount{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ReleaseCount);

    PLONG PreviousCount{};
    uc_reg_read(uc, UC_X86_REG_R8, &PreviousCount);

    LONG rlPreviousCount{};

    if(PreviousCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }


    NTSTATUS ZwReleaseSemaphoreResult = ZwReleaseSemaphore((HANDLE)SemaphoreHandle,(LONG)ReleaseCount,(PLONG)&rlPreviousCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReleaseSemaphoreResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SemaphoreHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ReleaseCount);
    uc_reg_write(uc, UC_X86_REG_R8, &PreviousCount);

    if(PreviousCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousCount, &rlPreviousCount, sizeof(rlPreviousCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReleaseSemaphore\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateTimer(
    OUT         PHANDLE             TimerHandle       ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          TIMER_TYPE          TimerType         );

*/
void EmuApi::EmuZwCreateTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    HANDLE dpTimerHandle{};

    if(TimerHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    TIMER_TYPE TimerType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TimerType);


    NTSTATUS ZwCreateTimerResult = ZwCreateTimer((PHANDLE)dpTimerHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(TIMER_TYPE)TimerType);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);

    if(TimerHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &TimerType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenTimer(
    OUT  PHANDLE             TimerHandle       ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    HANDLE dpTimerHandle{};

    if(TimerHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenTimerResult = ZwOpenTimer((PHANDLE)dpTimerHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);

    if(TimerHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TimerHandle, &dpTimerHandle, sizeof(dpTimerHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCancelTimer(
    IN           HANDLE    TimerHandle   ,
    OUTOPTIONAL  PBOOLEAN  CurrentState  );

*/
void EmuApi::EmuZwCancelTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    PBOOLEAN CurrentState{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CurrentState);

    BOOLEAN rlCurrentState{};

    if(CurrentState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CurrentState, &rlCurrentState, sizeof(rlCurrentState));
    }


    NTSTATUS ZwCancelTimerResult = ZwCancelTimer((HANDLE)TimerHandle,(PBOOLEAN)&rlCurrentState);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCancelTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &CurrentState);

    if(CurrentState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CurrentState, &rlCurrentState, sizeof(rlCurrentState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCancelTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryTimer(
    IN           HANDLE                   TimerHandle             ,
    IN           TIMER_INFORMATION_CLASS  TimerInformationClass   ,
    OUT          PVOID                    TimerInformation        ,
    IN           ULONG                    TimerInformationLength  ,
    OUTOPTIONAL  PULONG                   ReturnLength            );

*/
void EmuApi::EmuZwQueryTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    TIMER_INFORMATION_CLASS TimerInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TimerInformationClass);

    PVOID TimerInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &TimerInformation);

    ULONG TimerInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TimerInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryTimerResult = ZwQueryTimer((HANDLE)TimerHandle,(TIMER_INFORMATION_CLASS)TimerInformationClass,(PVOID)&TimerInformation,(ULONG)TimerInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &TimerInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &TimerInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &TimerInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetTimer(
    IN           HANDLE              TimerHandle      ,
    IN           PLARGE_INTEGER      DueTime          ,
    INOPTIONAL   PTIMER_APC_ROUTINE  TimerApcRoutine  ,
    INOPTIONAL   PVOID               TimerContext     ,
    IN           BOOLEAN             ResumeTimer      ,
    INOPTIONAL   LONG                Period           ,
    OUTOPTIONAL  PBOOLEAN            PreviousState    );

*/
void EmuApi::EmuZwSetTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerHandle);

    PLARGE_INTEGER DueTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DueTime);

    LARGE_INTEGER rlDueTime{};

    if(DueTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DueTime, &rlDueTime, sizeof(rlDueTime));
    }

    PTIMER_APC_ROUTINE TimerApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &TimerApcRoutine);

    PVOID TimerContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &TimerContext);

    BOOLEAN ResumeTimer{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ResumeTimer, sizeof(ResumeTimer));

    LONG Period{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Period, sizeof(Period));

    PBOOLEAN PreviousState{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &PreviousState, sizeof(PreviousState));

    BOOLEAN rlPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }


    NTSTATUS ZwSetTimerResult = ZwSetTimer((HANDLE)TimerHandle,(PLARGE_INTEGER)&rlDueTime,(PTIMER_APC_ROUTINE)TimerApcRoutine,(PVOID)&TimerContext,(BOOLEAN)ResumeTimer,(LONG)Period,(PBOOLEAN)&rlPreviousState);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &DueTime);

    if(DueTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DueTime, &rlDueTime, sizeof(rlDueTime));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &TimerApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &TimerContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ResumeTimer, sizeof(ResumeTimer));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Period, sizeof(Period));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &PreviousState, sizeof(PreviousState));

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &rlPreviousState, sizeof(rlPreviousState));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySystemTime(
    OUT  PLARGE_INTEGER  SystemTime  );

*/
void EmuApi::EmuZwQuerySystemTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }


    NTSTATUS ZwQuerySystemTimeResult = ZwQuerySystemTime((PLARGE_INTEGER)&rlSystemTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySystemTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySystemTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetSystemTime(
    INOPTIONAL   PLARGE_INTEGER  SystemTime    ,
    OUTOPTIONAL  PLARGE_INTEGER  PreviousTime  );

*/
void EmuApi::EmuZwSetSystemTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER SystemTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SystemTime);

    LARGE_INTEGER rlSystemTime{};

    if(SystemTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }

    PLARGE_INTEGER PreviousTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousTime);

    LARGE_INTEGER rlPreviousTime{};

    if(PreviousTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousTime, &rlPreviousTime, sizeof(rlPreviousTime));
    }


    NTSTATUS ZwSetSystemTimeResult = ZwSetSystemTime((PLARGE_INTEGER)&rlSystemTime,(PLARGE_INTEGER)&rlPreviousTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetSystemTimeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SystemTime);

    if(SystemTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SystemTime, &rlSystemTime, sizeof(rlSystemTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousTime);

    if(PreviousTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousTime, &rlPreviousTime, sizeof(rlPreviousTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetSystemTime\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryTimerResolution(
    OUT  PULONG  MaximumTime  ,
    OUT  PULONG  MinimumTime  ,
    OUT  PULONG  CurrentTime  );

*/
void EmuApi::EmuZwQueryTimerResolution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG MaximumTime{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MaximumTime);

    ULONG rlMaximumTime{};

    if(MaximumTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaximumTime, &rlMaximumTime, sizeof(rlMaximumTime));
    }

    PULONG MinimumTime{};
    uc_reg_read(uc, UC_X86_REG_RDX, &MinimumTime);

    ULONG rlMinimumTime{};

    if(MinimumTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MinimumTime, &rlMinimumTime, sizeof(rlMinimumTime));
    }

    PULONG CurrentTime{};
    uc_reg_read(uc, UC_X86_REG_R8, &CurrentTime);

    ULONG rlCurrentTime{};

    if(CurrentTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CurrentTime, &rlCurrentTime, sizeof(rlCurrentTime));
    }


    NTSTATUS ZwQueryTimerResolutionResult = ZwQueryTimerResolution((PULONG)&rlMaximumTime,(PULONG)&rlMinimumTime,(PULONG)&rlCurrentTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryTimerResolutionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MaximumTime);

    if(MaximumTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaximumTime, &rlMaximumTime, sizeof(rlMaximumTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &MinimumTime);

    if(MinimumTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MinimumTime, &rlMinimumTime, sizeof(rlMinimumTime));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &CurrentTime);

    if(CurrentTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CurrentTime, &rlCurrentTime, sizeof(rlCurrentTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryTimerResolution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetTimerResolution(
    IN   ULONG    DesiredTime    ,
    IN   BOOLEAN  SetResolution  ,
    OUT  PULONG   ActualTime     );

*/
void EmuApi::EmuZwSetTimerResolution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG DesiredTime{};
    uc_reg_read(uc, UC_X86_REG_ECX, &DesiredTime);

    BOOLEAN SetResolution{};
    uc_reg_read(uc, UC_X86_REG_DL, &SetResolution);

    PULONG ActualTime{};
    uc_reg_read(uc, UC_X86_REG_R8, &ActualTime);

    ULONG rlActualTime{};

    if(ActualTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ActualTime, &rlActualTime, sizeof(rlActualTime));
    }


    NTSTATUS ZwSetTimerResolutionResult = ZwSetTimerResolution((ULONG)DesiredTime,(BOOLEAN)SetResolution,(PULONG)&rlActualTime);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetTimerResolutionResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &DesiredTime);
    uc_reg_write(uc, UC_X86_REG_DL, &SetResolution);
    uc_reg_write(uc, UC_X86_REG_R8, &ActualTime);

    if(ActualTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ActualTime, &rlActualTime, sizeof(rlActualTime));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetTimerResolution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAllocateLocallyUniqueId(
    OUT  PLUID  Luid  );

*/
void EmuApi::EmuZwAllocateLocallyUniqueId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLUID Luid{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Luid);

    LUID stLuid{};

    if(Luid != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Luid, &stLuid, sizeof(stLuid));
    }


    NTSTATUS ZwAllocateLocallyUniqueIdResult = ZwAllocateLocallyUniqueId((PLUID)&stLuid);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAllocateLocallyUniqueIdResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Luid);

    if(Luid != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Luid, &stLuid, sizeof(stLuid));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAllocateLocallyUniqueId\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetUuidSeed(
    IN  PCHAR  Seed  );

*/
void EmuApi::EmuZwSetUuidSeed(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCHAR Seed{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Seed);

    std::string rlaSeed;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in ZwSetUuidSeed"); _CrtDbgBreak(); }


    NTSTATUS ZwSetUuidSeedResult = ZwSetUuidSeed((PCHAR)rlaSeed.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetUuidSeedResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in ZwSetUuidSeed"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetUuidSeed\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAllocateUuids(
    OUT  PULARGE_INTEGER  Time      ,
    OUT  PULONG           Range     ,
    OUT  PULONG           Sequence  ,
    OUT  PCHAR            Seed      );

*/
void EmuApi::EmuZwAllocateUuids(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULARGE_INTEGER Time{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Time);

    ULARGE_INTEGER rlTime{};

    if(Time != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }

    PULONG Range{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Range);

    ULONG rlRange{};

    if(Range != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Range, &rlRange, sizeof(rlRange));
    }

    PULONG Sequence{};
    uc_reg_read(uc, UC_X86_REG_R8, &Sequence);

    ULONG rlSequence{};

    if(Sequence != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Sequence, &rlSequence, sizeof(rlSequence));
    }

    PCHAR Seed{};
    uc_reg_read(uc, UC_X86_REG_R9, &Seed);

    std::string rlaSeed;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in ZwAllocateUuids"); _CrtDbgBreak(); }


    NTSTATUS ZwAllocateUuidsResult = ZwAllocateUuids((PULARGE_INTEGER)&rlTime,(PULONG)&rlRange,(PULONG)&rlSequence,(PCHAR)rlaSeed.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAllocateUuidsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Time);

    if(Time != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Time, &rlTime, sizeof(rlTime));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Range);

    if(Range != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Range, &rlRange, sizeof(rlRange));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Sequence);

    if(Sequence != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Sequence, &rlSequence, sizeof(rlSequence));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Seed, rlaSeed)) { printf("Error when read Seed in ZwAllocateUuids"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAllocateUuids\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateProfile(
    OUT  PHANDLE          ProfileHandle  ,
    IN   HANDLE           Process        ,
    ,IN  PVOID            ProfileBase    ,
    IN   SIZE_T           ProfileSize    ,
    IN   ULONG            BucketSize     ,
    IN   PULONG           Buffer         ,
    IN   ULONG            BufferSize     ,
    IN   KPROFILE_SOURCE  ProfileSource  ,
    IN   KAFFINITY        Affinity       );

*/
void EmuApi::EmuZwCreateProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProfileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProfileHandle);

    HANDLE dpProfileHandle{};

    if(ProfileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProfileHandle, &dpProfileHandle, sizeof(dpProfileHandle));
    }

    HANDLE Process{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Process);

    PVOID ProfileBase{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProfileBase);

    SIZE_T ProfileSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProfileSize);

    ULONG BucketSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BucketSize, sizeof(BucketSize));

    PULONG Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG rlBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &rlBuffer, sizeof(rlBuffer));
    }

    ULONG BufferSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &BufferSize, sizeof(BufferSize));

    KPROFILE_SOURCE ProfileSource{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ProfileSource, sizeof(ProfileSource));

    KAFFINITY Affinity{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Affinity, sizeof(Affinity));


    NTSTATUS ZwCreateProfileResult = ZwCreateProfile((PHANDLE)dpProfileHandle,(HANDLE)Process,(PVOID)&ProfileBase,(SIZE_T)ProfileSize,(ULONG)BucketSize,(PULONG)&rlBuffer,(ULONG)BufferSize,(KPROFILE_SOURCE)ProfileSource,(KAFFINITY)Affinity);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateProfileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProfileHandle);

    if(ProfileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProfileHandle, &dpProfileHandle, sizeof(dpProfileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Process);
    uc_reg_write(uc, UC_X86_REG_R8, &ProfileBase);
    uc_reg_write(uc, UC_X86_REG_R9, &ProfileSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BucketSize, sizeof(BucketSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &rlBuffer, sizeof(rlBuffer));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ProfileSource, sizeof(ProfileSource));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Affinity, sizeof(Affinity));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwStartProfile(
    IN  HANDLE  ProfileHandle  );

*/
void EmuApi::EmuZwStartProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProfileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProfileHandle);


    NTSTATUS ZwStartProfileResult = ZwStartProfile((HANDLE)ProfileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwStartProfileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProfileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwStartProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwStopProfile(
    IN  HANDLE  ProfileHandle  );

*/
void EmuApi::EmuZwStopProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProfileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProfileHandle);


    NTSTATUS ZwStopProfileResult = ZwStopProfile((HANDLE)ProfileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwStopProfileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProfileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwStopProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetIntervalProfile(
    IN  ULONG            Interval  ,
    IN  KPROFILE_SOURCE  Source    );

*/
void EmuApi::EmuZwSetIntervalProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Interval{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Interval);

    KPROFILE_SOURCE Source{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Source);


    NTSTATUS ZwSetIntervalProfileResult = ZwSetIntervalProfile((ULONG)Interval,(KPROFILE_SOURCE)Source);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetIntervalProfileResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Interval);
    uc_reg_write(uc, UC_X86_REG_EDX, &Source);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetIntervalProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryIntervalProfile(
    IN   KPROFILE_SOURCE  ProfileSource  ,
    OUT  PULONG           Interval       );

*/
void EmuApi::EmuZwQueryIntervalProfile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    KPROFILE_SOURCE ProfileSource{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ProfileSource);

    PULONG Interval{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Interval);

    ULONG rlInterval{};

    if(Interval != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Interval, &rlInterval, sizeof(rlInterval));
    }


    NTSTATUS ZwQueryIntervalProfileResult = ZwQueryIntervalProfile((KPROFILE_SOURCE)ProfileSource,(PULONG)&rlInterval);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryIntervalProfileResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ProfileSource);
    uc_reg_write(uc, UC_X86_REG_RDX, &Interval);

    if(Interval != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Interval, &rlInterval, sizeof(rlInterval));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryIntervalProfile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryPerformanceCounter(
    OUT          PLARGE_INTEGER  PerformanceCounter    ,
    OUTOPTIONAL  PLARGE_INTEGER  PerformanceFrequency  );

*/
void EmuApi::EmuZwQueryPerformanceCounter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLARGE_INTEGER PerformanceCounter{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PerformanceCounter);

    LARGE_INTEGER rlPerformanceCounter{};

    if(PerformanceCounter != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PerformanceCounter, &rlPerformanceCounter, sizeof(rlPerformanceCounter));
    }

    PLARGE_INTEGER PerformanceFrequency{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PerformanceFrequency);

    LARGE_INTEGER rlPerformanceFrequency{};

    if(PerformanceFrequency != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PerformanceFrequency, &rlPerformanceFrequency, sizeof(rlPerformanceFrequency));
    }


    NTSTATUS ZwQueryPerformanceCounterResult = ZwQueryPerformanceCounter((PLARGE_INTEGER)&rlPerformanceCounter,(PLARGE_INTEGER)&rlPerformanceFrequency);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryPerformanceCounterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PerformanceCounter);

    if(PerformanceCounter != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PerformanceCounter, &rlPerformanceCounter, sizeof(rlPerformanceCounter));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PerformanceFrequency);

    if(PerformanceFrequency != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PerformanceFrequency, &rlPerformanceFrequency, sizeof(rlPerformanceFrequency));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryPerformanceCounter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateKeyedEvent(
    OUT         PHANDLE             KeyedEventHandle  ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          ULONG               Flags             );

*/
void EmuApi::EmuZwCreateKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    HANDLE dpKeyedEventHandle{};

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Flags);


    NTSTATUS ZwCreateKeyedEventResult = ZwCreateKeyedEvent((PHANDLE)dpKeyedEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenKeyedEvent(
    OUT  PHANDLE             KeyedEventHandle  ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    HANDLE dpKeyedEventHandle{};

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenKeyedEventResult = ZwOpenKeyedEvent((PHANDLE)dpKeyedEventHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    if(KeyedEventHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyedEventHandle, &dpKeyedEventHandle, sizeof(dpKeyedEventHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReleaseKeyedEvent(
    IN          HANDLE          KeyedEventHandle  ,
    IN          PVOID           KeyValue          ,
    IN          BOOLEAN         Alertable         ,
    INOPTIONAL  PLARGE_INTEGER  Timeout           );

*/
void EmuApi::EmuZwReleaseKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    PVOID KeyValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyValue);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R9, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwReleaseKeyedEventResult = ZwReleaseKeyedEvent((HANDLE)KeyedEventHandle,(PVOID)&KeyValue,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReleaseKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyValue);
    uc_reg_write(uc, UC_X86_REG_R8B, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R9, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReleaseKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWaitForKeyedEvent(
    IN          HANDLE          KeyedEventHandle  ,
    IN          PVOID           KeyValue          ,
    IN          BOOLEAN         Alertable         ,
    INOPTIONAL  PLARGE_INTEGER  Timeout           );

*/
void EmuApi::EmuZwWaitForKeyedEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyedEventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyedEventHandle);

    PVOID KeyValue{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyValue);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R9, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwWaitForKeyedEventResult = ZwWaitForKeyedEvent((HANDLE)KeyedEventHandle,(PVOID)&KeyValue,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWaitForKeyedEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyedEventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyValue);
    uc_reg_write(uc, UC_X86_REG_R8B, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R9, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWaitForKeyedEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySystemInformation(
    IN           SYSTEM_INFORMATION_CLASS  SystemInformationClass   ,
    OUTOPTIONAL  PVOID                     SystemInformation        ,
    IN           ULONG                     SystemInformationLength  ,
    OUTOPTIONAL  PULONG                    ReturnLength             );

*/
void EmuApi::EmuZwQuerySystemInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SYSTEM_INFORMATION_CLASS SystemInformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SystemInformationClass);

    PVOID SystemInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SystemInformation);

    ULONG SystemInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SystemInformationLength);

    PULONG ReturnLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReturnLength);

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQuerySystemInformationResult = ZwQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemInformationClass,(PVOID)&SystemInformation,(ULONG)SystemInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySystemInformationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SystemInformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &SystemInformation);
    uc_reg_write(uc, UC_X86_REG_R8D, &SystemInformationLength);
    uc_reg_write(uc, UC_X86_REG_R9, &ReturnLength);

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySystemInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetSystemInformation(
    IN          SYSTEM_INFORMATION_CLASS  SystemInformationClass   ,
    INOPTIONAL  PVOID                     SystemInformation        ,
    IN          ULONG                     SystemInformationLength  );

*/
void EmuApi::EmuZwSetSystemInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SYSTEM_INFORMATION_CLASS SystemInformationClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SystemInformationClass);

    PVOID SystemInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SystemInformation);

    ULONG SystemInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &SystemInformationLength);


    NTSTATUS ZwSetSystemInformationResult = ZwSetSystemInformation((SYSTEM_INFORMATION_CLASS)SystemInformationClass,(PVOID)&SystemInformation,(ULONG)SystemInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetSystemInformationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SystemInformationClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &SystemInformation);
    uc_reg_write(uc, UC_X86_REG_R8D, &SystemInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetSystemInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSystemDebugControl(
    IN           SYSDBG_COMMAND  Command             ,
    INOPTIONAL   PVOID           InputBuffer         ,
    IN           ULONG           InputBufferLength   ,
    OUTOPTIONAL  PVOID           OutputBuffer        ,
    IN           ULONG           OutputBufferLength  ,
    OUTOPTIONAL  PULONG          ReturnLength        );

*/
void EmuApi::EmuZwSystemDebugControl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SYSDBG_COMMAND Command{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Command);

    PVOID InputBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &InputBuffer);

    ULONG InputBufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InputBufferLength);

    PVOID OutputBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutputBuffer);

    ULONG OutputBufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwSystemDebugControlResult = ZwSystemDebugControl((SYSDBG_COMMAND)Command,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSystemDebugControlResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Command);
    uc_reg_write(uc, UC_X86_REG_RDX, &InputBuffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &InputBufferLength);
    uc_reg_write(uc, UC_X86_REG_R9, &OutputBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSystemDebugControl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRaiseHardError(
    IN          NTSTATUS    ErrorStatus                 ,
    IN          ULONG       NumberOfParameters          ,
    IN          ULONG       UnicodeStringParameterMask  ,
    INOPTIONAL  PULONG_PTR  Parameters                  ,
    IN          ULONG       ValidResponseOptions        ,
    OUT         PULONG      Response                    );

*/
void EmuApi::EmuZwRaiseHardError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    NTSTATUS ErrorStatus{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ErrorStatus);

    ULONG NumberOfParameters{};
    uc_reg_read(uc, UC_X86_REG_EDX, &NumberOfParameters);

    ULONG UnicodeStringParameterMask{};
    uc_reg_read(uc, UC_X86_REG_R8D, &UnicodeStringParameterMask);

    PULONG_PTR Parameters{};
    uc_reg_read(uc, UC_X86_REG_R9, &Parameters);

    unsigned long long rlParameters{};

    if(Parameters != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Parameters, &rlParameters, sizeof(rlParameters));
    }

    ULONG ValidResponseOptions{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ValidResponseOptions, sizeof(ValidResponseOptions));

    PULONG Response{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Response, sizeof(Response));

    ULONG rlResponse{};

    if(Response != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Response, &rlResponse, sizeof(rlResponse));
    }


    NTSTATUS ZwRaiseHardErrorResult = ZwRaiseHardError((NTSTATUS)ErrorStatus,(ULONG)NumberOfParameters,(ULONG)UnicodeStringParameterMask,(PULONG_PTR)&rlParameters,(ULONG)ValidResponseOptions,(PULONG)&rlResponse);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRaiseHardErrorResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ErrorStatus);
    uc_reg_write(uc, UC_X86_REG_EDX, &NumberOfParameters);
    uc_reg_write(uc, UC_X86_REG_R8D, &UnicodeStringParameterMask);
    uc_reg_write(uc, UC_X86_REG_R9, &Parameters);

    if(Parameters != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Parameters, &rlParameters, sizeof(rlParameters));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ValidResponseOptions, sizeof(ValidResponseOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Response, sizeof(Response));

    if(Response != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Response, &rlResponse, sizeof(rlResponse));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRaiseHardError\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryDefaultLocale(
    IN   BOOLEAN  UserProfile      ,
    OUT  PLCID    DefaultLocaleId  );

*/
void EmuApi::EmuZwQueryDefaultLocale(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN UserProfile{};
    uc_reg_read(uc, UC_X86_REG_CL, &UserProfile);

    PLCID DefaultLocaleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DefaultLocaleId);

    DWORD rlDefaultLocaleId{};

    if(DefaultLocaleId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultLocaleId, &rlDefaultLocaleId, sizeof(rlDefaultLocaleId));
    }


    NTSTATUS ZwQueryDefaultLocaleResult = ZwQueryDefaultLocale((BOOLEAN)UserProfile,(PLCID)&rlDefaultLocaleId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryDefaultLocaleResult);
    uc_reg_write(uc, UC_X86_REG_CL, &UserProfile);
    uc_reg_write(uc, UC_X86_REG_RDX, &DefaultLocaleId);

    if(DefaultLocaleId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultLocaleId, &rlDefaultLocaleId, sizeof(rlDefaultLocaleId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryDefaultLocale\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetDefaultLocale(
    IN  BOOLEAN  UserProfile      ,
    IN  LCID     DefaultLocaleId  );

*/
void EmuApi::EmuZwSetDefaultLocale(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN UserProfile{};
    uc_reg_read(uc, UC_X86_REG_CL, &UserProfile);

    LCID DefaultLocaleId{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DefaultLocaleId);


    NTSTATUS ZwSetDefaultLocaleResult = ZwSetDefaultLocale((BOOLEAN)UserProfile,(LCID)DefaultLocaleId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetDefaultLocaleResult);
    uc_reg_write(uc, UC_X86_REG_CL, &UserProfile);
    uc_reg_write(uc, UC_X86_REG_EDX, &DefaultLocaleId);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetDefaultLocale\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInstallUILanguage(
    OUT  LANGID *  InstallUILanguageId  );

*/
void EmuApi::EmuZwQueryInstallUILanguage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LANGID * InstallUILanguageId{};
    uc_reg_read(uc, UC_X86_REG_RCX, &InstallUILanguageId);

    WORD rlInstallUILanguageId{};

    if(InstallUILanguageId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InstallUILanguageId, &rlInstallUILanguageId, sizeof(rlInstallUILanguageId));
    }


    NTSTATUS ZwQueryInstallUILanguageResult = ZwQueryInstallUILanguage((LANGID *)&rlInstallUILanguageId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInstallUILanguageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &InstallUILanguageId);

    if(InstallUILanguageId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InstallUILanguageId, &rlInstallUILanguageId, sizeof(rlInstallUILanguageId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInstallUILanguage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryDefaultUILanguage(
    OUT  LANGID *  DefaultUILanguageId  );

*/
void EmuApi::EmuZwQueryDefaultUILanguage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LANGID * DefaultUILanguageId{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DefaultUILanguageId);

    WORD rlDefaultUILanguageId{};

    if(DefaultUILanguageId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultUILanguageId, &rlDefaultUILanguageId, sizeof(rlDefaultUILanguageId));
    }


    NTSTATUS ZwQueryDefaultUILanguageResult = ZwQueryDefaultUILanguage((LANGID *)&rlDefaultUILanguageId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryDefaultUILanguageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DefaultUILanguageId);

    if(DefaultUILanguageId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultUILanguageId, &rlDefaultUILanguageId, sizeof(rlDefaultUILanguageId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryDefaultUILanguage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetDefaultUILanguage(
    IN  LANGID  DefaultUILanguageId  );

*/
void EmuApi::EmuZwSetDefaultUILanguage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LANGID DefaultUILanguageId{};
    uc_reg_read(uc, UC_X86_REG_CX, &DefaultUILanguageId);


    NTSTATUS ZwSetDefaultUILanguageResult = ZwSetDefaultUILanguage((LANGID)DefaultUILanguageId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetDefaultUILanguageResult);
    uc_reg_write(uc, UC_X86_REG_CX, &DefaultUILanguageId);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetDefaultUILanguage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetDefaultHardErrorPort(
    IN  HANDLE  DefaultHardErrorPort  );

*/
void EmuApi::EmuZwSetDefaultHardErrorPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DefaultHardErrorPort{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DefaultHardErrorPort);


    NTSTATUS ZwSetDefaultHardErrorPortResult = ZwSetDefaultHardErrorPort((HANDLE)DefaultHardErrorPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetDefaultHardErrorPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DefaultHardErrorPort);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetDefaultHardErrorPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwShutdownSystem(
    IN  SHUTDOWN_ACTION  Action  );

*/
void EmuApi::EmuZwShutdownSystem(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SHUTDOWN_ACTION Action{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Action);


    NTSTATUS ZwShutdownSystemResult = ZwShutdownSystem((SHUTDOWN_ACTION)Action);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwShutdownSystemResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Action);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwShutdownSystem\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDisplayString(
    IN  PUNICODE_STRING  String  );

*/
void EmuApi::EmuZwDisplayString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING String{};
    uc_reg_read(uc, UC_X86_REG_RCX, &String);

    std::wstring rlwString;

    USHORT rlLengthString;

    USHORT rlMaxLengthString;
    uc_mem_read(uc, (DWORD_PTR)String, &rlLengthString, sizeof(rlLengthString));
    uc_mem_read(uc, (DWORD_PTR)String+16, &rlMaxLengthString, sizeof(rlMaxLengthString));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)String+64, rlwString, true, rlLengthString)) { printf("Error when read String in ZwDisplayString"); _CrtDbgBreak(); }

    UNICODE_STRING stString{};
    stString.Length = rlLengthString;
    stString.MaximumLength = rlMaxLengthString;
    stString.Buffer = rlwString.data();


    NTSTATUS ZwDisplayStringResult = ZwDisplayString((PUNICODE_STRING)&stString);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDisplayStringResult);
    uc_mem_write(uc, (DWORD_PTR)String, &stString.Length, sizeof(stString.Length));
    uc_mem_write(uc, (DWORD_PTR)String+16, &stString.MaximumLength, sizeof(stString.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)String+64, stString.Buffer, true, stString.Length)) { printf("Error when read String in ZwDisplayString"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDisplayString\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAddAtom(
    INOPTIONAL   PWSTR      AtomName  ,
    IN           ULONG      Length    ,
    OUTOPTIONAL  PRTL_ATOM  Atom      );

*/
void EmuApi::EmuZwAddAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in ZwAddAtom"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Length);

    PRTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_R8, &Atom);

    RTL_ATOM rlAtom{};

    if(Atom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }


    NTSTATUS ZwAddAtomResult = ZwAddAtom((PWSTR)rlwAtomName.data(),(ULONG)Length,(PRTL_ATOM)&rlAtom);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAddAtomResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in ZwAddAtom"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8, &Atom);

    if(Atom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAddAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFindAtom(
    INOPTIONAL   PWSTR      AtomName  ,
    IN           ULONG      Length    ,
    OUTOPTIONAL  PRTL_ATOM  Atom      );

*/
void EmuApi::EmuZwFindAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR AtomName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &AtomName);

    std::wstring rlwAtomName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in ZwFindAtom"); _CrtDbgBreak(); }

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Length);

    PRTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_R8, &Atom);

    RTL_ATOM rlAtom{};

    if(Atom != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }


    NTSTATUS ZwFindAtomResult = ZwFindAtom((PWSTR)rlwAtomName.data(),(ULONG)Length,(PRTL_ATOM)&rlAtom);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFindAtomResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)AtomName, rlwAtomName)) { printf("Error when read AtomName in ZwFindAtom"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &Length);
    uc_reg_write(uc, UC_X86_REG_R8, &Atom);

    if(Atom != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Atom, &rlAtom, sizeof(rlAtom));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFindAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteAtom(
    IN  RTL_ATOM  Atom  );

*/
void EmuApi::EmuZwDeleteAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_CX, &Atom);


    NTSTATUS ZwDeleteAtomResult = ZwDeleteAtom((RTL_ATOM)Atom);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteAtomResult);
    uc_reg_write(uc, UC_X86_REG_CX, &Atom);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationAtom(
    IN           RTL_ATOM                Atom                   ,
    IN           ATOM_INFORMATION_CLASS  AtomInformationClass   ,
    OUTOPTIONAL  PVOID                   AtomInformation        ,
    IN           ULONG                   AtomInformationLength  ,
    OUTOPTIONAL  PULONG                  ReturnLength           );

*/
void EmuApi::EmuZwQueryInformationAtom(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    RTL_ATOM Atom{};
    uc_reg_read(uc, UC_X86_REG_CX, &Atom);

    ATOM_INFORMATION_CLASS AtomInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &AtomInformationClass);

    PVOID AtomInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &AtomInformation);

    ULONG AtomInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AtomInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryInformationAtomResult = ZwQueryInformationAtom((RTL_ATOM)Atom,(ATOM_INFORMATION_CLASS)AtomInformationClass,(PVOID)&AtomInformation,(ULONG)AtomInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationAtomResult);
    uc_reg_write(uc, UC_X86_REG_CX, &Atom);
    uc_reg_write(uc, UC_X86_REG_EDX, &AtomInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &AtomInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &AtomInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationAtom\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCancelIoFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  );

*/
void EmuApi::EmuZwCancelIoFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }


    NTSTATUS ZwCancelIoFileResult = ZwCancelIoFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCancelIoFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCancelIoFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateNamedPipeFile(
    OUT         PHANDLE             FileHandle         ,
    IN          ULONG               DesiredAccess      ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes   ,
    OUT         PIO_STATUS_BLOCK    IoStatusBlock      ,
    IN          ULONG               ShareAccess        ,
    IN          ULONG               CreateDisposition  ,
    IN          ULONG               CreateOptions      ,
    IN          ULONG               NamedPipeType      ,
    IN          ULONG               ReadMode           ,
    IN          ULONG               CompletionMode     ,
    IN          ULONG               MaximumInstances   ,
    IN          ULONG               InboundQuota       ,
    IN          ULONG               OutboundQuota      ,
    INOPTIONAL  PLARGE_INTEGER      DefaultTimeout     );

*/
void EmuApi::EmuZwCreateNamedPipeFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ULONG DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG ShareAccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));

    ULONG CreateDisposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CreateDisposition, sizeof(CreateDisposition));

    ULONG CreateOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &CreateOptions, sizeof(CreateOptions));

    ULONG NamedPipeType{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &NamedPipeType, sizeof(NamedPipeType));

    ULONG ReadMode{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ReadMode, sizeof(ReadMode));

    ULONG CompletionMode{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &CompletionMode, sizeof(CompletionMode));

    ULONG MaximumInstances{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &MaximumInstances, sizeof(MaximumInstances));

    ULONG InboundQuota{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &InboundQuota, sizeof(InboundQuota));

    ULONG OutboundQuota{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &OutboundQuota, sizeof(OutboundQuota));

    PLARGE_INTEGER DefaultTimeout{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &DefaultTimeout, sizeof(DefaultTimeout));

    LARGE_INTEGER rlDefaultTimeout{};

    if(DefaultTimeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultTimeout, &rlDefaultTimeout, sizeof(rlDefaultTimeout));
    }


    NTSTATUS ZwCreateNamedPipeFileResult = ZwCreateNamedPipeFile((PHANDLE)dpFileHandle,(ULONG)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)ShareAccess,(ULONG)CreateDisposition,(ULONG)CreateOptions,(ULONG)NamedPipeType,(ULONG)ReadMode,(ULONG)CompletionMode,(ULONG)MaximumInstances,(ULONG)InboundQuota,(ULONG)OutboundQuota,(PLARGE_INTEGER)&rlDefaultTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateNamedPipeFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &CreateDisposition, sizeof(CreateDisposition));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &NamedPipeType, sizeof(NamedPipeType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ReadMode, sizeof(ReadMode));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &CompletionMode, sizeof(CompletionMode));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &MaximumInstances, sizeof(MaximumInstances));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &InboundQuota, sizeof(InboundQuota));
    uc_mem_write(uc, (DWORD_PTR)SP+104, &OutboundQuota, sizeof(OutboundQuota));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &DefaultTimeout, sizeof(DefaultTimeout));

    if(DefaultTimeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultTimeout, &rlDefaultTimeout, sizeof(rlDefaultTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateNamedPipeFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateMailslotFile(
    OUT  PHANDLE             FileHandle          ,
    IN   ULONG               DesiredAccess       ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes    ,
    OUT  PIO_STATUS_BLOCK    IoStatusBlock       ,
    IN   ULONG               CreateOptions       ,
    IN   ULONG               MailslotQuota       ,
    IN   ULONG               MaximumMessageSize  ,
    IN   PLARGE_INTEGER      ReadTimeout         );

*/
void EmuApi::EmuZwCreateMailslotFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ULONG DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG CreateOptions{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CreateOptions, sizeof(CreateOptions));

    ULONG MailslotQuota{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &MailslotQuota, sizeof(MailslotQuota));

    ULONG MaximumMessageSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &MaximumMessageSize, sizeof(MaximumMessageSize));

    PLARGE_INTEGER ReadTimeout{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ReadTimeout, sizeof(ReadTimeout));

    LARGE_INTEGER rlReadTimeout{};

    if(ReadTimeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReadTimeout, &rlReadTimeout, sizeof(rlReadTimeout));
    }


    NTSTATUS ZwCreateMailslotFileResult = ZwCreateMailslotFile((PHANDLE)dpFileHandle,(ULONG)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)CreateOptions,(ULONG)MailslotQuota,(ULONG)MaximumMessageSize,(PLARGE_INTEGER)&rlReadTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateMailslotFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &MailslotQuota, sizeof(MailslotQuota));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &MaximumMessageSize, sizeof(MaximumMessageSize));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ReadTimeout, sizeof(ReadTimeout));

    if(ReadTimeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReadTimeout, &rlReadTimeout, sizeof(rlReadTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateMailslotFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteFile(
    IN  POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwDeleteFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwDeleteFileResult = ZwDeleteFile((POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFlushBuffersFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  );

*/
void EmuApi::EmuZwFlushBuffersFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }


    NTSTATUS ZwFlushBuffersFileResult = ZwFlushBuffersFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFlushBuffersFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFlushBuffersFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwNotifyChangeDirectoryFile(
    IN          HANDLE            FileHandle        ,
    INOPTIONAL  HANDLE            Event             ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine        ,
    INOPTIONAL  PVOID             ApcContext        ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock     ,
    OUT         PVOID             Buffer            ,
    IN          ULONG             Length            ,
    IN          ULONG             CompletionFilter  ,
    IN          BOOLEAN           WatchTree         );

*/
void EmuApi::EmuZwNotifyChangeDirectoryFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    ULONG CompletionFilter{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));

    BOOLEAN WatchTree{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));


    NTSTATUS ZwNotifyChangeDirectoryFileResult = ZwNotifyChangeDirectoryFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(ULONG)CompletionFilter,(BOOLEAN)WatchTree);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwNotifyChangeDirectoryFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwNotifyChangeDirectoryFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryAttributesFile(
    IN   POBJECT_ATTRIBUTES       ObjectAttributes  ,
    OUT  PFILE_BASIC_INFORMATION  FileInformation   );

*/
void EmuApi::EmuZwQueryAttributesFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PFILE_BASIC_INFORMATION FileInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileInformation);

    FILE_BASIC_INFORMATION stFileInformation{};

    if(FileInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }


    NTSTATUS ZwQueryAttributesFileResult = ZwQueryAttributesFile((POBJECT_ATTRIBUTES)&rlObjectAttributes,(PFILE_BASIC_INFORMATION)&stFileInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryAttributesFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &FileInformation);

    if(FileInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryAttributesFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryFullAttributesFile(
    IN   POBJECT_ATTRIBUTES              ObjectAttributes  ,
    OUT  PFILE_NETWORK_OPEN_INFORMATION  FileInformation   );

*/
void EmuApi::EmuZwQueryFullAttributesFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PFILE_NETWORK_OPEN_INFORMATION FileInformation{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileInformation);

    FILE_NETWORK_OPEN_INFORMATION stFileInformation{};

    if(FileInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }


    NTSTATUS ZwQueryFullAttributesFileResult = ZwQueryFullAttributesFile((POBJECT_ATTRIBUTES)&rlObjectAttributes,(PFILE_NETWORK_OPEN_INFORMATION)&stFileInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryFullAttributesFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &FileInformation);

    if(FileInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileInformation, &stFileInformation, sizeof(stFileInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryFullAttributesFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryEaFile(
    IN          HANDLE            FileHandle         ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock      ,
    OUT         PVOID             Buffer             ,
    IN          ULONG             Length             ,
    IN          BOOLEAN           ReturnSingleEntry  ,
    IN          PVOID             EaList             ,
    IN          ULONG             EaListLength       ,
    INOPTIONAL  PULONG            EaIndex            ,
    ,IN         BOOLEAN           RestartScan        );

*/
void EmuApi::EmuZwQueryEaFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    BOOLEAN ReturnSingleEntry{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));

    PVOID EaList{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &EaList, sizeof(EaList));

    ULONG EaListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &EaListLength, sizeof(EaListLength));

    PULONG EaIndex{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &EaIndex, sizeof(EaIndex));

    ULONG rlEaIndex{};

    if(EaIndex != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EaIndex, &rlEaIndex, sizeof(rlEaIndex));
    }

    BOOLEAN RestartScan{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));


    NTSTATUS ZwQueryEaFileResult = ZwQueryEaFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(BOOLEAN)ReturnSingleEntry,(PVOID)&EaList,(ULONG)EaListLength,(PULONG)&rlEaIndex,(BOOLEAN)RestartScan);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryEaFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &EaList, sizeof(EaList));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &EaListLength, sizeof(EaListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &EaIndex, sizeof(EaIndex));

    if(EaIndex != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EaIndex, &rlEaIndex, sizeof(rlEaIndex));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryEaFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateFile(
    OUT         PHANDLE             FileHandle         ,
    IN          ACCESS_MASK         DesiredAccess      ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes   ,
    OUT         PIO_STATUS_BLOCK    IoStatusBlock      ,
    INOPTIONAL  PLARGE_INTEGER      AllocationSize     ,
    IN          ULONG               FileAttributes     ,
    IN          ULONG               ShareAccess        ,
    IN          ULONG               CreateDisposition  ,
    IN          ULONG               CreateOptions      ,
    INOPTIONAL  PVOID               EaBuffer           ,
    IN          ULONG               EaLength           );

*/
void EmuApi::EmuZwCreateFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER AllocationSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AllocationSize, sizeof(AllocationSize));

    LARGE_INTEGER rlAllocationSize{};

    if(AllocationSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AllocationSize, &rlAllocationSize, sizeof(rlAllocationSize));
    }

    ULONG FileAttributes{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FileAttributes, sizeof(FileAttributes));

    ULONG ShareAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ShareAccess, sizeof(ShareAccess));

    ULONG CreateDisposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CreateDisposition, sizeof(CreateDisposition));

    ULONG CreateOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &CreateOptions, sizeof(CreateOptions));

    PVOID EaBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &EaBuffer, sizeof(EaBuffer));

    ULONG EaLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &EaLength, sizeof(EaLength));


    NTSTATUS ZwCreateFileResult = ZwCreateFile((PHANDLE)dpFileHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlAllocationSize,(ULONG)FileAttributes,(ULONG)ShareAccess,(ULONG)CreateDisposition,(ULONG)CreateOptions,(PVOID)&EaBuffer,(ULONG)EaLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AllocationSize, sizeof(AllocationSize));

    if(AllocationSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AllocationSize, &rlAllocationSize, sizeof(rlAllocationSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FileAttributes, sizeof(FileAttributes));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ShareAccess, sizeof(ShareAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CreateDisposition, sizeof(CreateDisposition));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &EaBuffer, sizeof(EaBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &EaLength, sizeof(EaLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeviceIoControlFile(
    IN           HANDLE            FileHandle          ,
    INOPTIONAL   HANDLE            Event               ,
    INOPTIONAL   PIO_APC_ROUTINE   ApcRoutine          ,
    INOPTIONAL   PVOID             ApcContext          ,
    OUT          PIO_STATUS_BLOCK  IoStatusBlock       ,
    IN           ULONG             IoControlCode       ,
    INOPTIONAL   PVOID             InputBuffer         ,
    IN           ULONG             InputBufferLength   ,
    OUTOPTIONAL  PVOID             OutputBuffer        ,
    IN           ULONG             OutputBufferLength  );

*/
void EmuApi::EmuZwDeviceIoControlFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG IoControlCode{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &IoControlCode, sizeof(IoControlCode));

    PVOID InputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));

    ULONG InputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));

    PVOID OutputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));

    ULONG OutputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));


    NTSTATUS ZwDeviceIoControlFileResult = ZwDeviceIoControlFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)IoControlCode,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeviceIoControlFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &IoControlCode, sizeof(IoControlCode));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeviceIoControlFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFsControlFile(
    IN           HANDLE            FileHandle          ,
    INOPTIONAL   HANDLE            Event               ,
    INOPTIONAL   PIO_APC_ROUTINE   ApcRoutine          ,
    INOPTIONAL   PVOID             ApcContext          ,
    OUT          PIO_STATUS_BLOCK  IoStatusBlock       ,
    IN           ULONG             FsControlCode       ,
    INOPTIONAL   PVOID             InputBuffer         ,
    IN           ULONG             InputBufferLength   ,
    OUTOPTIONAL  PVOID             OutputBuffer        ,
    IN           ULONG             OutputBufferLength  );

*/
void EmuApi::EmuZwFsControlFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG FsControlCode{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FsControlCode, sizeof(FsControlCode));

    PVOID InputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));

    ULONG InputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));

    PVOID OutputBuffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));

    ULONG OutputBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));


    NTSTATUS ZwFsControlFileResult = ZwFsControlFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)FsControlCode,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFsControlFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FsControlCode, sizeof(FsControlCode));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InputBuffer, sizeof(InputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &InputBufferLength, sizeof(InputBufferLength));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &OutputBuffer, sizeof(OutputBuffer));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &OutputBufferLength, sizeof(OutputBufferLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFsControlFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLockFile(
    IN          HANDLE            FileHandle       ,
    INOPTIONAL  HANDLE            Event            ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine       ,
    INOPTIONAL  PVOID             ApcContext       ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock    ,
    IN          PLARGE_INTEGER    ByteOffset       ,
    IN          PLARGE_INTEGER    Length           ,
    IN          ULONG             Key              ,
    IN          BOOLEAN           FailImmediately  ,
    IN          BOOLEAN           ExclusiveLock    );

*/
void EmuApi::EmuZwLockFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PLARGE_INTEGER Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    LARGE_INTEGER rlLength{};

    if(Length != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }

    ULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Key, sizeof(Key));

    BOOLEAN FailImmediately{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &FailImmediately, sizeof(FailImmediately));

    BOOLEAN ExclusiveLock{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ExclusiveLock, sizeof(ExclusiveLock));


    NTSTATUS ZwLockFileResult = ZwLockFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlByteOffset,(PLARGE_INTEGER)&rlLength,(ULONG)Key,(BOOLEAN)FailImmediately,(BOOLEAN)ExclusiveLock);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLockFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    if(Length != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Key, sizeof(Key));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &FailImmediately, sizeof(FailImmediately));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ExclusiveLock, sizeof(ExclusiveLock));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLockFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenFile(
    OUT  PHANDLE             FileHandle        ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  ,
    OUT  PIO_STATUS_BLOCK    IoStatusBlock     ,
    IN   ULONG               ShareAccess       ,
    IN   ULONG               OpenOptions       );

*/
void EmuApi::EmuZwOpenFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE dpFileHandle{};

    if(FileHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG ShareAccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));

    ULONG OpenOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &OpenOptions, sizeof(OpenOptions));


    NTSTATUS ZwOpenFileResult = ZwOpenFile((PHANDLE)dpFileHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)ShareAccess,(ULONG)OpenOptions);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);

    if(FileHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FileHandle, &dpFileHandle, sizeof(dpFileHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ShareAccess, sizeof(ShareAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &OpenOptions, sizeof(OpenOptions));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryDirectoryFile(
    IN          HANDLE                  FileHandle            ,
    INOPTIONAL  HANDLE                  Event                 ,
    INOPTIONAL  PIO_APC_ROUTINE         ApcRoutine            ,
    INOPTIONAL  PVOID                   ApcContext            ,
    OUT         PIO_STATUS_BLOCK        IoStatusBlock         ,
    OUT         PVOID                   FileInformation       ,
    IN          ULONG                   Length                ,
    IN          FILE_INFORMATION_CLASS  FileInformationClass  ,
    IN          BOOLEAN                 ReturnSingleEntry     ,
    INOPTIONAL  PUNICODE_STRING         FileName              ,
    IN          BOOLEAN                 RestartScan           );

*/
void EmuApi::EmuZwQueryDirectoryFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FileInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &FileInformation, sizeof(FileInformation));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    FILE_INFORMATION_CLASS FileInformationClass{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &FileInformationClass, sizeof(FileInformationClass));

    BOOLEAN ReturnSingleEntry{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ReturnSingleEntry, sizeof(ReturnSingleEntry));

    PUNICODE_STRING FileName{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &FileName, sizeof(FileName));

    std::wstring rlwFileName;

    USHORT rlLengthFileName;

    USHORT rlMaxLengthFileName;
    uc_mem_read(uc, (DWORD_PTR)FileName, &rlLengthFileName, sizeof(rlLengthFileName));
    uc_mem_read(uc, (DWORD_PTR)FileName+16, &rlMaxLengthFileName, sizeof(rlMaxLengthFileName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)FileName+64, rlwFileName, true, rlLengthFileName)) { printf("Error when read FileName in ZwQueryDirectoryFile"); _CrtDbgBreak(); }

    UNICODE_STRING stFileName{};
    stFileName.Length = rlLengthFileName;
    stFileName.MaximumLength = rlMaxLengthFileName;
    stFileName.Buffer = rlwFileName.data();

    BOOLEAN RestartScan{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &RestartScan, sizeof(RestartScan));


    NTSTATUS ZwQueryDirectoryFileResult = ZwQueryDirectoryFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FileInformation,(ULONG)Length,(FILE_INFORMATION_CLASS)FileInformationClass,(BOOLEAN)ReturnSingleEntry,(PUNICODE_STRING)&stFileName,(BOOLEAN)RestartScan);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryDirectoryFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &FileInformation, sizeof(FileInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &FileInformationClass, sizeof(FileInformationClass));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ReturnSingleEntry, sizeof(ReturnSingleEntry));
    uc_mem_write(uc, (DWORD_PTR)FileName, &stFileName.Length, sizeof(stFileName.Length));
    uc_mem_write(uc, (DWORD_PTR)FileName+16, &stFileName.MaximumLength, sizeof(stFileName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)FileName+64, stFileName.Buffer, true, stFileName.Length)) { printf("Error when read FileName in ZwQueryDirectoryFile"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &RestartScan, sizeof(RestartScan));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryDirectoryFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationFile(
    IN   HANDLE                  FileHandle            ,
    OUT  PIO_STATUS_BLOCK        IoStatusBlock         ,
    OUT  PVOID                   FileInformation       ,
    IN   ULONG                   Length                ,
    IN   FILE_INFORMATION_CLASS  FileInformationClass  );

*/
void EmuApi::EmuZwQueryInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FileInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FileInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FILE_INFORMATION_CLASS FileInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));


    NTSTATUS ZwQueryInformationFileResult = ZwQueryInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FileInformation,(ULONG)Length,(FILE_INFORMATION_CLASS)FileInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FileInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryQuotaInformationFile(
    IN          HANDLE            FileHandle         ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock      ,
    OUT         PVOID             Buffer             ,
    IN          ULONG             Length             ,
    IN          BOOLEAN           ReturnSingleEntry  ,
    INOPTIONAL  PVOID             SidList            ,
    IN          ULONG             SidListLength      ,
    INOPTIONAL  PSID              StartSid           ,
    IN          BOOLEAN           RestartScan        );

*/
void EmuApi::EmuZwQueryQuotaInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    BOOLEAN ReturnSingleEntry{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));

    PVOID SidList{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SidList, sizeof(SidList));

    ULONG SidListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &SidListLength, sizeof(SidListLength));

    PSID StartSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &StartSid, sizeof(StartSid));

    BOOLEAN RestartScan{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));


    NTSTATUS ZwQueryQuotaInformationFileResult = ZwQueryQuotaInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(BOOLEAN)ReturnSingleEntry,(PVOID)&SidList,(ULONG)SidListLength,(PSID)&StartSid,(BOOLEAN)RestartScan);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryQuotaInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnSingleEntry, sizeof(ReturnSingleEntry));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SidList, sizeof(SidList));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &SidListLength, sizeof(SidListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &StartSid, sizeof(StartSid));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &RestartScan, sizeof(RestartScan));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryQuotaInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryVolumeInformationFile(
    IN   HANDLE                FileHandle          ,
    OUT  PIO_STATUS_BLOCK      IoStatusBlock       ,
    OUT  PVOID                 FsInformation       ,
    IN   ULONG                 Length              ,
    IN   FS_INFORMATION_CLASS  FsInformationClass  );

*/
void EmuApi::EmuZwQueryVolumeInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FsInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FsInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FS_INFORMATION_CLASS FsInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));


    NTSTATUS ZwQueryVolumeInformationFileResult = ZwQueryVolumeInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FsInformation,(ULONG)Length,(FS_INFORMATION_CLASS)FsInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryVolumeInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FsInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryVolumeInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReadFile(
    IN          HANDLE            FileHandle     ,
    INOPTIONAL  HANDLE            Event          ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine     ,
    INOPTIONAL  PVOID             ApcContext     ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock  ,
    OUT         PVOID             Buffer         ,
    IN          ULONG             Length         ,
    INOPTIONAL  PLARGE_INTEGER    ByteOffset     ,
    INOPTIONAL  PULONG            Key            );

*/
void EmuApi::EmuZwReadFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS ZwReadFileResult = ZwReadFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReadFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReadFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationFile(
    IN   HANDLE                  FileHandle            ,
    OUT  PIO_STATUS_BLOCK        IoStatusBlock         ,
    IN   PVOID                   FileInformation       ,
    IN   ULONG                   Length                ,
    IN   FILE_INFORMATION_CLASS  FileInformationClass  );

*/
void EmuApi::EmuZwSetInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FileInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FileInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FILE_INFORMATION_CLASS FileInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));


    NTSTATUS ZwSetInformationFileResult = ZwSetInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FileInformation,(ULONG)Length,(FILE_INFORMATION_CLASS)FileInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FileInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FileInformationClass, sizeof(FileInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetQuotaInformationFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN   PVOID             Buffer         ,
    IN   ULONG             Length         );

*/
void EmuApi::EmuZwSetQuotaInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);


    NTSTATUS ZwSetQuotaInformationFileResult = ZwSetQuotaInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetQuotaInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetQuotaInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetVolumeInformationFile(
    IN   HANDLE                FileHandle          ,
    OUT  PIO_STATUS_BLOCK      IoStatusBlock       ,
    IN   PVOID                 FsInformation       ,
    IN   ULONG                 Length              ,
    IN   FS_INFORMATION_CLASS  FsInformationClass  );

*/
void EmuApi::EmuZwSetVolumeInformationFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID FsInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &FsInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    FS_INFORMATION_CLASS FsInformationClass{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));


    NTSTATUS ZwSetVolumeInformationFileResult = ZwSetVolumeInformationFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&FsInformation,(ULONG)Length,(FS_INFORMATION_CLASS)FsInformationClass);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetVolumeInformationFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &FsInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &FsInformationClass, sizeof(FsInformationClass));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetVolumeInformationFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWriteFile(
    IN          HANDLE            FileHandle     ,
    INOPTIONAL  HANDLE            Event          ,
    INOPTIONAL  PIO_APC_ROUTINE   ApcRoutine     ,
    INOPTIONAL  PVOID             ApcContext     ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN          PVOID             Buffer         ,
    IN          ULONG             Length         ,
    INOPTIONAL  PLARGE_INTEGER    ByteOffset     ,
    INOPTIONAL  PULONG            Key            );

*/
void EmuApi::EmuZwWriteFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS ZwWriteFileResult = ZwWriteFile((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWriteFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWriteFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnlockFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN   PLARGE_INTEGER    ByteOffset     ,
    IN   PLARGE_INTEGER    Length         ,
    IN   ULONG             Key            );

*/
void EmuApi::EmuZwUnlockFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER ByteOffset{};
    uc_reg_read(uc, UC_X86_REG_R8, &ByteOffset);

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PLARGE_INTEGER Length{};
    uc_reg_read(uc, UC_X86_REG_R9, &Length);

    LARGE_INTEGER rlLength{};

    if(Length != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }

    ULONG Key{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Key, sizeof(Key));


    NTSTATUS ZwUnlockFileResult = ZwUnlockFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlByteOffset,(PLARGE_INTEGER)&rlLength,(ULONG)Key);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnlockFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ByteOffset);

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Length);

    if(Length != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Length, &rlLength, sizeof(rlLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Key, sizeof(Key));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnlockFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReadFileScatter(
    IN          HANDLE                 FileHandle     ,
    INOPTIONAL  HANDLE                 Event          ,
    INOPTIONAL  PIO_APC_ROUTINE        ApcRoutine     ,
    INOPTIONAL  PVOID                  ApcContext     ,
    OUT         PIO_STATUS_BLOCK       IoStatusBlock  ,
    IN          PFILE_SEGMENT_ELEMENT  SegmentArray   ,
    IN          ULONG                  Length         ,
    INOPTIONAL  PLARGE_INTEGER         ByteOffset     ,
    INOPTIONAL  PULONG                 Key            );

*/
void EmuApi::EmuZwReadFileScatter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PFILE_SEGMENT_ELEMENT SegmentArray{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    union _FILE_SEGMENT_ELEMENT rlSegmentArray{};

    if(SegmentArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS ZwReadFileScatterResult = ZwReadFileScatter((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PFILE_SEGMENT_ELEMENT)&rlSegmentArray,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReadFileScatterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    if(SegmentArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReadFileScatter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetEaFile(
    IN   HANDLE            FileHandle     ,
    OUT  PIO_STATUS_BLOCK  IoStatusBlock  ,
    IN   PVOID             Buffer         ,
    IN   ULONG             Length         );

*/
void EmuApi::EmuZwSetEaFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_RDX, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);


    NTSTATUS ZwSetEaFileResult = ZwSetEaFile((HANDLE)FileHandle,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PVOID)&Buffer,(ULONG)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetEaFileResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetEaFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWriteFileGather(
    IN          HANDLE                 FileHandle     ,
    INOPTIONAL  HANDLE                 Event          ,
    INOPTIONAL  PIO_APC_ROUTINE        ApcRoutine     ,
    INOPTIONAL  PVOID                  ApcContext     ,
    OUT         PIO_STATUS_BLOCK       IoStatusBlock  ,
    IN          PFILE_SEGMENT_ELEMENT  SegmentArray   ,
    IN          ULONG                  Length         ,
    INOPTIONAL  PLARGE_INTEGER         ByteOffset     ,
    INOPTIONAL  PULONG                 Key            );

*/
void EmuApi::EmuZwWriteFileGather(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PFILE_SEGMENT_ELEMENT SegmentArray{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    union _FILE_SEGMENT_ELEMENT rlSegmentArray{};

    if(SegmentArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }

    ULONG Length{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));

    PLARGE_INTEGER ByteOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    LARGE_INTEGER rlByteOffset{};

    if(ByteOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }

    PULONG Key{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    ULONG rlKey{};

    if(Key != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }


    NTSTATUS ZwWriteFileGatherResult = ZwWriteFileGather((HANDLE)FileHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PFILE_SEGMENT_ELEMENT)&rlSegmentArray,(ULONG)Length,(PLARGE_INTEGER)&rlByteOffset,(PULONG)&rlKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWriteFileGatherResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SegmentArray, sizeof(SegmentArray));

    if(SegmentArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SegmentArray, &rlSegmentArray, sizeof(rlSegmentArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ByteOffset, sizeof(ByteOffset));

    if(ByteOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ByteOffset, &rlByteOffset, sizeof(rlByteOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Key, sizeof(Key));

    if(Key != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Key, &rlKey, sizeof(rlKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWriteFileGather\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLoadDriver(
    IN  PUNICODE_STRING  DriverServiceName  );

*/
void EmuApi::EmuZwLoadDriver(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DriverServiceName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverServiceName);

    std::wstring rlwDriverServiceName;

    USHORT rlLengthDriverServiceName;

    USHORT rlMaxLengthDriverServiceName;
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName, &rlLengthDriverServiceName, sizeof(rlLengthDriverServiceName));
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName+16, &rlMaxLengthDriverServiceName, sizeof(rlMaxLengthDriverServiceName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, rlwDriverServiceName, true, rlLengthDriverServiceName)) { printf("Error when read DriverServiceName in ZwLoadDriver"); _CrtDbgBreak(); }

    UNICODE_STRING stDriverServiceName{};
    stDriverServiceName.Length = rlLengthDriverServiceName;
    stDriverServiceName.MaximumLength = rlMaxLengthDriverServiceName;
    stDriverServiceName.Buffer = rlwDriverServiceName.data();


    NTSTATUS ZwLoadDriverResult = ZwLoadDriver((PUNICODE_STRING)&stDriverServiceName);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLoadDriverResult);
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName, &stDriverServiceName.Length, sizeof(stDriverServiceName.Length));
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName+16, &stDriverServiceName.MaximumLength, sizeof(stDriverServiceName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, stDriverServiceName.Buffer, true, stDriverServiceName.Length)) { printf("Error when read DriverServiceName in ZwLoadDriver"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLoadDriver\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnloadDriver(
    IN  PUNICODE_STRING  DriverServiceName  );

*/
void EmuApi::EmuZwUnloadDriver(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING DriverServiceName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DriverServiceName);

    std::wstring rlwDriverServiceName;

    USHORT rlLengthDriverServiceName;

    USHORT rlMaxLengthDriverServiceName;
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName, &rlLengthDriverServiceName, sizeof(rlLengthDriverServiceName));
    uc_mem_read(uc, (DWORD_PTR)DriverServiceName+16, &rlMaxLengthDriverServiceName, sizeof(rlMaxLengthDriverServiceName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, rlwDriverServiceName, true, rlLengthDriverServiceName)) { printf("Error when read DriverServiceName in ZwUnloadDriver"); _CrtDbgBreak(); }

    UNICODE_STRING stDriverServiceName{};
    stDriverServiceName.Length = rlLengthDriverServiceName;
    stDriverServiceName.MaximumLength = rlMaxLengthDriverServiceName;
    stDriverServiceName.Buffer = rlwDriverServiceName.data();


    NTSTATUS ZwUnloadDriverResult = ZwUnloadDriver((PUNICODE_STRING)&stDriverServiceName);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnloadDriverResult);
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName, &stDriverServiceName.Length, sizeof(stDriverServiceName.Length));
    uc_mem_write(uc, (DWORD_PTR)DriverServiceName+16, &stDriverServiceName.MaximumLength, sizeof(stDriverServiceName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DriverServiceName+64, stDriverServiceName.Buffer, true, stDriverServiceName.Length)) { printf("Error when read DriverServiceName in ZwUnloadDriver"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnloadDriver\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateIoCompletion(
    OUT         PHANDLE             IoCompletionHandle  ,
    IN          ACCESS_MASK         DesiredAccess       ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes    ,
    IN          ULONG               Count               );

*/
void EmuApi::EmuZwCreateIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    HANDLE dpIoCompletionHandle{};

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Count);


    NTSTATUS ZwCreateIoCompletionResult = ZwCreateIoCompletion((PHANDLE)dpIoCompletionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)Count);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &Count);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenIoCompletion(
    OUT  PHANDLE             IoCompletionHandle  ,
    IN   ACCESS_MASK         DesiredAccess       ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes    );

*/
void EmuApi::EmuZwOpenIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    HANDLE dpIoCompletionHandle{};

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenIoCompletionResult = ZwOpenIoCompletion((PHANDLE)dpIoCompletionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    if(IoCompletionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoCompletionHandle, &dpIoCompletionHandle, sizeof(dpIoCompletionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryIoCompletion(
    IN           HANDLE                           IoCompletionHandle             ,
    IN           IO_COMPLETION_INFORMATION_CLASS  IoCompletionInformationClass   ,
    OUT          PVOID                            IoCompletionInformation        ,
    IN           ULONG                            IoCompletionInformationLength  ,
    OUTOPTIONAL  PULONG                           ReturnLength                   );

*/
void EmuApi::EmuZwQueryIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &IoCompletionInformationClass);

    PVOID IoCompletionInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &IoCompletionInformation);

    ULONG IoCompletionInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &IoCompletionInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryIoCompletionResult = ZwQueryIoCompletion((HANDLE)IoCompletionHandle,(IO_COMPLETION_INFORMATION_CLASS)IoCompletionInformationClass,(PVOID)&IoCompletionInformation,(ULONG)IoCompletionInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &IoCompletionInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &IoCompletionInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &IoCompletionInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetIoCompletion(
    IN          HANDLE     IoCompletionHandle   ,
    IN          PVOID      KeyContext           ,
    INOPTIONAL  PVOID      ApcContext           ,
    IN          NTSTATUS   IoStatus             ,
    IN          ULONG_PTR  IoStatusInformation  );

*/
void EmuApi::EmuZwSetIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    PVOID KeyContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyContext);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcContext);

    NTSTATUS IoStatus{};
    uc_reg_read(uc, UC_X86_REG_R9D, &IoStatus);

    ULONG_PTR IoStatusInformation{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusInformation, sizeof(IoStatusInformation));


    NTSTATUS ZwSetIoCompletionResult = ZwSetIoCompletion((HANDLE)IoCompletionHandle,(PVOID)&KeyContext,(PVOID)&ApcContext,(NTSTATUS)IoStatus,(ULONG_PTR)IoStatusInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyContext);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcContext);
    uc_reg_write(uc, UC_X86_REG_R9D, &IoStatus);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusInformation, sizeof(IoStatusInformation));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRemoveIoCompletion(
    IN          HANDLE            IoCompletionHandle  ,
    OUT         PVOID *           KeyContext          ,
    OUT         PVOID *           ApcContext          ,
    OUT         PIO_STATUS_BLOCK  IoStatusBlock       ,
    INOPTIONAL  PLARGE_INTEGER    Timeout             );

*/
void EmuApi::EmuZwRemoveIoCompletion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE IoCompletionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &IoCompletionHandle);

    PVOID * KeyContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyContext);

    PVOID * dpKeyContext{};

    if(KeyContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyContext, &dpKeyContext, sizeof(dpKeyContext));
    }

    PVOID * ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcContext);

    PVOID * dpApcContext{};

    if(ApcContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ApcContext, &dpApcContext, sizeof(dpApcContext));
    }

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatusBlock);

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwRemoveIoCompletionResult = ZwRemoveIoCompletion((HANDLE)IoCompletionHandle,(PVOID *)&dpKeyContext,(PVOID *)&dpApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRemoveIoCompletionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &IoCompletionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyContext);

    if(KeyContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyContext, &dpKeyContext, sizeof(dpKeyContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ApcContext);

    if(ApcContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ApcContext, &dpApcContext, sizeof(dpApcContext));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatusBlock);

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRemoveIoCompletion\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCallbackReturn(
    IN   PVOID     OutputBuffer  ,
    ,IN  ULONG     OutputLength  ,
    IN   NTSTATUS  Status        );

*/
void EmuApi::EmuZwCallbackReturn(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID OutputBuffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &OutputBuffer);

    ULONG OutputLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &OutputLength);

    NTSTATUS Status{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Status);


    NTSTATUS ZwCallbackReturnResult = ZwCallbackReturn((PVOID)&OutputBuffer,(ULONG)OutputLength,(NTSTATUS)Status);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCallbackReturnResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &OutputBuffer);
    uc_reg_write(uc, UC_X86_REG_EDX, &OutputLength);
    uc_reg_write(uc, UC_X86_REG_R8D, &Status);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCallbackReturn\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryDebugFilterState(
    IN  ULONG  ComponentId  ,
    IN  ULONG  Level        );

*/
void EmuApi::EmuZwQueryDebugFilterState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);


    NTSTATUS ZwQueryDebugFilterStateResult = ZwQueryDebugFilterState((ULONG)ComponentId,(ULONG)Level);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryDebugFilterStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryDebugFilterState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetDebugFilterState(
    IN  ULONG    ComponentId  ,
    IN  ULONG    Level        ,
    IN  BOOLEAN  State        );

*/
void EmuApi::EmuZwSetDebugFilterState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ComponentId{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ComponentId);

    ULONG Level{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Level);

    BOOLEAN State{};
    uc_reg_read(uc, UC_X86_REG_R8B, &State);


    NTSTATUS ZwSetDebugFilterStateResult = ZwSetDebugFilterState((ULONG)ComponentId,(ULONG)Level,(BOOLEAN)State);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetDebugFilterStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ComponentId);
    uc_reg_write(uc, UC_X86_REG_EDX, &Level);
    uc_reg_write(uc, UC_X86_REG_R8B, &State);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetDebugFilterState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwYieldExecution(VOID);

*/
void EmuApi::EmuZwYieldExecution(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS ZwYieldExecutionResult = ZwYieldExecution();


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwYieldExecutionResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwYieldExecution\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreatePort(
    OUT         PHANDLE             PortHandle               ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes         ,
    IN          ULONG               MaxConnectionInfoLength  ,
    IN          ULONG               MaxMessageLength         ,
    INOPTIONAL  ULONG               MaxPoolUsage             );

*/
void EmuApi::EmuZwCreatePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG MaxConnectionInfoLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);

    ULONG MaxMessageLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MaxMessageLength);

    ULONG MaxPoolUsage{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));


    NTSTATUS ZwCreatePortResult = ZwCreatePort((PHANDLE)dpPortHandle,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)MaxConnectionInfoLength,(ULONG)MaxMessageLength,(ULONG)MaxPoolUsage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreatePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);
    uc_reg_write(uc, UC_X86_REG_R9D, &MaxMessageLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreatePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateWaitablePort(
    OUT         PHANDLE             PortHandle               ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes         ,
    IN          ULONG               MaxConnectionInfoLength  ,
    IN          ULONG               MaxMessageLength         ,
    INOPTIONAL  ULONG               MaxPoolUsage             );

*/
void EmuApi::EmuZwCreateWaitablePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG MaxConnectionInfoLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);

    ULONG MaxMessageLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MaxMessageLength);

    ULONG MaxPoolUsage{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));


    NTSTATUS ZwCreateWaitablePortResult = ZwCreateWaitablePort((PHANDLE)dpPortHandle,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)MaxConnectionInfoLength,(ULONG)MaxMessageLength,(ULONG)MaxPoolUsage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateWaitablePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &MaxConnectionInfoLength);
    uc_reg_write(uc, UC_X86_REG_R9D, &MaxMessageLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MaxPoolUsage, sizeof(MaxPoolUsage));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateWaitablePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwConnectPort(
    OUT            PHANDLE                       PortHandle                   ,
    IN             PUNICODE_STRING               PortName                     ,
    IN             PSECURITY_QUALITY_OF_SERVICE  SecurityQos                  ,
    INOUTOPTIONAL  PPORT_VIEW                    ClientView                   ,
    INOUTOPTIONAL  PREMOTE_PORT_VIEW             ServerView                   ,
    OUTOPTIONAL    PULONG                        MaxMessageLength             ,
    INOUTOPTIONAL  PVOID                         ConnectionInformation        ,
    INOUTOPTIONAL  PULONG                        ConnectionInformationLength  );

*/
void EmuApi::EmuZwConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    PUNICODE_STRING PortName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortName);

    std::wstring rlwPortName;

    USHORT rlLengthPortName;

    USHORT rlMaxLengthPortName;
    uc_mem_read(uc, (DWORD_PTR)PortName, &rlLengthPortName, sizeof(rlLengthPortName));
    uc_mem_read(uc, (DWORD_PTR)PortName+16, &rlMaxLengthPortName, sizeof(rlMaxLengthPortName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, rlwPortName, true, rlLengthPortName)) { printf("Error when read PortName in ZwConnectPort"); _CrtDbgBreak(); }

    UNICODE_STRING stPortName{};
    stPortName.Length = rlLengthPortName;
    stPortName.MaximumLength = rlMaxLengthPortName;
    stPortName.Buffer = rlwPortName.data();

    PSECURITY_QUALITY_OF_SERVICE SecurityQos{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityQos);

    SECURITY_QUALITY_OF_SERVICE stSecurityQos{};

    if(SecurityQos != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }

    PPORT_VIEW ClientView{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientView);

    PORT_VIEW stClientView{};

    if(ClientView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }

    PREMOTE_PORT_VIEW ServerView{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    REMOTE_PORT_VIEW stServerView{};

    if(ServerView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }

    PULONG MaxMessageLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &MaxMessageLength, sizeof(MaxMessageLength));

    ULONG rlMaxMessageLength{};

    if(MaxMessageLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }

    PVOID ConnectionInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ConnectionInformation, sizeof(ConnectionInformation));

    PULONG ConnectionInformationLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    ULONG rlConnectionInformationLength{};

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }


    NTSTATUS ZwConnectPortResult = ZwConnectPort((PHANDLE)dpPortHandle,(PUNICODE_STRING)&stPortName,(PSECURITY_QUALITY_OF_SERVICE)&stSecurityQos,(PPORT_VIEW)&stClientView,(PREMOTE_PORT_VIEW)&stServerView,(PULONG)&rlMaxMessageLength,(PVOID)&ConnectionInformation,(PULONG)&rlConnectionInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_mem_write(uc, (DWORD_PTR)PortName, &stPortName.Length, sizeof(stPortName.Length));
    uc_mem_write(uc, (DWORD_PTR)PortName+16, &stPortName.MaximumLength, sizeof(stPortName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, stPortName.Buffer, true, stPortName.Length)) { printf("Error when read PortName in ZwConnectPort"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityQos);

    if(SecurityQos != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientView);

    if(ClientView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    if(ServerView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &MaxMessageLength, sizeof(MaxMessageLength));

    if(MaxMessageLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ConnectionInformation, sizeof(ConnectionInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSecureConnectPort(
    OUT            PHANDLE                       PortHandle                   ,
    IN             PUNICODE_STRING               PortName                     ,
    IN             PSECURITY_QUALITY_OF_SERVICE  SecurityQos                  ,
    INOUTOPTIONAL  PPORT_VIEW                    ClientView                   ,
    INOPTIONAL     PSID                          RequiredServerSid            ,
    INOUTOPTIONAL  PREMOTE_PORT_VIEW             ServerView                   ,
    OUTOPTIONAL    PULONG                        MaxMessageLength             ,
    INOUTOPTIONAL  PVOID                         ConnectionInformation        ,
    INOUTOPTIONAL  PULONG                        ConnectionInformationLength  );

*/
void EmuApi::EmuZwSecureConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    PUNICODE_STRING PortName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortName);

    std::wstring rlwPortName;

    USHORT rlLengthPortName;

    USHORT rlMaxLengthPortName;
    uc_mem_read(uc, (DWORD_PTR)PortName, &rlLengthPortName, sizeof(rlLengthPortName));
    uc_mem_read(uc, (DWORD_PTR)PortName+16, &rlMaxLengthPortName, sizeof(rlMaxLengthPortName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, rlwPortName, true, rlLengthPortName)) { printf("Error when read PortName in ZwSecureConnectPort"); _CrtDbgBreak(); }

    UNICODE_STRING stPortName{};
    stPortName.Length = rlLengthPortName;
    stPortName.MaximumLength = rlMaxLengthPortName;
    stPortName.Buffer = rlwPortName.data();

    PSECURITY_QUALITY_OF_SERVICE SecurityQos{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityQos);

    SECURITY_QUALITY_OF_SERVICE stSecurityQos{};

    if(SecurityQos != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }

    PPORT_VIEW ClientView{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientView);

    PORT_VIEW stClientView{};

    if(ClientView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }

    PSID RequiredServerSid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RequiredServerSid, sizeof(RequiredServerSid));

    PREMOTE_PORT_VIEW ServerView{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ServerView, sizeof(ServerView));

    REMOTE_PORT_VIEW stServerView{};

    if(ServerView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }

    PULONG MaxMessageLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &MaxMessageLength, sizeof(MaxMessageLength));

    ULONG rlMaxMessageLength{};

    if(MaxMessageLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }

    PVOID ConnectionInformation{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ConnectionInformation, sizeof(ConnectionInformation));

    PULONG ConnectionInformationLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    ULONG rlConnectionInformationLength{};

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }


    NTSTATUS ZwSecureConnectPortResult = ZwSecureConnectPort((PHANDLE)dpPortHandle,(PUNICODE_STRING)&stPortName,(PSECURITY_QUALITY_OF_SERVICE)&stSecurityQos,(PPORT_VIEW)&stClientView,(PSID)&RequiredServerSid,(PREMOTE_PORT_VIEW)&stServerView,(PULONG)&rlMaxMessageLength,(PVOID)&ConnectionInformation,(PULONG)&rlConnectionInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSecureConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_mem_write(uc, (DWORD_PTR)PortName, &stPortName.Length, sizeof(stPortName.Length));
    uc_mem_write(uc, (DWORD_PTR)PortName+16, &stPortName.MaximumLength, sizeof(stPortName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PortName+64, stPortName.Buffer, true, stPortName.Length)) { printf("Error when read PortName in ZwSecureConnectPort"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityQos);

    if(SecurityQos != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientView);

    if(ClientView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RequiredServerSid, sizeof(RequiredServerSid));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ServerView, sizeof(ServerView));

    if(ServerView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &MaxMessageLength, sizeof(MaxMessageLength));

    if(MaxMessageLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaxMessageLength, &rlMaxMessageLength, sizeof(rlMaxMessageLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ConnectionInformation, sizeof(ConnectionInformation));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &ConnectionInformationLength, sizeof(ConnectionInformationLength));

    if(ConnectionInformationLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionInformationLength, &rlConnectionInformationLength, sizeof(rlConnectionInformationLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSecureConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwListenPort(
    IN   HANDLE         PortHandle         ,
    OUT  PPORT_MESSAGE  ConnectionRequest  );

*/
void EmuApi::EmuZwListenPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE ConnectionRequest{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ConnectionRequest);

    PORT_MESSAGE stConnectionRequest{};

    if(ConnectionRequest != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }


    NTSTATUS ZwListenPortResult = ZwListenPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stConnectionRequest);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwListenPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ConnectionRequest);

    if(ConnectionRequest != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwListenPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAcceptConnectPort(
    OUT            PHANDLE            PortHandle         ,
    INOPTIONAL     PVOID              PortContext        ,
    IN             PPORT_MESSAGE      ConnectionRequest  ,
    IN             BOOLEAN            AcceptConnection   ,
    INOUTOPTIONAL  PPORT_VIEW         ServerView         ,
    OUTOPTIONAL    PREMOTE_PORT_VIEW  ClientView         );

*/
void EmuApi::EmuZwAcceptConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    HANDLE dpPortHandle{};

    if(PortHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }

    PVOID PortContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortContext);

    PPORT_MESSAGE ConnectionRequest{};
    uc_reg_read(uc, UC_X86_REG_R8, &ConnectionRequest);

    PORT_MESSAGE stConnectionRequest{};

    if(ConnectionRequest != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }

    BOOLEAN AcceptConnection{};
    uc_reg_read(uc, UC_X86_REG_R9B, &AcceptConnection);

    PPORT_VIEW ServerView{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    PORT_VIEW stServerView{};

    if(ServerView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }

    PREMOTE_PORT_VIEW ClientView{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ClientView, sizeof(ClientView));

    REMOTE_PORT_VIEW stClientView{};

    if(ClientView != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }


    NTSTATUS ZwAcceptConnectPortResult = ZwAcceptConnectPort((PHANDLE)dpPortHandle,(PVOID)&PortContext,(PPORT_MESSAGE)&stConnectionRequest,(BOOLEAN)AcceptConnection,(PPORT_VIEW)&stServerView,(PREMOTE_PORT_VIEW)&stClientView);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAcceptConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);

    if(PortHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortHandle, &dpPortHandle, sizeof(dpPortHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &PortContext);
    uc_reg_write(uc, UC_X86_REG_R8, &ConnectionRequest);

    if(ConnectionRequest != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ConnectionRequest, &stConnectionRequest, sizeof(stConnectionRequest));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &AcceptConnection);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ServerView, sizeof(ServerView));

    if(ServerView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServerView, &stServerView, sizeof(stServerView));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ClientView, sizeof(ClientView));

    if(ClientView != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientView, &stClientView, sizeof(stClientView));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAcceptConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCompleteConnectPort(
    IN  HANDLE  PortHandle  );

*/
void EmuApi::EmuZwCompleteConnectPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);


    NTSTATUS ZwCompleteConnectPortResult = ZwCompleteConnectPort((HANDLE)PortHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCompleteConnectPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCompleteConnectPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRequestPort(
    IN  HANDLE         PortHandle      ,
    IN  PPORT_MESSAGE  RequestMessage  );

*/
void EmuApi::EmuZwRequestPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE RequestMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RequestMessage);

    PORT_MESSAGE stRequestMessage{};

    if(RequestMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }


    NTSTATUS ZwRequestPortResult = ZwRequestPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stRequestMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRequestPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &RequestMessage);

    if(RequestMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRequestPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRequestWaitReplyPort(
    IN   HANDLE         PortHandle      ,
    IN   PPORT_MESSAGE  RequestMessage  ,
    OUT  PPORT_MESSAGE  ReplyMessage    );

*/
void EmuApi::EmuZwRequestWaitReplyPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE RequestMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RequestMessage);

    PORT_MESSAGE stRequestMessage{};

    if(RequestMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }


    NTSTATUS ZwRequestWaitReplyPortResult = ZwRequestWaitReplyPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stRequestMessage,(PPORT_MESSAGE)&stReplyMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRequestWaitReplyPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &RequestMessage);

    if(RequestMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequestMessage, &stRequestMessage, sizeof(stRequestMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRequestWaitReplyPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReplyPort(
    IN  HANDLE         PortHandle    ,
    IN  PPORT_MESSAGE  ReplyMessage  );

*/
void EmuApi::EmuZwReplyPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }


    NTSTATUS ZwReplyPortResult = ZwReplyPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stReplyMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReplyPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReplyPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReplyWaitReplyPort(
    IN     HANDLE         PortHandle    ,
    INOUT  PPORT_MESSAGE  ReplyMessage  );

*/
void EmuApi::EmuZwReplyWaitReplyPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }


    NTSTATUS ZwReplyWaitReplyPortResult = ZwReplyWaitReplyPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stReplyMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReplyWaitReplyPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReplyWaitReplyPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReplyWaitReceivePort(
    IN           HANDLE         PortHandle      ,
    OUTOPTIONAL  PVOID *        PortContext     ,
    INOPTIONAL   PPORT_MESSAGE  ReplyMessage    ,
    OUT          PPORT_MESSAGE  ReceiveMessage  );

*/
void EmuApi::EmuZwReplyWaitReceivePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PVOID * PortContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortContext);

    PVOID * dpPortContext{};

    if(PortContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }

    PPORT_MESSAGE ReceiveMessage{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReceiveMessage);

    PORT_MESSAGE stReceiveMessage{};

    if(ReceiveMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }


    NTSTATUS ZwReplyWaitReceivePortResult = ZwReplyWaitReceivePort((HANDLE)PortHandle,(PVOID *)&dpPortContext,(PPORT_MESSAGE)&stReplyMessage,(PPORT_MESSAGE)&stReceiveMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReplyWaitReceivePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PortContext);

    if(PortContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ReceiveMessage);

    if(ReceiveMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReplyWaitReceivePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReplyWaitReceivePortEx(
    IN           HANDLE          PortHandle      ,
    OUTOPTIONAL  PVOID *         PortContext     ,
    INOPTIONAL   PPORT_MESSAGE   ReplyMessage    ,
    OUT          PPORT_MESSAGE   ReceiveMessage  ,
    INOPTIONAL   PLARGE_INTEGER  Timeout         );

*/
void EmuApi::EmuZwReplyWaitReceivePortEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PVOID * PortContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PortContext);

    PVOID * dpPortContext{};

    if(PortContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }

    PPORT_MESSAGE ReplyMessage{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReplyMessage);

    PORT_MESSAGE stReplyMessage{};

    if(ReplyMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }

    PPORT_MESSAGE ReceiveMessage{};
    uc_reg_read(uc, UC_X86_REG_R9, &ReceiveMessage);

    PORT_MESSAGE stReceiveMessage{};

    if(ReceiveMessage != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwReplyWaitReceivePortExResult = ZwReplyWaitReceivePortEx((HANDLE)PortHandle,(PVOID *)&dpPortContext,(PPORT_MESSAGE)&stReplyMessage,(PPORT_MESSAGE)&stReceiveMessage,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReplyWaitReceivePortExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PortContext);

    if(PortContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PortContext, &dpPortContext, sizeof(dpPortContext));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ReplyMessage);

    if(ReplyMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReplyMessage, &stReplyMessage, sizeof(stReplyMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ReceiveMessage);

    if(ReceiveMessage != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReceiveMessage, &stReceiveMessage, sizeof(stReceiveMessage));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReplyWaitReceivePortEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwImpersonateClientOfPort(
    IN  HANDLE         PortHandle  ,
    IN  PPORT_MESSAGE  Message     );

*/
void EmuApi::EmuZwImpersonateClientOfPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE Message{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Message);

    PORT_MESSAGE stMessage{};

    if(Message != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }


    NTSTATUS ZwImpersonateClientOfPortResult = ZwImpersonateClientOfPort((HANDLE)PortHandle,(PPORT_MESSAGE)&stMessage);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwImpersonateClientOfPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Message);

    if(Message != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwImpersonateClientOfPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReadRequestData(
    IN           HANDLE         PortHandle         ,
    IN           PPORT_MESSAGE  Message            ,
    IN           ULONG          DataEntryIndex     ,
    OUT          PVOID          Buffer             ,
    IN           SIZE_T         BufferSize         ,
    OUTOPTIONAL  PSIZE_T        NumberOfBytesRead  );

*/
void EmuApi::EmuZwReadRequestData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE Message{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Message);

    PORT_MESSAGE stMessage{};

    if(Message != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }

    ULONG DataEntryIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DataEntryIndex);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);

    SIZE_T BufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));

    PSIZE_T NumberOfBytesRead{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    ULONG_PTR rlNumberOfBytesRead{};

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }


    NTSTATUS ZwReadRequestDataResult = ZwReadRequestData((HANDLE)PortHandle,(PPORT_MESSAGE)&stMessage,(ULONG)DataEntryIndex,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesRead);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReadRequestDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Message);

    if(Message != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &DataEntryIndex);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReadRequestData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWriteRequestData(
    IN           HANDLE         PortHandle            ,
    IN           PPORT_MESSAGE  Message               ,
    IN           ULONG          DataEntryIndex        ,
    IN           PVOID          Buffer                ,
    IN           SIZE_T         BufferSize            ,
    OUTOPTIONAL  PSIZE_T        NumberOfBytesWritten  );

*/
void EmuApi::EmuZwWriteRequestData(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PPORT_MESSAGE Message{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Message);

    PORT_MESSAGE stMessage{};

    if(Message != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }

    ULONG DataEntryIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DataEntryIndex);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &Buffer);

    SIZE_T BufferSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));

    PSIZE_T NumberOfBytesWritten{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    ULONG_PTR rlNumberOfBytesWritten{};

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }


    NTSTATUS ZwWriteRequestDataResult = ZwWriteRequestData((HANDLE)PortHandle,(PPORT_MESSAGE)&stMessage,(ULONG)DataEntryIndex,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesWritten);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWriteRequestDataResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Message);

    if(Message != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Message, &stMessage, sizeof(stMessage));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &DataEntryIndex);
    uc_reg_write(uc, UC_X86_REG_R9, &Buffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWriteRequestData\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationPort(
    IN           HANDLE                  PortHandle            ,
    IN           PORT_INFORMATION_CLASS  PortInformationClass  ,
    OUT          PVOID                   PortInformation       ,
    IN           ULONG                   Length                ,
    OUTOPTIONAL  PULONG                  ReturnLength          );

*/
void EmuApi::EmuZwQueryInformationPort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);

    PORT_INFORMATION_CLASS PortInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &PortInformationClass);

    PVOID PortInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &PortInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryInformationPortResult = ZwQueryInformationPort((HANDLE)PortHandle,(PORT_INFORMATION_CLASS)PortInformationClass,(PVOID)&PortInformation,(ULONG)Length,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationPortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &PortInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &PortInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationPort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateSection(
    OUT         PHANDLE             SectionHandle          ,
    IN          ACCESS_MASK         DesiredAccess          ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes       ,
    INOPTIONAL  PLARGE_INTEGER      MaximumSize            ,
    IN          ULONG               SectionPageProtection  ,
    IN          ULONG               AllocationAttributes   ,
    INOPTIONAL  HANDLE              FileHandle             );

*/
void EmuApi::EmuZwCreateSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    HANDLE dpSectionHandle{};

    if(SectionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PLARGE_INTEGER MaximumSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &MaximumSize);

    LARGE_INTEGER rlMaximumSize{};

    if(MaximumSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }

    ULONG SectionPageProtection{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SectionPageProtection, sizeof(SectionPageProtection));

    ULONG AllocationAttributes{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AllocationAttributes, sizeof(AllocationAttributes));

    HANDLE FileHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &FileHandle, sizeof(FileHandle));


    NTSTATUS ZwCreateSectionResult = ZwCreateSection((PHANDLE)dpSectionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PLARGE_INTEGER)&rlMaximumSize,(ULONG)SectionPageProtection,(ULONG)AllocationAttributes,(HANDLE)FileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);

    if(SectionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &MaximumSize);

    if(MaximumSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SectionPageProtection, sizeof(SectionPageProtection));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AllocationAttributes, sizeof(AllocationAttributes));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &FileHandle, sizeof(FileHandle));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenSection(
    OUT  PHANDLE             SectionHandle     ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    HANDLE dpSectionHandle{};

    if(SectionHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenSectionResult = ZwOpenSection((PHANDLE)dpSectionHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);

    if(SectionHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SectionHandle, &dpSectionHandle, sizeof(dpSectionHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwMapViewOfSection(
    IN             HANDLE           SectionHandle       ,
    IN             HANDLE           ProcessHandle       ,
    INOUT          PVOID *          BaseAddress         ,
    IN             ULONG_PTR        ZeroBits            ,
    IN             SIZE_T           CommitSize          ,
    INOUTOPTIONAL  PLARGE_INTEGER   SectionOffset       ,
    INOUT          PSIZE_T          ViewSize            ,
    IN             SECTION_INHERIT  InheritDisposition  ,
    IN             ULONG            AllocationType      ,
    IN             ULONG            Win32Protect        );

*/
void EmuApi::EmuZwMapViewOfSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    ULONG_PTR ZeroBits{};
    uc_reg_read(uc, UC_X86_REG_R9, &ZeroBits);

    SIZE_T CommitSize{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &CommitSize, sizeof(CommitSize));

    PLARGE_INTEGER SectionOffset{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SectionOffset, sizeof(SectionOffset));

    LARGE_INTEGER rlSectionOffset{};

    if(SectionOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SectionOffset, &rlSectionOffset, sizeof(rlSectionOffset));
    }

    PSIZE_T ViewSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ViewSize, sizeof(ViewSize));

    ULONG_PTR rlViewSize{};

    if(ViewSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ViewSize, &rlViewSize, sizeof(rlViewSize));
    }

    SECTION_INHERIT InheritDisposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &InheritDisposition, sizeof(InheritDisposition));

    ULONG AllocationType{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &AllocationType, sizeof(AllocationType));

    ULONG Win32Protect{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Win32Protect, sizeof(Win32Protect));


    NTSTATUS ZwMapViewOfSectionResult = ZwMapViewOfSection((HANDLE)SectionHandle,(HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(ULONG_PTR)ZeroBits,(SIZE_T)CommitSize,(PLARGE_INTEGER)&rlSectionOffset,(PSIZE_T)&rlViewSize,(SECTION_INHERIT)InheritDisposition,(ULONG)AllocationType,(ULONG)Win32Protect);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwMapViewOfSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ZeroBits);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CommitSize, sizeof(CommitSize));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SectionOffset, sizeof(SectionOffset));

    if(SectionOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SectionOffset, &rlSectionOffset, sizeof(rlSectionOffset));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ViewSize, sizeof(ViewSize));

    if(ViewSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ViewSize, &rlViewSize, sizeof(rlViewSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &InheritDisposition, sizeof(InheritDisposition));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &AllocationType, sizeof(AllocationType));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Win32Protect, sizeof(Win32Protect));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwMapViewOfSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnmapViewOfSection(
    IN  HANDLE  ProcessHandle  ,
    IN  PVOID   BaseAddress    );

*/
void EmuApi::EmuZwUnmapViewOfSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);


    NTSTATUS ZwUnmapViewOfSectionResult = ZwUnmapViewOfSection((HANDLE)ProcessHandle,(PVOID)&BaseAddress);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnmapViewOfSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnmapViewOfSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwExtendSection(
    IN     HANDLE          SectionHandle   ,
    INOUT  PLARGE_INTEGER  NewSectionSize  );

*/
void EmuApi::EmuZwExtendSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    PLARGE_INTEGER NewSectionSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NewSectionSize);

    LARGE_INTEGER rlNewSectionSize{};

    if(NewSectionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewSectionSize, &rlNewSectionSize, sizeof(rlNewSectionSize));
    }


    NTSTATUS ZwExtendSectionResult = ZwExtendSection((HANDLE)SectionHandle,(PLARGE_INTEGER)&rlNewSectionSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwExtendSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &NewSectionSize);

    if(NewSectionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewSectionSize, &rlNewSectionSize, sizeof(rlNewSectionSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwExtendSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAreMappedFilesTheSame(
    IN  PVOID  File1MappedAsAnImage  ,
    IN  PVOID  File2MappedAsFile     );

*/
void EmuApi::EmuZwAreMappedFilesTheSame(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID File1MappedAsAnImage{};
    uc_reg_read(uc, UC_X86_REG_RCX, &File1MappedAsAnImage);

    PVOID File2MappedAsFile{};
    uc_reg_read(uc, UC_X86_REG_RDX, &File2MappedAsFile);


    NTSTATUS ZwAreMappedFilesTheSameResult = ZwAreMappedFilesTheSame((PVOID)&File1MappedAsAnImage,(PVOID)&File2MappedAsFile);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAreMappedFilesTheSameResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &File1MappedAsAnImage);
    uc_reg_write(uc, UC_X86_REG_RDX, &File2MappedAsFile);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAreMappedFilesTheSame\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAllocateVirtualMemory(
    IN     HANDLE     ProcessHandle   ,
    INOUT  PVOID *    BaseAddress     ,
    IN     ULONG_PTR  ZeroBits        ,
    INOUT  PSIZE_T    RegionSize      ,
    IN     ULONG      AllocationType  ,
    IN     ULONG      Protect         );

*/
void EmuApi::EmuZwAllocateVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    ULONG_PTR ZeroBits{};
    uc_reg_read(uc, UC_X86_REG_R8, &ZeroBits);

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG AllocationType{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AllocationType, sizeof(AllocationType));

    ULONG Protect{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Protect, sizeof(Protect));


    NTSTATUS ZwAllocateVirtualMemoryResult = ZwAllocateVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(ULONG_PTR)ZeroBits,(PSIZE_T)&rlRegionSize,(ULONG)AllocationType,(ULONG)Protect);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAllocateVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &ZeroBits);
    uc_reg_write(uc, UC_X86_REG_R9, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AllocationType, sizeof(AllocationType));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Protect, sizeof(Protect));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAllocateVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFreeVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    FreeType       );

*/
void EmuApi::EmuZwFreeVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG FreeType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &FreeType);


    NTSTATUS ZwFreeVirtualMemoryResult = ZwFreeVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)FreeType);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFreeVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &FreeType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFreeVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReadVirtualMemory(
    IN           HANDLE   ProcessHandle      ,
    INOPTIONAL   PVOID    BaseAddress        ,
    OUT          PVOID    Buffer             ,
    IN           SIZE_T   BufferSize         ,
    OUTOPTIONAL  PSIZE_T  NumberOfBytesRead  );

*/
void EmuApi::EmuZwReadVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    SIZE_T BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &BufferSize);

    PSIZE_T NumberOfBytesRead{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    ULONG_PTR rlNumberOfBytesRead{};

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }


    NTSTATUS ZwReadVirtualMemoryResult = ZwReadVirtualMemory((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesRead);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReadVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9, &BufferSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NumberOfBytesRead, sizeof(NumberOfBytesRead));

    if(NumberOfBytesRead != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesRead, &rlNumberOfBytesRead, sizeof(rlNumberOfBytesRead));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReadVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWriteVirtualMemory(
    IN                     HANDLE        ProcessHandle         ,
    INOPTIONAL             PVOID         BaseAddress           ,
                           const void *  Buffer                ,
    INCONSTVOID*Buffer,IN  SIZE_T        BufferSize            ,
    OUTOPTIONAL            PSIZE_T       NumberOfBytesWritten  );

*/
void EmuApi::EmuZwWriteVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    SIZE_T BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &BufferSize);

    PSIZE_T NumberOfBytesWritten{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    ULONG_PTR rlNumberOfBytesWritten{};

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }


    NTSTATUS ZwWriteVirtualMemoryResult = ZwWriteVirtualMemory((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(PVOID)&Buffer,(SIZE_T)BufferSize,(PSIZE_T)&rlNumberOfBytesWritten);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWriteVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9, &BufferSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten));

    if(NumberOfBytesWritten != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfBytesWritten, &rlNumberOfBytesWritten, sizeof(rlNumberOfBytesWritten));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWriteVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFlushVirtualMemory(
    IN     HANDLE            ProcessHandle  ,
    INOUT  PVOID *           BaseAddress    ,
    INOUT  PSIZE_T           RegionSize     ,
    OUT    PIO_STATUS_BLOCK  IoStatus       );

*/
void EmuApi::EmuZwFlushVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    PIO_STATUS_BLOCK IoStatus{};
    uc_reg_read(uc, UC_X86_REG_R9, &IoStatus);

    IO_STATUS_BLOCK stIoStatus{};

    if(IoStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatus, &stIoStatus, sizeof(stIoStatus));
    }


    NTSTATUS ZwFlushVirtualMemoryResult = ZwFlushVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(PIO_STATUS_BLOCK)&stIoStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFlushVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &IoStatus);

    if(IoStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatus, &stIoStatus, sizeof(stIoStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFlushVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLockVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    MapType        );

*/
void EmuApi::EmuZwLockVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG MapType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MapType);


    NTSTATUS ZwLockVirtualMemoryResult = ZwLockVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)MapType);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLockVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &MapType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLockVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnlockVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    MapType        );

*/
void EmuApi::EmuZwUnlockVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG MapType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &MapType);


    NTSTATUS ZwUnlockVirtualMemoryResult = ZwUnlockVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)MapType);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnlockVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &MapType);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnlockVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwProtectVirtualMemory(
    IN     HANDLE   ProcessHandle  ,
    INOUT  PVOID *  BaseAddress    ,
    INOUT  PSIZE_T  RegionSize     ,
    IN     ULONG    NewProtect     ,
    OUT    PULONG   OldProtect     );

*/
void EmuApi::EmuZwProtectVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID * BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    PVOID * dpBaseAddress{};

    if(BaseAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }

    PSIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);

    ULONG_PTR rlRegionSize{};

    if(RegionSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }

    ULONG NewProtect{};
    uc_reg_read(uc, UC_X86_REG_R9D, &NewProtect);

    PULONG OldProtect{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &OldProtect, sizeof(OldProtect));

    ULONG rlOldProtect{};

    if(OldProtect != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldProtect, &rlOldProtect, sizeof(rlOldProtect));
    }


    NTSTATUS ZwProtectVirtualMemoryResult = ZwProtectVirtualMemory((HANDLE)ProcessHandle,(PVOID *)&dpBaseAddress,(PSIZE_T)&rlRegionSize,(ULONG)NewProtect,(PULONG)&rlOldProtect);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwProtectVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);

    if(BaseAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BaseAddress, &dpBaseAddress, sizeof(dpBaseAddress));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);

    if(RegionSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RegionSize, &rlRegionSize, sizeof(rlRegionSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &NewProtect);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &OldProtect, sizeof(OldProtect));

    if(OldProtect != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldProtect, &rlOldProtect, sizeof(rlOldProtect));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwProtectVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryVirtualMemory(
    IN           HANDLE                    ProcessHandle            ,
    IN           PVOID                     BaseAddress              ,
    IN           MEMORY_INFORMATION_CLASS  MemoryInformationClass   ,
    OUT          PVOID                     MemoryInformation        ,
    IN           SIZE_T                    MemoryInformationLength  ,
    OUTOPTIONAL  PSIZE_T                   ReturnLength             );

*/
void EmuApi::EmuZwQueryVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    MEMORY_INFORMATION_CLASS MemoryInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &MemoryInformationClass);

    PVOID MemoryInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &MemoryInformation);

    SIZE_T MemoryInformationLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &MemoryInformationLength, sizeof(MemoryInformationLength));

    PSIZE_T ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG_PTR rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryVirtualMemoryResult = ZwQueryVirtualMemory((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(MEMORY_INFORMATION_CLASS)MemoryInformationClass,(PVOID)&MemoryInformation,(SIZE_T)MemoryInformationLength,(PSIZE_T)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryVirtualMemoryResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8D, &MemoryInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &MemoryInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &MemoryInformationLength, sizeof(MemoryInformationLength));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryVirtualMemory\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySection(
    IN           HANDLE                     SectionHandle             ,
    IN           SECTION_INFORMATION_CLASS  SectionInformationClass   ,
    OUT          PVOID                      SectionInformation        ,
    IN           SIZE_T                     SectionInformationLength  ,
    OUTOPTIONAL  PSIZE_T                    ReturnLength              );

*/
void EmuApi::EmuZwQuerySection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SectionHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SectionHandle);

    SECTION_INFORMATION_CLASS SectionInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SectionInformationClass);

    PVOID SectionInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &SectionInformation);

    SIZE_T SectionInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9, &SectionInformationLength);

    PSIZE_T ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG_PTR rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQuerySectionResult = ZwQuerySection((HANDLE)SectionHandle,(SECTION_INFORMATION_CLASS)SectionInformationClass,(PVOID)&SectionInformation,(SIZE_T)SectionInformationLength,(PSIZE_T)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SectionHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SectionInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &SectionInformation);
    uc_reg_write(uc, UC_X86_REG_R9, &SectionInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwMapUserPhysicalPages(
    IN          PVOID       VirtualAddress  ,
    IN          ULONG_PTR   NumberOfPages   ,
    INOPTIONAL  PULONG_PTR  UserPfnArray    );

*/
void EmuApi::EmuZwMapUserPhysicalPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID VirtualAddress{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VirtualAddress);

    ULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS ZwMapUserPhysicalPagesResult = ZwMapUserPhysicalPages((PVOID)&VirtualAddress,(ULONG_PTR)NumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwMapUserPhysicalPagesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &VirtualAddress);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwMapUserPhysicalPages\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwMapUserPhysicalPagesScatter(
    IN          PVOID *     VirtualAddresses  ,
    IN          ULONG_PTR   NumberOfPages     ,
    INOPTIONAL  PULONG_PTR  UserPfnArray      );

*/
void EmuApi::EmuZwMapUserPhysicalPagesScatter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID * VirtualAddresses{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VirtualAddresses);

    PVOID * dpVirtualAddresses{};

    if(VirtualAddresses != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)VirtualAddresses, &dpVirtualAddresses, sizeof(dpVirtualAddresses));
    }

    ULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS ZwMapUserPhysicalPagesScatterResult = ZwMapUserPhysicalPagesScatter((PVOID *)&dpVirtualAddresses,(ULONG_PTR)NumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwMapUserPhysicalPagesScatterResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &VirtualAddresses);

    if(VirtualAddresses != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)VirtualAddresses, &dpVirtualAddresses, sizeof(dpVirtualAddresses));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwMapUserPhysicalPagesScatter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAllocateUserPhysicalPages(
    IN     HANDLE      ProcessHandle  ,
    INOUT  PULONG_PTR  NumberOfPages  ,
    OUT    PULONG_PTR  UserPfnArray   );

*/
void EmuApi::EmuZwAllocateUserPhysicalPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    unsigned long long rlNumberOfPages{};

    if(NumberOfPages != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS ZwAllocateUserPhysicalPagesResult = ZwAllocateUserPhysicalPages((HANDLE)ProcessHandle,(PULONG_PTR)&rlNumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAllocateUserPhysicalPagesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);

    if(NumberOfPages != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAllocateUserPhysicalPages\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFreeUserPhysicalPages(
    IN     HANDLE      ProcessHandle  ,
    INOUT  PULONG_PTR  NumberOfPages  ,
    IN     PULONG_PTR  UserPfnArray   );

*/
void EmuApi::EmuZwFreeUserPhysicalPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PULONG_PTR NumberOfPages{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfPages);

    unsigned long long rlNumberOfPages{};

    if(NumberOfPages != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }

    PULONG_PTR UserPfnArray{};
    uc_reg_read(uc, UC_X86_REG_R8, &UserPfnArray);

    unsigned long long rlUserPfnArray{};

    if(UserPfnArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }


    NTSTATUS ZwFreeUserPhysicalPagesResult = ZwFreeUserPhysicalPages((HANDLE)ProcessHandle,(PULONG_PTR)&rlNumberOfPages,(PULONG_PTR)&rlUserPfnArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFreeUserPhysicalPagesResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfPages);

    if(NumberOfPages != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NumberOfPages, &rlNumberOfPages, sizeof(rlNumberOfPages));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &UserPfnArray);

    if(UserPfnArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserPfnArray, &rlUserPfnArray, sizeof(rlUserPfnArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFreeUserPhysicalPages\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwGetWriteWatch(
    IN     HANDLE      ProcessHandle              ,
    IN     ULONG       Flags                      ,
    IN     PVOID       BaseAddress                ,
    IN     SIZE_T      RegionSize                 ,
    OUT    PVOID *     UserAddressArray           ,
    INOUT  PULONG_PTR  EntriesInUserAddressArray  ,
    OUT    PULONG      Granularity                );

*/
void EmuApi::EmuZwGetWriteWatch(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_R8, &BaseAddress);

    SIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &RegionSize);

    PVOID * UserAddressArray{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &UserAddressArray, sizeof(UserAddressArray));

    PVOID * dpUserAddressArray{};

    if(UserAddressArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserAddressArray, &dpUserAddressArray, sizeof(dpUserAddressArray));
    }

    PULONG_PTR EntriesInUserAddressArray{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &EntriesInUserAddressArray, sizeof(EntriesInUserAddressArray));

    unsigned long long rlEntriesInUserAddressArray{};

    if(EntriesInUserAddressArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EntriesInUserAddressArray, &rlEntriesInUserAddressArray, sizeof(rlEntriesInUserAddressArray));
    }

    PULONG Granularity{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Granularity, sizeof(Granularity));

    ULONG rlGranularity{};

    if(Granularity != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Granularity, &rlGranularity, sizeof(rlGranularity));
    }


    NTSTATUS ZwGetWriteWatchResult = ZwGetWriteWatch((HANDLE)ProcessHandle,(ULONG)Flags,(PVOID)&BaseAddress,(SIZE_T)RegionSize,(PVOID *)&dpUserAddressArray,(PULONG_PTR)&rlEntriesInUserAddressArray,(PULONG)&rlGranularity);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwGetWriteWatchResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R9, &RegionSize);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &UserAddressArray, sizeof(UserAddressArray));

    if(UserAddressArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserAddressArray, &dpUserAddressArray, sizeof(dpUserAddressArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &EntriesInUserAddressArray, sizeof(EntriesInUserAddressArray));

    if(EntriesInUserAddressArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EntriesInUserAddressArray, &rlEntriesInUserAddressArray, sizeof(rlEntriesInUserAddressArray));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Granularity, sizeof(Granularity));

    if(Granularity != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Granularity, &rlGranularity, sizeof(rlGranularity));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwGetWriteWatch\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwResetWriteWatch(
    IN  HANDLE  ProcessHandle  ,
    IN  PVOID   BaseAddress    ,
    IN  SIZE_T  RegionSize     );

*/
void EmuApi::EmuZwResetWriteWatch(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    SIZE_T RegionSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &RegionSize);


    NTSTATUS ZwResetWriteWatchResult = ZwResetWriteWatch((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(SIZE_T)RegionSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwResetWriteWatchResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &RegionSize);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwResetWriteWatch\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreatePagingFile(
    IN  PUNICODE_STRING  PageFileName  ,
    IN  PLARGE_INTEGER   MinimumSize   ,
    IN  PLARGE_INTEGER   MaximumSize   ,
    IN  ULONG            Priority      );

*/
void EmuApi::EmuZwCreatePagingFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING PageFileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PageFileName);

    std::wstring rlwPageFileName;

    USHORT rlLengthPageFileName;

    USHORT rlMaxLengthPageFileName;
    uc_mem_read(uc, (DWORD_PTR)PageFileName, &rlLengthPageFileName, sizeof(rlLengthPageFileName));
    uc_mem_read(uc, (DWORD_PTR)PageFileName+16, &rlMaxLengthPageFileName, sizeof(rlMaxLengthPageFileName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PageFileName+64, rlwPageFileName, true, rlLengthPageFileName)) { printf("Error when read PageFileName in ZwCreatePagingFile"); _CrtDbgBreak(); }

    UNICODE_STRING stPageFileName{};
    stPageFileName.Length = rlLengthPageFileName;
    stPageFileName.MaximumLength = rlMaxLengthPageFileName;
    stPageFileName.Buffer = rlwPageFileName.data();

    PLARGE_INTEGER MinimumSize{};
    uc_reg_read(uc, UC_X86_REG_RDX, &MinimumSize);

    LARGE_INTEGER rlMinimumSize{};

    if(MinimumSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MinimumSize, &rlMinimumSize, sizeof(rlMinimumSize));
    }

    PLARGE_INTEGER MaximumSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &MaximumSize);

    LARGE_INTEGER rlMaximumSize{};

    if(MaximumSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }

    ULONG Priority{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Priority);


    NTSTATUS ZwCreatePagingFileResult = ZwCreatePagingFile((PUNICODE_STRING)&stPageFileName,(PLARGE_INTEGER)&rlMinimumSize,(PLARGE_INTEGER)&rlMaximumSize,(ULONG)Priority);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreatePagingFileResult);
    uc_mem_write(uc, (DWORD_PTR)PageFileName, &stPageFileName.Length, sizeof(stPageFileName.Length));
    uc_mem_write(uc, (DWORD_PTR)PageFileName+16, &stPageFileName.MaximumLength, sizeof(stPageFileName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PageFileName+64, stPageFileName.Buffer, true, stPageFileName.Length)) { printf("Error when read PageFileName in ZwCreatePagingFile"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &MinimumSize);

    if(MinimumSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MinimumSize, &rlMinimumSize, sizeof(rlMinimumSize));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &MaximumSize);

    if(MaximumSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)MaximumSize, &rlMaximumSize, sizeof(rlMaximumSize));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &Priority);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreatePagingFile\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFlushInstructionCache(
    IN          HANDLE  ProcessHandle  ,
    INOPTIONAL  PVOID   BaseAddress    ,
    IN          SIZE_T  Length         );

*/
void EmuApi::EmuZwFlushInstructionCache(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RDX, &BaseAddress);

    SIZE_T Length{};
    uc_reg_read(uc, UC_X86_REG_R8, &Length);


    NTSTATUS ZwFlushInstructionCacheResult = ZwFlushInstructionCache((HANDLE)ProcessHandle,(PVOID)&BaseAddress,(SIZE_T)Length);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFlushInstructionCacheResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_R8, &Length);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFlushInstructionCache\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFlushWriteBuffer(VOID);

*/
void EmuApi::EmuZwFlushWriteBuffer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS ZwFlushWriteBufferResult = ZwFlushWriteBuffer();


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFlushWriteBufferResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFlushWriteBuffer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryObject(
    IN   HANDLE                    Handle                   ,
    IN   OBJECT_INFORMATION_CLASS  ObjectInformationClass   ,
    OUT  PVOID                     ObjectInformation        ,
    IN   ULONG                     ObjectInformationLength  ,
    OUT  PULONG                    ReturnLength             );

*/
void EmuApi::EmuZwQueryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    OBJECT_INFORMATION_CLASS ObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ObjectInformationClass);

    PVOID ObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectInformation);

    ULONG ObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ObjectInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryObjectResult = ZwQueryObject((HANDLE)Handle,(OBJECT_INFORMATION_CLASS)ObjectInformationClass,(PVOID)&ObjectInformation,(ULONG)ObjectInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ObjectInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationObject(
    IN  HANDLE                    Handle                   ,
    IN  OBJECT_INFORMATION_CLASS  ObjectInformationClass   ,
    IN  PVOID                     ObjectInformation        ,
    IN  ULONG                     ObjectInformationLength  );

*/
void EmuApi::EmuZwSetInformationObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    OBJECT_INFORMATION_CLASS ObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ObjectInformationClass);

    PVOID ObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectInformation);

    ULONG ObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ObjectInformationLength);


    NTSTATUS ZwSetInformationObjectResult = ZwSetInformationObject((HANDLE)Handle,(OBJECT_INFORMATION_CLASS)ObjectInformationClass,(PVOID)&ObjectInformation,(ULONG)ObjectInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ObjectInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDuplicateObject(
    IN          HANDLE       SourceProcessHandle  ,
    IN          HANDLE       SourceHandle         ,
    INOPTIONAL  HANDLE       TargetProcessHandle  ,
    OUT         PHANDLE      TargetHandle         ,
    IN          ACCESS_MASK  DesiredAccess        ,
    IN          ULONG        HandleAttributes     ,
    IN          ULONG        Options              );

*/
void EmuApi::EmuZwDuplicateObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SourceProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SourceProcessHandle);

    HANDLE SourceHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceHandle);

    HANDLE TargetProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &TargetProcessHandle);

    HANDLE TargetHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TargetHandle);

    HANDLE dpTargetHandle{};

    if(TargetHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetHandle, &dpTargetHandle, sizeof(dpTargetHandle));
    }

    ACCESS_MASK DesiredAccess{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &DesiredAccess, sizeof(DesiredAccess));

    ULONG HandleAttributes{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &HandleAttributes, sizeof(HandleAttributes));

    ULONG Options{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Options, sizeof(Options));


    NTSTATUS ZwDuplicateObjectResult = ZwDuplicateObject((HANDLE)SourceProcessHandle,(HANDLE)SourceHandle,(HANDLE)TargetProcessHandle,(PHANDLE)dpTargetHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(ULONG)Options);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDuplicateObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SourceProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &TargetProcessHandle);
    uc_reg_write(uc, UC_X86_REG_R9, &TargetHandle);

    if(TargetHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetHandle, &dpTargetHandle, sizeof(dpTargetHandle));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &HandleAttributes, sizeof(HandleAttributes));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Options, sizeof(Options));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDuplicateObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwMakeTemporaryObject(
    IN  HANDLE  Handle  );

*/
void EmuApi::EmuZwMakeTemporaryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    NTSTATUS ZwMakeTemporaryObjectResult = ZwMakeTemporaryObject((HANDLE)Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwMakeTemporaryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwMakeTemporaryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwMakePermanentObject(
    IN  HANDLE  Handle  );

*/
void EmuApi::EmuZwMakePermanentObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    NTSTATUS ZwMakePermanentObjectResult = ZwMakePermanentObject((HANDLE)Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwMakePermanentObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwMakePermanentObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSignalAndWaitForSingleObject(
    IN          HANDLE          SignalHandle  ,
    IN          HANDLE          WaitHandle    ,
    IN          BOOLEAN         Alertable     ,
    INOPTIONAL  PLARGE_INTEGER  Timeout       );

*/
void EmuApi::EmuZwSignalAndWaitForSingleObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE SignalHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SignalHandle);

    HANDLE WaitHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &WaitHandle);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R8B, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R9, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwSignalAndWaitForSingleObjectResult = ZwSignalAndWaitForSingleObject((HANDLE)SignalHandle,(HANDLE)WaitHandle,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSignalAndWaitForSingleObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SignalHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &WaitHandle);
    uc_reg_write(uc, UC_X86_REG_R8B, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R9, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSignalAndWaitForSingleObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWaitForSingleObject(
    IN          HANDLE          Handle     ,
    IN          BOOLEAN         Alertable  ,
    INOPTIONAL  PLARGE_INTEGER  Timeout    );

*/
void EmuApi::EmuZwWaitForSingleObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_DL, &Alertable);

    PLARGE_INTEGER Timeout{};
    uc_reg_read(uc, UC_X86_REG_R8, &Timeout);

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwWaitForSingleObjectResult = ZwWaitForSingleObject((HANDLE)Handle,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWaitForSingleObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_DL, &Alertable);
    uc_reg_write(uc, UC_X86_REG_R8, &Timeout);

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWaitForSingleObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWaitForMultipleObjects(
    IN          ULONG           Count      ,
    IN          HANDLE *        Handles    ,
    IN          WAIT_TYPE       WaitType   ,
    IN          BOOLEAN         Alertable  ,
    INOPTIONAL  PLARGE_INTEGER  Timeout    );

*/
void EmuApi::EmuZwWaitForMultipleObjects(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Count);

    PHANDLE Handles{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handles);

    HANDLE rlHandles{};

    if(Handles != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }

    WAIT_TYPE WaitType{};
    uc_reg_read(uc, UC_X86_REG_R8D, &WaitType);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R9B, &Alertable);

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwWaitForMultipleObjectsResult = ZwWaitForMultipleObjects((ULONG)Count,(HANDLE *)rlHandles,(WAIT_TYPE)WaitType,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWaitForMultipleObjectsResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Count);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handles);

    if(Handles != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &WaitType);
    uc_reg_write(uc, UC_X86_REG_R9B, &Alertable);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWaitForMultipleObjects\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwWaitForMultipleObjects32(
    IN          ULONG           Count      ,
    IN          LONG *          Handles    ,
    IN          WAIT_TYPE       WaitType   ,
    IN          BOOLEAN         Alertable  ,
    INOPTIONAL  PLARGE_INTEGER  Timeout    );

*/
void EmuApi::EmuZwWaitForMultipleObjects32(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Count);

    PLONG Handles{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handles);

    LONG rlHandles{};

    if(Handles != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }

    WAIT_TYPE WaitType{};
    uc_reg_read(uc, UC_X86_REG_R8D, &WaitType);

    BOOLEAN Alertable{};
    uc_reg_read(uc, UC_X86_REG_R9B, &Alertable);

    PLARGE_INTEGER Timeout{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    LARGE_INTEGER rlTimeout{};

    if(Timeout != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }


    NTSTATUS ZwWaitForMultipleObjects32Result = ZwWaitForMultipleObjects32((ULONG)Count,(LONG *)&rlHandles,(WAIT_TYPE)WaitType,(BOOLEAN)Alertable,(PLARGE_INTEGER)&rlTimeout);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwWaitForMultipleObjects32Result);
    uc_reg_write(uc, UC_X86_REG_ECX, &Count);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handles);

    if(Handles != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handles, &rlHandles, sizeof(rlHandles));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &WaitType);
    uc_reg_write(uc, UC_X86_REG_R9B, &Alertable);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Timeout, sizeof(Timeout));

    if(Timeout != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Timeout, &rlTimeout, sizeof(rlTimeout));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwWaitForMultipleObjects32\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetSecurityObject(
    IN  HANDLE                Handle               ,
    IN  SECURITY_INFORMATION  SecurityInformation  ,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor   );

*/
void EmuApi::EmuZwSetSecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SecurityInformation);

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityDescriptor);


    NTSTATUS ZwSetSecurityObjectResult = ZwSetSecurityObject((HANDLE)Handle,(SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&SecurityDescriptor);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetSecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityDescriptor);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetSecurityObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySecurityObject(
    IN   HANDLE                Handle               ,
    IN   SECURITY_INFORMATION  SecurityInformation  ,
    OUT  PSECURITY_DESCRIPTOR  SecurityDescriptor   ,
    IN   ULONG                 Length               ,
    OUT  PULONG                LengthNeeded         );

*/
void EmuApi::EmuZwQuerySecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SecurityInformation);

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityDescriptor);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    PULONG LengthNeeded{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &LengthNeeded, sizeof(LengthNeeded));

    ULONG rlLengthNeeded{};

    if(LengthNeeded != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LengthNeeded, &rlLengthNeeded, sizeof(rlLengthNeeded));
    }


    NTSTATUS ZwQuerySecurityObjectResult = ZwQuerySecurityObject((HANDLE)Handle,(SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(ULONG)Length,(PULONG)&rlLengthNeeded);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    uc_reg_write(uc, UC_X86_REG_EDX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &LengthNeeded, sizeof(LengthNeeded));

    if(LengthNeeded != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LengthNeeded, &rlLengthNeeded, sizeof(rlLengthNeeded));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySecurityObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwClose(
    IN  HANDLE  Handle  );

*/
void EmuApi::EmuZwClose(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    NTSTATUS ZwCloseResult = ZwClose((HANDLE)Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCloseResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwClose\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateDirectoryObject(
    OUT  PHANDLE             DirectoryHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwCreateDirectoryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DirectoryHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DirectoryHandle);

    HANDLE dpDirectoryHandle{};

    if(DirectoryHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwCreateDirectoryObjectResult = ZwCreateDirectoryObject((PHANDLE)dpDirectoryHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateDirectoryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DirectoryHandle);

    if(DirectoryHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateDirectoryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenDirectoryObject(
    OUT  PHANDLE             DirectoryHandle   ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenDirectoryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DirectoryHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DirectoryHandle);

    HANDLE dpDirectoryHandle{};

    if(DirectoryHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenDirectoryObjectResult = ZwOpenDirectoryObject((PHANDLE)dpDirectoryHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenDirectoryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DirectoryHandle);

    if(DirectoryHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DirectoryHandle, &dpDirectoryHandle, sizeof(dpDirectoryHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenDirectoryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryDirectoryObject(
    IN     HANDLE   DirectoryHandle    ,
    OUT    PVOID    Buffer             ,
    IN     ULONG    Length             ,
    IN     BOOLEAN  ReturnSingleEntry  ,
    IN     BOOLEAN  RestartScan        ,
    INOUT  PULONG   Context            ,
    OUT    PULONG   ReturnLength       );

*/
void EmuApi::EmuZwQueryDirectoryObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE DirectoryHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DirectoryHandle);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Buffer);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Length);

    BOOLEAN ReturnSingleEntry{};
    uc_reg_read(uc, UC_X86_REG_R9B, &ReturnSingleEntry);

    BOOLEAN RestartScan{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RestartScan, sizeof(RestartScan));

    PULONG Context{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Context, sizeof(Context));

    ULONG rlContext{};

    if(Context != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Context, &rlContext, sizeof(rlContext));
    }

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryDirectoryObjectResult = ZwQueryDirectoryObject((HANDLE)DirectoryHandle,(PVOID)&Buffer,(ULONG)Length,(BOOLEAN)ReturnSingleEntry,(BOOLEAN)RestartScan,(PULONG)&rlContext,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryDirectoryObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DirectoryHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &Length);
    uc_reg_write(uc, UC_X86_REG_R9B, &ReturnSingleEntry);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RestartScan, sizeof(RestartScan));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Context, sizeof(Context));

    if(Context != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Context, &rlContext, sizeof(rlContext));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryDirectoryObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateSymbolicLinkObject(
    OUT  PHANDLE             LinkHandle        ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN   PUNICODE_STRING     LinkTarget        );

*/
void EmuApi::EmuZwCreateSymbolicLinkObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LinkHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LinkHandle);

    HANDLE dpLinkHandle{};

    if(LinkHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PUNICODE_STRING LinkTarget{};
    uc_reg_read(uc, UC_X86_REG_R9, &LinkTarget);

    std::wstring rlwLinkTarget;

    USHORT rlLengthLinkTarget;

    USHORT rlMaxLengthLinkTarget;
    uc_mem_read(uc, (DWORD_PTR)LinkTarget, &rlLengthLinkTarget, sizeof(rlLengthLinkTarget));
    uc_mem_read(uc, (DWORD_PTR)LinkTarget+16, &rlMaxLengthLinkTarget, sizeof(rlMaxLengthLinkTarget));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, rlwLinkTarget, true, rlLengthLinkTarget)) { printf("Error when read LinkTarget in ZwCreateSymbolicLinkObject"); _CrtDbgBreak(); }

    UNICODE_STRING stLinkTarget{};
    stLinkTarget.Length = rlLengthLinkTarget;
    stLinkTarget.MaximumLength = rlMaxLengthLinkTarget;
    stLinkTarget.Buffer = rlwLinkTarget.data();


    NTSTATUS ZwCreateSymbolicLinkObjectResult = ZwCreateSymbolicLinkObject((PHANDLE)dpLinkHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PUNICODE_STRING)&stLinkTarget);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateSymbolicLinkObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LinkHandle);

    if(LinkHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_mem_write(uc, (DWORD_PTR)LinkTarget, &stLinkTarget.Length, sizeof(stLinkTarget.Length));
    uc_mem_write(uc, (DWORD_PTR)LinkTarget+16, &stLinkTarget.MaximumLength, sizeof(stLinkTarget.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, stLinkTarget.Buffer, true, stLinkTarget.Length)) { printf("Error when read LinkTarget in ZwCreateSymbolicLinkObject"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateSymbolicLinkObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenSymbolicLinkObject(
    OUT  PHANDLE             LinkHandle        ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenSymbolicLinkObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LinkHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LinkHandle);

    HANDLE dpLinkHandle{};

    if(LinkHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenSymbolicLinkObjectResult = ZwOpenSymbolicLinkObject((PHANDLE)dpLinkHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenSymbolicLinkObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LinkHandle);

    if(LinkHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)LinkHandle, &dpLinkHandle, sizeof(dpLinkHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenSymbolicLinkObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQuerySymbolicLinkObject(
    IN     HANDLE           LinkHandle      ,
    INOUT  PUNICODE_STRING  LinkTarget      ,
    OUT    PULONG           ReturnedLength  );

*/
void EmuApi::EmuZwQuerySymbolicLinkObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE LinkHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &LinkHandle);

    PUNICODE_STRING LinkTarget{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LinkTarget);

    std::wstring rlwLinkTarget;

    USHORT rlLengthLinkTarget;

    USHORT rlMaxLengthLinkTarget;
    uc_mem_read(uc, (DWORD_PTR)LinkTarget, &rlLengthLinkTarget, sizeof(rlLengthLinkTarget));
    uc_mem_read(uc, (DWORD_PTR)LinkTarget+16, &rlMaxLengthLinkTarget, sizeof(rlMaxLengthLinkTarget));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, rlwLinkTarget, true, rlLengthLinkTarget)) { printf("Error when read LinkTarget in ZwQuerySymbolicLinkObject"); _CrtDbgBreak(); }

    UNICODE_STRING stLinkTarget{};
    stLinkTarget.Length = rlLengthLinkTarget;
    stLinkTarget.MaximumLength = rlMaxLengthLinkTarget;
    stLinkTarget.Buffer = rlwLinkTarget.data();

    PULONG ReturnedLength{};
    uc_reg_read(uc, UC_X86_REG_R8, &ReturnedLength);

    ULONG rlReturnedLength{};

    if(ReturnedLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnedLength, &rlReturnedLength, sizeof(rlReturnedLength));
    }


    NTSTATUS ZwQuerySymbolicLinkObjectResult = ZwQuerySymbolicLinkObject((HANDLE)LinkHandle,(PUNICODE_STRING)&stLinkTarget,(PULONG)&rlReturnedLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQuerySymbolicLinkObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &LinkHandle);
    uc_mem_write(uc, (DWORD_PTR)LinkTarget, &stLinkTarget.Length, sizeof(stLinkTarget.Length));
    uc_mem_write(uc, (DWORD_PTR)LinkTarget+16, &stLinkTarget.MaximumLength, sizeof(stLinkTarget.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)LinkTarget+64, stLinkTarget.Buffer, true, stLinkTarget.Length)) { printf("Error when read LinkTarget in ZwQuerySymbolicLinkObject"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &ReturnedLength);

    if(ReturnedLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnedLength, &rlReturnedLength, sizeof(rlReturnedLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQuerySymbolicLinkObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwGetPlugPlayEvent(
    IN          HANDLE                 EventHandle      ,
    INOPTIONAL  PVOID                  Context          ,
    OUT         PPLUGPLAY_EVENT_BLOCK  EventBlock       ,
    IN          ULONG                  EventBufferSize  );

*/
void EmuApi::EmuZwGetPlugPlayEvent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE EventHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &EventHandle);

    PVOID Context{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Context);

    PPLUGPLAY_EVENT_BLOCK EventBlock{};
    uc_reg_read(uc, UC_X86_REG_R8, &EventBlock);

    PLUGPLAY_EVENT_BLOCK stEventBlock{};

    if(EventBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)EventBlock, &stEventBlock, sizeof(stEventBlock));
    }

    ULONG EventBufferSize{};
    uc_reg_read(uc, UC_X86_REG_R9D, &EventBufferSize);


    NTSTATUS ZwGetPlugPlayEventResult = ZwGetPlugPlayEvent((HANDLE)EventHandle,(PVOID)&Context,(PPLUGPLAY_EVENT_BLOCK)&stEventBlock,(ULONG)EventBufferSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwGetPlugPlayEventResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &EventHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Context);
    uc_reg_write(uc, UC_X86_REG_R8, &EventBlock);

    if(EventBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)EventBlock, &stEventBlock, sizeof(stEventBlock));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &EventBufferSize);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwGetPlugPlayEvent\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS  PnPControlClass       ,
    INOUT  PVOID                   PnPControlData        ,
    IN     ULONG                   PnPControlDataLength  );

*/
void EmuApi::EmuZwPlugPlayControl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PLUGPLAY_CONTROL_CLASS PnPControlClass{};
    uc_reg_read(uc, UC_X86_REG_ECX, &PnPControlClass);

    PVOID PnPControlData{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PnPControlData);

    ULONG PnPControlDataLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &PnPControlDataLength);


    NTSTATUS ZwPlugPlayControlResult = ZwPlugPlayControl((PLUGPLAY_CONTROL_CLASS)PnPControlClass,(PVOID)&PnPControlData,(ULONG)PnPControlDataLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwPlugPlayControlResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &PnPControlClass);
    uc_reg_write(uc, UC_X86_REG_RDX, &PnPControlData);
    uc_reg_write(uc, UC_X86_REG_R8D, &PnPControlDataLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwPlugPlayControl\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwPowerInformation(
    IN           POWER_INFORMATION_LEVEL  InformationLevel    ,
    INOPTIONAL   PVOID                    InputBuffer         ,
    IN           ULONG                    InputBufferLength   ,
    OUTOPTIONAL  PVOID                    OutputBuffer        ,
    IN           ULONG                    OutputBufferLength  );

*/
void EmuApi::EmuZwPowerInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POWER_INFORMATION_LEVEL InformationLevel{};
    uc_reg_read(uc, UC_X86_REG_ECX, &InformationLevel);

    PVOID InputBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &InputBuffer);

    ULONG InputBufferLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &InputBufferLength);

    PVOID OutputBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &OutputBuffer);

    ULONG OutputBufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));


    NTSTATUS ZwPowerInformationResult = ZwPowerInformation((POWER_INFORMATION_LEVEL)InformationLevel,(PVOID)&InputBuffer,(ULONG)InputBufferLength,(PVOID)&OutputBuffer,(ULONG)OutputBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwPowerInformationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &InformationLevel);
    uc_reg_write(uc, UC_X86_REG_RDX, &InputBuffer);
    uc_reg_write(uc, UC_X86_REG_R8D, &InputBufferLength);
    uc_reg_write(uc, UC_X86_REG_R9, &OutputBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &OutputBufferLength, sizeof(OutputBufferLength));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwPowerInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetThreadExecutionState(
    IN   EXECUTION_STATE    esFlags        ,
    OUT  EXECUTION_STATE *  PreviousFlags  );

*/
void EmuApi::EmuZwSetThreadExecutionState(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    EXECUTION_STATE esFlags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &esFlags);

    PEXECUTION_STATE PreviousFlags{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousFlags);

    DWORD rlPreviousFlags{};

    if(PreviousFlags != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousFlags, &rlPreviousFlags, sizeof(rlPreviousFlags));
    }


    NTSTATUS ZwSetThreadExecutionStateResult = ZwSetThreadExecutionState((EXECUTION_STATE)esFlags,(EXECUTION_STATE *)&rlPreviousFlags);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetThreadExecutionStateResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &esFlags);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousFlags);

    if(PreviousFlags != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousFlags, &rlPreviousFlags, sizeof(rlPreviousFlags));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetThreadExecutionState\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRequestWakeupLatency(
    IN  LATENCY_TIME  latency  );

*/
void EmuApi::EmuZwRequestWakeupLatency(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    LATENCY_TIME latency{};
    uc_reg_read(uc, UC_X86_REG_ECX, &latency);


    NTSTATUS ZwRequestWakeupLatencyResult = ZwRequestWakeupLatency((LATENCY_TIME)latency);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRequestWakeupLatencyResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &latency);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRequestWakeupLatency\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateProcess(
    OUT         PHANDLE             ProcessHandle       ,
    IN          ACCESS_MASK         DesiredAccess       ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes    ,
    IN          HANDLE              ParentProcess       ,
    IN          BOOLEAN             InheritObjectTable  ,
    INOPTIONAL  HANDLE              SectionHandle       ,
    INOPTIONAL  HANDLE              DebugPort           ,
    INOPTIONAL  HANDLE              ExceptionPort       );

*/
void EmuApi::EmuZwCreateProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE dpProcessHandle{};

    if(ProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    HANDLE ParentProcess{};
    uc_reg_read(uc, UC_X86_REG_R9, &ParentProcess);

    BOOLEAN InheritObjectTable{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &InheritObjectTable, sizeof(InheritObjectTable));

    HANDLE SectionHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));

    HANDLE DebugPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));

    HANDLE ExceptionPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));


    NTSTATUS ZwCreateProcessResult = ZwCreateProcess((PHANDLE)dpProcessHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(HANDLE)ParentProcess,(BOOLEAN)InheritObjectTable,(HANDLE)SectionHandle,(HANDLE)DebugPort,(HANDLE)ExceptionPort);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);

    if(ProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ParentProcess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &InheritObjectTable, sizeof(InheritObjectTable));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateProcessEx(
    OUT         PHANDLE             ProcessHandle     ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          HANDLE              ParentProcess     ,
    IN          ULONG               Flags             ,
    INOPTIONAL  HANDLE              SectionHandle     ,
    INOPTIONAL  HANDLE              DebugPort         ,
    INOPTIONAL  HANDLE              ExceptionPort     ,
    IN          ULONG               JobMemberLevel    );

*/
void EmuApi::EmuZwCreateProcessEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE dpProcessHandle{};

    if(ProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    HANDLE ParentProcess{};
    uc_reg_read(uc, UC_X86_REG_R9, &ParentProcess);

    ULONG Flags{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));

    HANDLE SectionHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));

    HANDLE DebugPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));

    HANDLE ExceptionPort{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));

    ULONG JobMemberLevel{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &JobMemberLevel, sizeof(JobMemberLevel));


    NTSTATUS ZwCreateProcessExResult = ZwCreateProcessEx((PHANDLE)dpProcessHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(HANDLE)ParentProcess,(ULONG)Flags,(HANDLE)SectionHandle,(HANDLE)DebugPort,(HANDLE)ExceptionPort,(ULONG)JobMemberLevel);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateProcessExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);

    if(ProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ParentProcess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &SectionHandle, sizeof(SectionHandle));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DebugPort, sizeof(DebugPort));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ExceptionPort, sizeof(ExceptionPort));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &JobMemberLevel, sizeof(JobMemberLevel));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateProcessEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenProcess(
    OUT         PHANDLE             ProcessHandle     ,
    IN          ACCESS_MASK         DesiredAccess     ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes  ,
    INOPTIONAL  PCLIENT_ID          ClientId          );

*/
void EmuApi::EmuZwOpenProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE dpProcessHandle{};

    if(ProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PCLIENT_ID ClientId{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientId);

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }


    NTSTATUS ZwOpenProcessResult = ZwOpenProcess((PHANDLE)dpProcessHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PCLIENT_ID)&stClientId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);

    if(ProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessHandle, &dpProcessHandle, sizeof(dpProcessHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientId);

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwTerminateProcess(
    INOPTIONAL  HANDLE    ProcessHandle  ,
    IN          NTSTATUS  ExitStatus     );

*/
void EmuApi::EmuZwTerminateProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ExitStatus);


    NTSTATUS ZwTerminateProcessResult = ZwTerminateProcess((HANDLE)ProcessHandle,(NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwTerminateProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwTerminateProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationProcess(
    IN           HANDLE            ProcessHandle             ,
    IN           PROCESSINFOCLASS  ProcessInformationClass   ,
    OUT          PVOID             ProcessInformation        ,
    IN           ULONG             ProcessInformationLength  ,
    OUTOPTIONAL  PULONG            ReturnLength              );

*/
void EmuApi::EmuZwQueryInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PROCESSINFOCLASS ProcessInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ProcessInformationClass);

    PVOID ProcessInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProcessInformation);

    ULONG ProcessInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ProcessInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryInformationProcessResult = ZwQueryInformationProcess((HANDLE)ProcessHandle,(PROCESSINFOCLASS)ProcessInformationClass,(PVOID)&ProcessInformation,(ULONG)ProcessInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ProcessInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ProcessInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ProcessInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwGetNextProcess(
    IN   HANDLE       ProcessHandle     ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   ULONG        HandleAttributes  ,
    IN   ULONG        Flags             ,
    OUT  PHANDLE      NewProcessHandle  );

*/
void EmuApi::EmuZwGetNextProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HandleAttributes);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Flags);

    HANDLE NewProcessHandle{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &NewProcessHandle, sizeof(NewProcessHandle));

    HANDLE dpNewProcessHandle{};

    if(NewProcessHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewProcessHandle, &dpNewProcessHandle, sizeof(dpNewProcessHandle));
    }


    NTSTATUS ZwGetNextProcessResult = ZwGetNextProcess((HANDLE)ProcessHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(ULONG)Flags,(PHANDLE)dpNewProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwGetNextProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8D, &HandleAttributes);
    uc_reg_write(uc, UC_X86_REG_R9D, &Flags);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &NewProcessHandle, sizeof(NewProcessHandle));

    if(NewProcessHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewProcessHandle, &dpNewProcessHandle, sizeof(dpNewProcessHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwGetNextProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwGetNextThread(
    IN   HANDLE       ProcessHandle     ,
    IN   HANDLE       ThreadHandle      ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   ULONG        HandleAttributes  ,
    IN   ULONG        Flags             ,
    OUT  PHANDLE      NewThreadHandle   );

*/
void EmuApi::EmuZwGetNextThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DesiredAccess);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R9D, &HandleAttributes);

    ULONG Flags{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));

    HANDLE NewThreadHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NewThreadHandle, sizeof(NewThreadHandle));

    HANDLE dpNewThreadHandle{};

    if(NewThreadHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewThreadHandle, &dpNewThreadHandle, sizeof(dpNewThreadHandle));
    }


    NTSTATUS ZwGetNextThreadResult = ZwGetNextThread((HANDLE)ProcessHandle,(HANDLE)ThreadHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(ULONG)Flags,(PHANDLE)dpNewThreadHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwGetNextThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R9D, &HandleAttributes);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NewThreadHandle, sizeof(NewThreadHandle));

    if(NewThreadHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewThreadHandle, &dpNewThreadHandle, sizeof(dpNewThreadHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwGetNextThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryPortInformationProcess(VOID);

*/
void EmuApi::EmuZwQueryPortInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS ZwQueryPortInformationProcessResult = ZwQueryPortInformationProcess();


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryPortInformationProcessResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryPortInformationProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationProcess(
    IN  HANDLE            ProcessHandle             ,
    IN  PROCESSINFOCLASS  ProcessInformationClass   ,
    IN  PVOID             ProcessInformation        ,
    IN  ULONG             ProcessInformationLength  );

*/
void EmuApi::EmuZwSetInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    PROCESSINFOCLASS ProcessInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ProcessInformationClass);

    PVOID ProcessInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ProcessInformation);

    ULONG ProcessInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ProcessInformationLength);


    NTSTATUS ZwSetInformationProcessResult = ZwSetInformationProcess((HANDLE)ProcessHandle,(PROCESSINFOCLASS)ProcessInformationClass,(PVOID)&ProcessInformation,(ULONG)ProcessInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ProcessInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ProcessInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ProcessInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateThread(
    OUT         PHANDLE             ThreadHandle      ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  ,
    IN          HANDLE              ProcessHandle     ,
    OUT         PCLIENT_ID          ClientId          ,
    IN          PCONTEXT            ThreadContext     ,
    IN          PINITIAL_TEB        InitialTeb        ,
    IN          BOOLEAN             CreateSuspended   );

*/
void EmuApi::EmuZwCreateThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    HANDLE dpThreadHandle{};

    if(ThreadHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProcessHandle);

    PCLIENT_ID ClientId{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ClientId, sizeof(ClientId));

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }

    PCONTEXT ThreadContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ThreadContext, sizeof(ThreadContext));

    CONTEXT stThreadContext{};

    if(ThreadContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }

    PINITIAL_TEB InitialTeb{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &InitialTeb, sizeof(InitialTeb));

    INITIAL_TEB stInitialTeb{};

    if(InitialTeb != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)InitialTeb, &stInitialTeb, sizeof(stInitialTeb));
    }

    BOOLEAN CreateSuspended{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CreateSuspended, sizeof(CreateSuspended));


    NTSTATUS ZwCreateThreadResult = ZwCreateThread((PHANDLE)dpThreadHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(HANDLE)ProcessHandle,(PCLIENT_ID)&stClientId,(PCONTEXT)&stThreadContext,(PINITIAL_TEB)&stInitialTeb,(BOOLEAN)CreateSuspended);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);

    if(ThreadHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ProcessHandle);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ClientId, sizeof(ClientId));

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ThreadContext, sizeof(ThreadContext));

    if(ThreadContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &InitialTeb, sizeof(InitialTeb));

    if(InitialTeb != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)InitialTeb, &stInitialTeb, sizeof(stInitialTeb));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CreateSuspended, sizeof(CreateSuspended));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenThread(
    OUT         PHANDLE             ThreadHandle      ,
    IN          ACCESS_MASK         DesiredAccess     ,
    IN          POBJECT_ATTRIBUTES  ObjectAttributes  ,
    INOPTIONAL  PCLIENT_ID          ClientId          );

*/
void EmuApi::EmuZwOpenThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    HANDLE dpThreadHandle{};

    if(ThreadHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    PCLIENT_ID ClientId{};
    uc_reg_read(uc, UC_X86_REG_R9, &ClientId);

    CLIENT_ID stClientId{};

    if(ClientId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }


    NTSTATUS ZwOpenThreadResult = ZwOpenThread((PHANDLE)dpThreadHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(PCLIENT_ID)&stClientId);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);

    if(ThreadHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadHandle, &dpThreadHandle, sizeof(dpThreadHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ClientId);

    if(ClientId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ClientId, &stClientId, sizeof(stClientId));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwTerminateThread(
    INOPTIONAL  HANDLE    ThreadHandle  ,
    IN          NTSTATUS  ExitStatus    );

*/
void EmuApi::EmuZwTerminateThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ExitStatus);


    NTSTATUS ZwTerminateThreadResult = ZwTerminateThread((HANDLE)ThreadHandle,(NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwTerminateThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwTerminateThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSuspendThread(
    IN           HANDLE  ThreadHandle          ,
    OUTOPTIONAL  PULONG  PreviousSuspendCount  );

*/
void EmuApi::EmuZwSuspendThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PULONG PreviousSuspendCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    ULONG rlPreviousSuspendCount{};

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }


    NTSTATUS ZwSuspendThreadResult = ZwSuspendThread((HANDLE)ThreadHandle,(PULONG)&rlPreviousSuspendCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSuspendThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSuspendThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwResumeThread(
    IN           HANDLE  ThreadHandle          ,
    OUTOPTIONAL  PULONG  PreviousSuspendCount  );

*/
void EmuApi::EmuZwResumeThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PULONG PreviousSuspendCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    ULONG rlPreviousSuspendCount{};

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }


    NTSTATUS ZwResumeThreadResult = ZwResumeThread((HANDLE)ThreadHandle,(PULONG)&rlPreviousSuspendCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwResumeThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwResumeThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSuspendProcess(
    IN  HANDLE  ProcessHandle  );

*/
void EmuApi::EmuZwSuspendProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);


    NTSTATUS ZwSuspendProcessResult = ZwSuspendProcess((HANDLE)ProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSuspendProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSuspendProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwResumeProcess(
    IN  HANDLE  ProcessHandle  );

*/
void EmuApi::EmuZwResumeProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);


    NTSTATUS ZwResumeProcessResult = ZwResumeProcess((HANDLE)ProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwResumeProcessResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwResumeProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwGetContextThread(
    IN     HANDLE    ThreadHandle   ,
    INOUT  PCONTEXT  ThreadContext  );

*/
void EmuApi::EmuZwGetContextThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PCONTEXT ThreadContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadContext);

    CONTEXT stThreadContext{};

    if(ThreadContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }


    NTSTATUS ZwGetContextThreadResult = ZwGetContextThread((HANDLE)ThreadHandle,(PCONTEXT)&stThreadContext);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwGetContextThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadContext);

    if(ThreadContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwGetContextThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetContextThread(
    IN  HANDLE    ThreadHandle   ,
    IN  PCONTEXT  ThreadContext  );

*/
void EmuApi::EmuZwSetContextThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PCONTEXT ThreadContext{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ThreadContext);

    CONTEXT stThreadContext{};

    if(ThreadContext != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }


    NTSTATUS ZwSetContextThreadResult = ZwSetContextThread((HANDLE)ThreadHandle,(PCONTEXT)&stThreadContext);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetContextThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ThreadContext);

    if(ThreadContext != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ThreadContext, &stThreadContext, sizeof(stThreadContext));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetContextThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationThread(
    IN           HANDLE           ThreadHandle             ,
    IN           THREADINFOCLASS  ThreadInformationClass   ,
    OUT          PVOID            ThreadInformation        ,
    IN           ULONG            ThreadInformationLength  ,
    OUTOPTIONAL  PULONG           ReturnLength             );

*/
void EmuApi::EmuZwQueryInformationThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    THREADINFOCLASS ThreadInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ThreadInformationClass);

    PVOID ThreadInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ThreadInformation);

    ULONG ThreadInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ThreadInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryInformationThreadResult = ZwQueryInformationThread((HANDLE)ThreadHandle,(THREADINFOCLASS)ThreadInformationClass,(PVOID)&ThreadInformation,(ULONG)ThreadInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ThreadInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ThreadInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ThreadInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationThread(
    IN  HANDLE           ThreadHandle             ,
    IN  THREADINFOCLASS  ThreadInformationClass   ,
    IN  PVOID            ThreadInformation        ,
    IN  ULONG            ThreadInformationLength  );

*/
void EmuApi::EmuZwSetInformationThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    THREADINFOCLASS ThreadInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ThreadInformationClass);

    PVOID ThreadInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &ThreadInformation);

    ULONG ThreadInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &ThreadInformationLength);


    NTSTATUS ZwSetInformationThreadResult = ZwSetInformationThread((HANDLE)ThreadHandle,(THREADINFOCLASS)ThreadInformationClass,(PVOID)&ThreadInformation,(ULONG)ThreadInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ThreadInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &ThreadInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &ThreadInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAlertThread(
    IN  HANDLE  ThreadHandle  );

*/
void EmuApi::EmuZwAlertThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);


    NTSTATUS ZwAlertThreadResult = ZwAlertThread((HANDLE)ThreadHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAlertThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAlertThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAlertResumeThread(
    IN           HANDLE  ThreadHandle          ,
    OUTOPTIONAL  PULONG  PreviousSuspendCount  );

*/
void EmuApi::EmuZwAlertResumeThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PULONG PreviousSuspendCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    ULONG rlPreviousSuspendCount{};

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }


    NTSTATUS ZwAlertResumeThreadResult = ZwAlertResumeThread((HANDLE)ThreadHandle,(PULONG)&rlPreviousSuspendCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAlertResumeThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &PreviousSuspendCount);

    if(PreviousSuspendCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousSuspendCount, &rlPreviousSuspendCount, sizeof(rlPreviousSuspendCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAlertResumeThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwImpersonateThread(
    IN  HANDLE                        ServerThreadHandle  ,
    IN  HANDLE                        ClientThreadHandle  ,
    IN  PSECURITY_QUALITY_OF_SERVICE  SecurityQos         );

*/
void EmuApi::EmuZwImpersonateThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ServerThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ServerThreadHandle);

    HANDLE ClientThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ClientThreadHandle);

    PSECURITY_QUALITY_OF_SERVICE SecurityQos{};
    uc_reg_read(uc, UC_X86_REG_R8, &SecurityQos);

    SECURITY_QUALITY_OF_SERVICE stSecurityQos{};

    if(SecurityQos != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }


    NTSTATUS ZwImpersonateThreadResult = ZwImpersonateThread((HANDLE)ServerThreadHandle,(HANDLE)ClientThreadHandle,(PSECURITY_QUALITY_OF_SERVICE)&stSecurityQos);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwImpersonateThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ServerThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ClientThreadHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &SecurityQos);

    if(SecurityQos != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SecurityQos, &stSecurityQos, sizeof(stSecurityQos));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwImpersonateThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwTestAlert(VOID);

*/
void EmuApi::EmuZwTestAlert(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    NTSTATUS ZwTestAlertResult = ZwTestAlert();


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwTestAlertResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwTestAlert\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRegisterThreadTerminatePort(
    IN  HANDLE  PortHandle  );

*/
void EmuApi::EmuZwRegisterThreadTerminatePort(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE PortHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PortHandle);


    NTSTATUS ZwRegisterThreadTerminatePortResult = ZwRegisterThreadTerminatePort((HANDLE)PortHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRegisterThreadTerminatePortResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &PortHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRegisterThreadTerminatePort\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetLdtEntries(
    IN  ULONG  Selector0  ,
    IN  ULONG  Entry0Low  ,
    IN  ULONG  Entry0Hi   ,
    IN  ULONG  Selector1  ,
    IN  ULONG  Entry1Low  ,
    IN  ULONG  Entry1Hi   );

*/
void EmuApi::EmuZwSetLdtEntries(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Selector0{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Selector0);

    ULONG Entry0Low{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Entry0Low);

    ULONG Entry0Hi{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Entry0Hi);

    ULONG Selector1{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Selector1);

    ULONG Entry1Low{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Entry1Low, sizeof(Entry1Low));

    ULONG Entry1Hi{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Entry1Hi, sizeof(Entry1Hi));


    NTSTATUS ZwSetLdtEntriesResult = ZwSetLdtEntries((ULONG)Selector0,(ULONG)Entry0Low,(ULONG)Entry0Hi,(ULONG)Selector1,(ULONG)Entry1Low,(ULONG)Entry1Hi);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetLdtEntriesResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Selector0);
    uc_reg_write(uc, UC_X86_REG_EDX, &Entry0Low);
    uc_reg_write(uc, UC_X86_REG_R8D, &Entry0Hi);
    uc_reg_write(uc, UC_X86_REG_R9D, &Selector1);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Entry1Low, sizeof(Entry1Low));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Entry1Hi, sizeof(Entry1Hi));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetLdtEntries\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueueApcThread(
    IN          HANDLE           ThreadHandle  ,
    IN          PPS_APC_ROUTINE  ApcRoutine    ,
    INOPTIONAL  PVOID            ApcArgument1  ,
    INOPTIONAL  PVOID            ApcArgument2  ,
    INOPTIONAL  PVOID            ApcArgument3  );

*/
void EmuApi::EmuZwQueueApcThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    PPS_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ApcRoutine);

    PVOID ApcArgument1{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcArgument1);

    PVOID ApcArgument2{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcArgument2);

    PVOID ApcArgument3{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ApcArgument3, sizeof(ApcArgument3));


    NTSTATUS ZwQueueApcThreadResult = ZwQueueApcThread((HANDLE)ThreadHandle,(PPS_APC_ROUTINE)ApcRoutine,(PVOID)&ApcArgument1,(PVOID)&ApcArgument2,(PVOID)&ApcArgument3);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueueApcThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcArgument1);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcArgument2);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ApcArgument3, sizeof(ApcArgument3));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueueApcThread\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateJobObject(
    OUT         PHANDLE             JobHandle         ,
    IN          ACCESS_MASK         DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwCreateJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    HANDLE dpJobHandle{};

    if(JobHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwCreateJobObjectResult = ZwCreateJobObject((PHANDLE)dpJobHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);

    if(JobHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenJobObject(
    OUT  PHANDLE             JobHandle         ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    HANDLE dpJobHandle{};

    if(JobHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenJobObjectResult = ZwOpenJobObject((PHANDLE)dpJobHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);

    if(JobHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)JobHandle, &dpJobHandle, sizeof(dpJobHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAssignProcessToJobObject(
    IN  HANDLE  JobHandle      ,
    IN  HANDLE  ProcessHandle  );

*/
void EmuApi::EmuZwAssignProcessToJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcessHandle);


    NTSTATUS ZwAssignProcessToJobObjectResult = ZwAssignProcessToJobObject((HANDLE)JobHandle,(HANDLE)ProcessHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAssignProcessToJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcessHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAssignProcessToJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwTerminateJobObject(
    IN  HANDLE    JobHandle   ,
    IN  NTSTATUS  ExitStatus  );

*/
void EmuApi::EmuZwTerminateJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    NTSTATUS ExitStatus{};
    uc_reg_read(uc, UC_X86_REG_EDX, &ExitStatus);


    NTSTATUS ZwTerminateJobObjectResult = ZwTerminateJobObject((HANDLE)JobHandle,(NTSTATUS)ExitStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwTerminateJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &ExitStatus);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwTerminateJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwIsProcessInJob(
    IN          HANDLE  ProcessHandle  ,
    INOPTIONAL  HANDLE  JobHandle      );

*/
void EmuApi::EmuZwIsProcessInJob(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &JobHandle);


    NTSTATUS ZwIsProcessInJobResult = ZwIsProcessInJob((HANDLE)ProcessHandle,(HANDLE)JobHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwIsProcessInJobResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &JobHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwIsProcessInJob\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateJobSet(
    IN  ULONG           NumJob      ,
    IN  PJOB_SET_ARRAY  UserJobSet  ,
    IN  ULONG           Flags       );

*/
void EmuApi::EmuZwCreateJobSet(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG NumJob{};
    uc_reg_read(uc, UC_X86_REG_ECX, &NumJob);

    PJOB_SET_ARRAY UserJobSet{};
    uc_reg_read(uc, UC_X86_REG_RDX, &UserJobSet);

    JOB_SET_ARRAY stUserJobSet{};

    if(UserJobSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)UserJobSet, &stUserJobSet, sizeof(stUserJobSet));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS ZwCreateJobSetResult = ZwCreateJobSet((ULONG)NumJob,(PJOB_SET_ARRAY)&stUserJobSet,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateJobSetResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &NumJob);
    uc_reg_write(uc, UC_X86_REG_RDX, &UserJobSet);

    if(UserJobSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)UserJobSet, &stUserJobSet, sizeof(stUserJobSet));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateJobSet\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationJobObject(
    INOPTIONAL   HANDLE              JobHandle                   ,
    IN           JOBOBJECTINFOCLASS  JobObjectInformationClass   ,
    OUT          PVOID               JobObjectInformation        ,
    IN           ULONG               JobObjectInformationLength  ,
    OUTOPTIONAL  PULONG              ReturnLength                );

*/
void EmuApi::EmuZwQueryInformationJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    JOBOBJECTINFOCLASS JobObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &JobObjectInformationClass);

    PVOID JobObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &JobObjectInformation);

    ULONG JobObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &JobObjectInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryInformationJobObjectResult = ZwQueryInformationJobObject((HANDLE)JobHandle,(JOBOBJECTINFOCLASS)JobObjectInformationClass,(PVOID)&JobObjectInformation,(ULONG)JobObjectInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &JobObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &JobObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &JobObjectInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationJobObject(
    IN  HANDLE              JobHandle                   ,
    IN  JOBOBJECTINFOCLASS  JobObjectInformationClass   ,
    IN  PVOID               JobObjectInformation        ,
    IN  ULONG               JobObjectInformationLength  );

*/
void EmuApi::EmuZwSetInformationJobObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE JobHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &JobHandle);

    JOBOBJECTINFOCLASS JobObjectInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &JobObjectInformationClass);

    PVOID JobObjectInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &JobObjectInformation);

    ULONG JobObjectInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &JobObjectInformationLength);


    NTSTATUS ZwSetInformationJobObjectResult = ZwSetInformationJobObject((HANDLE)JobHandle,(JOBOBJECTINFOCLASS)JobObjectInformationClass,(PVOID)&JobObjectInformation,(ULONG)JobObjectInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationJobObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &JobHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &JobObjectInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &JobObjectInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &JobObjectInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationJobObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateKey(
    OUT          PHANDLE             KeyHandle         ,
    IN           ACCESS_MASK         DesiredAccess     ,
    IN           POBJECT_ATTRIBUTES  ObjectAttributes  ,
                 ULONG               TitleIndex        ,
    INOPTIONAL   PUNICODE_STRING     Class             ,
    IN           ULONG               CreateOptions     ,
    OUTOPTIONAL  PULONG              Disposition       );

*/
void EmuApi::EmuZwCreateKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE dpKeyHandle{};

    if(KeyHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    ULONG TitleIndex{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TitleIndex);

    PUNICODE_STRING Class{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Class, sizeof(Class));

    std::wstring rlwClass;

    USHORT rlLengthClass;

    USHORT rlMaxLengthClass;
    uc_mem_read(uc, (DWORD_PTR)Class, &rlLengthClass, sizeof(rlLengthClass));
    uc_mem_read(uc, (DWORD_PTR)Class+16, &rlMaxLengthClass, sizeof(rlMaxLengthClass));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)Class+64, rlwClass, true, rlLengthClass)) { printf("Error when read Class in ZwCreateKey"); _CrtDbgBreak(); }

    UNICODE_STRING stClass{};
    stClass.Length = rlLengthClass;
    stClass.MaximumLength = rlMaxLengthClass;
    stClass.Buffer = rlwClass.data();

    ULONG CreateOptions{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CreateOptions, sizeof(CreateOptions));

    PULONG Disposition{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Disposition, sizeof(Disposition));

    ULONG rlDisposition{};

    if(Disposition != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Disposition, &rlDisposition, sizeof(rlDisposition));
    }


    NTSTATUS ZwCreateKeyResult = ZwCreateKey((PHANDLE)dpKeyHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(ULONG)TitleIndex,(PUNICODE_STRING)&stClass,(ULONG)CreateOptions,(PULONG)&rlDisposition);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);

    if(KeyHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &TitleIndex);
    uc_mem_write(uc, (DWORD_PTR)Class, &stClass.Length, sizeof(stClass.Length));
    uc_mem_write(uc, (DWORD_PTR)Class+16, &stClass.MaximumLength, sizeof(stClass.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)Class+64, stClass.Buffer, true, stClass.Length)) { printf("Error when read Class in ZwCreateKey"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &CreateOptions, sizeof(CreateOptions));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Disposition, sizeof(Disposition));

    if(Disposition != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Disposition, &rlDisposition, sizeof(rlDisposition));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteKey(
    IN  HANDLE  KeyHandle  );

*/
void EmuApi::EmuZwDeleteKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);


    NTSTATUS ZwDeleteKeyResult = ZwDeleteKey((HANDLE)KeyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteValueKey(
    IN  HANDLE           KeyHandle  ,
    IN  PUNICODE_STRING  ValueName  );

*/
void EmuApi::EmuZwDeleteValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING ValueName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueName);

    std::wstring rlwValueName;

    USHORT rlLengthValueName;

    USHORT rlMaxLengthValueName;
    uc_mem_read(uc, (DWORD_PTR)ValueName, &rlLengthValueName, sizeof(rlLengthValueName));
    uc_mem_read(uc, (DWORD_PTR)ValueName+16, &rlMaxLengthValueName, sizeof(rlMaxLengthValueName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, rlwValueName, true, rlLengthValueName)) { printf("Error when read ValueName in ZwDeleteValueKey"); _CrtDbgBreak(); }

    UNICODE_STRING stValueName{};
    stValueName.Length = rlLengthValueName;
    stValueName.MaximumLength = rlMaxLengthValueName;
    stValueName.Buffer = rlwValueName.data();


    NTSTATUS ZwDeleteValueKeyResult = ZwDeleteValueKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stValueName);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)ValueName, &stValueName.Length, sizeof(stValueName.Length));
    uc_mem_write(uc, (DWORD_PTR)ValueName+16, &stValueName.MaximumLength, sizeof(stValueName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, stValueName.Buffer, true, stValueName.Length)) { printf("Error when read ValueName in ZwDeleteValueKey"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwEnumerateKey(
    IN           HANDLE                 KeyHandle            ,
    IN           ULONG                  Index                ,
    IN           KEY_INFORMATION_CLASS  KeyInformationClass  ,
    OUTOPTIONAL  PVOID                  KeyInformation       ,
    IN           ULONG                  Length               ,
    OUT          PULONG                 ResultLength         );

*/
void EmuApi::EmuZwEnumerateKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    ULONG Index{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Index);

    KEY_INFORMATION_CLASS KeyInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &KeyInformationClass);

    PVOID KeyInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &KeyInformation);

    ULONG Length{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));

    PULONG ResultLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS ZwEnumerateKeyResult = ZwEnumerateKey((HANDLE)KeyHandle,(ULONG)Index,(KEY_INFORMATION_CLASS)KeyInformationClass,(PVOID)&KeyInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwEnumerateKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Index);
    uc_reg_write(uc, UC_X86_REG_R8D, &KeyInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &KeyInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwEnumerateKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwEnumerateValueKey(
    IN           HANDLE                       KeyHandle                 ,
    IN           ULONG                        Index                     ,
    IN           KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass  ,
    OUTOPTIONAL  PVOID                        KeyValueInformation       ,
    IN           ULONG                        Length                    ,
    OUT          PULONG                       ResultLength              );

*/
void EmuApi::EmuZwEnumerateValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    ULONG Index{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Index);

    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &KeyValueInformationClass);

    PVOID KeyValueInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &KeyValueInformation);

    ULONG Length{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));

    PULONG ResultLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS ZwEnumerateValueKeyResult = ZwEnumerateValueKey((HANDLE)KeyHandle,(ULONG)Index,(KEY_VALUE_INFORMATION_CLASS)KeyValueInformationClass,(PVOID)&KeyValueInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwEnumerateValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Index);
    uc_reg_write(uc, UC_X86_REG_R8D, &KeyValueInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &KeyValueInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwEnumerateValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFlushKey(
    IN  HANDLE  KeyHandle  );

*/
void EmuApi::EmuZwFlushKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);


    NTSTATUS ZwFlushKeyResult = ZwFlushKey((HANDLE)KeyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFlushKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFlushKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwInitializeRegistry(
    IN  USHORT  BootCondition  );

*/
void EmuApi::EmuZwInitializeRegistry(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    USHORT BootCondition{};
    uc_reg_read(uc, UC_X86_REG_CX, &BootCondition);


    NTSTATUS ZwInitializeRegistryResult = ZwInitializeRegistry((USHORT)BootCondition);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwInitializeRegistryResult);
    uc_reg_write(uc, UC_X86_REG_CX, &BootCondition);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwInitializeRegistry\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwNotifyChangeKey(
    IN           HANDLE            KeyHandle         ,
    INOPTIONAL   HANDLE            Event             ,
    INOPTIONAL   PIO_APC_ROUTINE   ApcRoutine        ,
    INOPTIONAL   PVOID             ApcContext        ,
    OUT          PIO_STATUS_BLOCK  IoStatusBlock     ,
    IN           ULONG             CompletionFilter  ,
    IN           BOOLEAN           WatchTree         ,
    OUTOPTIONAL  PVOID             Buffer            ,
    IN           ULONG             BufferSize        ,
    IN           BOOLEAN           Asynchronous      );

*/
void EmuApi::EmuZwNotifyChangeKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);

    PIO_APC_ROUTINE ApcRoutine{};
    uc_reg_read(uc, UC_X86_REG_R8, &ApcRoutine);

    PVOID ApcContext{};
    uc_reg_read(uc, UC_X86_REG_R9, &ApcContext);

    PIO_STATUS_BLOCK IoStatusBlock{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG CompletionFilter{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &CompletionFilter, sizeof(CompletionFilter));

    BOOLEAN WatchTree{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &WatchTree, sizeof(WatchTree));

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Buffer, sizeof(Buffer));

    ULONG BufferSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &BufferSize, sizeof(BufferSize));

    BOOLEAN Asynchronous{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Asynchronous, sizeof(Asynchronous));


    NTSTATUS ZwNotifyChangeKeyResult = ZwNotifyChangeKey((HANDLE)KeyHandle,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)CompletionFilter,(BOOLEAN)WatchTree,(PVOID)&Buffer,(ULONG)BufferSize,(BOOLEAN)Asynchronous);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwNotifyChangeKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    uc_reg_write(uc, UC_X86_REG_R8, &ApcRoutine);
    uc_reg_write(uc, UC_X86_REG_R9, &ApcContext);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &CompletionFilter, sizeof(CompletionFilter));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &WatchTree, sizeof(WatchTree));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Asynchronous, sizeof(Asynchronous));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwNotifyChangeKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwNotifyChangeMultipleKeys(
    IN           HANDLE               MasterKeyHandle   ,
    INOPTIONAL   ULONG                Count             ,
    INOPTIONAL   OBJECT_ATTRIBUTES *  SlaveObjects      ,
    INOPTIONAL   HANDLE               Event             ,
    INOPTIONAL   PIO_APC_ROUTINE      ApcRoutine        ,
    INOPTIONAL   PVOID                ApcContext        ,
    OUT          PIO_STATUS_BLOCK     IoStatusBlock     ,
    IN           ULONG                CompletionFilter  ,
    IN           BOOLEAN              WatchTree         ,
    OUTOPTIONAL  PVOID                Buffer            ,
    IN           ULONG                BufferSize        ,
    IN           BOOLEAN              Asynchronous      );

*/
void EmuApi::EmuZwNotifyChangeMultipleKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE MasterKeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &MasterKeyHandle);

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Count);

    POBJECT_ATTRIBUTES SlaveObjects{};
    uc_reg_read(uc, UC_X86_REG_R8, &SlaveObjects);

    OBJECT_ATTRIBUTES rlSlaveObjects{};

    if(SlaveObjects != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SlaveObjects, &rlSlaveObjects, sizeof(rlSlaveObjects));
    }

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_R9, &Event);

    PIO_APC_ROUTINE ApcRoutine{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ApcRoutine, sizeof(ApcRoutine));

    PVOID ApcContext{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ApcContext, sizeof(ApcContext));

    PIO_STATUS_BLOCK IoStatusBlock{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &IoStatusBlock, sizeof(IoStatusBlock));

    IO_STATUS_BLOCK stIoStatusBlock{};

    if(IoStatusBlock != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }

    ULONG CompletionFilter{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));

    BOOLEAN WatchTree{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));

    PVOID Buffer{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Buffer, sizeof(Buffer));

    ULONG BufferSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &BufferSize, sizeof(BufferSize));

    BOOLEAN Asynchronous{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &Asynchronous, sizeof(Asynchronous));


    NTSTATUS ZwNotifyChangeMultipleKeysResult = ZwNotifyChangeMultipleKeys((HANDLE)MasterKeyHandle,(ULONG)Count,(OBJECT_ATTRIBUTES *)&rlSlaveObjects,(HANDLE)Event,(PIO_APC_ROUTINE)ApcRoutine,(PVOID)&ApcContext,(PIO_STATUS_BLOCK)&stIoStatusBlock,(ULONG)CompletionFilter,(BOOLEAN)WatchTree,(PVOID)&Buffer,(ULONG)BufferSize,(BOOLEAN)Asynchronous);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwNotifyChangeMultipleKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &MasterKeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Count);
    uc_reg_write(uc, UC_X86_REG_R8, &SlaveObjects);

    if(SlaveObjects != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SlaveObjects, &rlSlaveObjects, sizeof(rlSlaveObjects));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Event);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ApcRoutine, sizeof(ApcRoutine));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ApcContext, sizeof(ApcContext));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &IoStatusBlock, sizeof(IoStatusBlock));

    if(IoStatusBlock != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)IoStatusBlock, &stIoStatusBlock, sizeof(stIoStatusBlock));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &CompletionFilter, sizeof(CompletionFilter));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &WatchTree, sizeof(WatchTree));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Buffer, sizeof(Buffer));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &BufferSize, sizeof(BufferSize));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &Asynchronous, sizeof(Asynchronous));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwNotifyChangeMultipleKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLoadKey(
    IN  POBJECT_ATTRIBUTES  TargetKey   ,
    IN  POBJECT_ATTRIBUTES  SourceFile  );

*/
void EmuApi::EmuZwLoadKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    POBJECT_ATTRIBUTES SourceFile{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceFile);

    OBJECT_ATTRIBUTES rlSourceFile{};

    if(SourceFile != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceFile, &rlSourceFile, sizeof(rlSourceFile));
    }


    NTSTATUS ZwLoadKeyResult = ZwLoadKey((POBJECT_ATTRIBUTES)&rlTargetKey,(POBJECT_ATTRIBUTES)&rlSourceFile);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLoadKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceFile);

    if(SourceFile != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceFile, &rlSourceFile, sizeof(rlSourceFile));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLoadKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLoadKey2(
    IN  POBJECT_ATTRIBUTES  TargetKey   ,
    IN  POBJECT_ATTRIBUTES  SourceFile  ,
    IN  ULONG               Flags       );

*/
void EmuApi::EmuZwLoadKey2(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    POBJECT_ATTRIBUTES SourceFile{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SourceFile);

    OBJECT_ATTRIBUTES rlSourceFile{};

    if(SourceFile != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SourceFile, &rlSourceFile, sizeof(rlSourceFile));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS ZwLoadKey2Result = ZwLoadKey2((POBJECT_ATTRIBUTES)&rlTargetKey,(POBJECT_ATTRIBUTES)&rlSourceFile,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLoadKey2Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &SourceFile);

    if(SourceFile != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SourceFile, &rlSourceFile, sizeof(rlSourceFile));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLoadKey2\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenKey(
    OUT  PHANDLE             KeyHandle         ,
    IN   ACCESS_MASK         DesiredAccess     ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes  );

*/
void EmuApi::EmuZwOpenKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE dpKeyHandle{};

    if(KeyHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }


    NTSTATUS ZwOpenKeyResult = ZwOpenKey((PHANDLE)dpKeyHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);

    if(KeyHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyHandle, &dpKeyHandle, sizeof(dpKeyHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryKey(
    IN           HANDLE                 KeyHandle            ,
    IN           KEY_INFORMATION_CLASS  KeyInformationClass  ,
    OUTOPTIONAL  PVOID                  KeyInformation       ,
    IN           ULONG                  Length               ,
    OUT          PULONG                 ResultLength         );

*/
void EmuApi::EmuZwQueryKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    KEY_INFORMATION_CLASS KeyInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &KeyInformationClass);

    PVOID KeyInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &KeyInformation);

    ULONG Length{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Length);

    PULONG ResultLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS ZwQueryKeyResult = ZwQueryKey((HANDLE)KeyHandle,(KEY_INFORMATION_CLASS)KeyInformationClass,(PVOID)&KeyInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &KeyInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &KeyInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &Length);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryValueKey(
    IN           HANDLE                       KeyHandle                 ,
    IN           PUNICODE_STRING              ValueName                 ,
    IN           KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass  ,
    OUTOPTIONAL  PVOID                        KeyValueInformation       ,
    IN           ULONG                        Length                    ,
    OUT          PULONG                       ResultLength              );

*/
void EmuApi::EmuZwQueryValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING ValueName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueName);

    std::wstring rlwValueName;

    USHORT rlLengthValueName;

    USHORT rlMaxLengthValueName;
    uc_mem_read(uc, (DWORD_PTR)ValueName, &rlLengthValueName, sizeof(rlLengthValueName));
    uc_mem_read(uc, (DWORD_PTR)ValueName+16, &rlMaxLengthValueName, sizeof(rlMaxLengthValueName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, rlwValueName, true, rlLengthValueName)) { printf("Error when read ValueName in ZwQueryValueKey"); _CrtDbgBreak(); }

    UNICODE_STRING stValueName{};
    stValueName.Length = rlLengthValueName;
    stValueName.MaximumLength = rlMaxLengthValueName;
    stValueName.Buffer = rlwValueName.data();

    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass{};
    uc_reg_read(uc, UC_X86_REG_R8D, &KeyValueInformationClass);

    PVOID KeyValueInformation{};
    uc_reg_read(uc, UC_X86_REG_R9, &KeyValueInformation);

    ULONG Length{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));

    PULONG ResultLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    ULONG rlResultLength{};

    if(ResultLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }


    NTSTATUS ZwQueryValueKeyResult = ZwQueryValueKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stValueName,(KEY_VALUE_INFORMATION_CLASS)KeyValueInformationClass,(PVOID)&KeyValueInformation,(ULONG)Length,(PULONG)&rlResultLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)ValueName, &stValueName.Length, sizeof(stValueName.Length));
    uc_mem_write(uc, (DWORD_PTR)ValueName+16, &stValueName.MaximumLength, sizeof(stValueName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, stValueName.Buffer, true, stValueName.Length)) { printf("Error when read ValueName in ZwQueryValueKey"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &KeyValueInformationClass);
    uc_reg_write(uc, UC_X86_REG_R9, &KeyValueInformation);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Length, sizeof(Length));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ResultLength, sizeof(ResultLength));

    if(ResultLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ResultLength, &rlResultLength, sizeof(rlResultLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryMultipleValueKey(
    IN           HANDLE            KeyHandle             ,
    INOUT        PKEY_VALUE_ENTRY  ValueEntries          ,
    IN           ULONG             EntryCount            ,
    OUT          PVOID             ValueBuffer           ,
    INOUT        PULONG            BufferLength          ,
    OUTOPTIONAL  PULONG            RequiredBufferLength  );

*/
void EmuApi::EmuZwQueryMultipleValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PKEY_VALUE_ENTRY ValueEntries{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueEntries);

    KEY_VALUE_ENTRY stValueEntries{};

    if(ValueEntries != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ValueEntries, &stValueEntries, sizeof(stValueEntries));
    }

    ULONG EntryCount{};
    uc_reg_read(uc, UC_X86_REG_R8D, &EntryCount);

    PVOID ValueBuffer{};
    uc_reg_read(uc, UC_X86_REG_R9, &ValueBuffer);

    PULONG BufferLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &BufferLength, sizeof(BufferLength));

    ULONG rlBufferLength{};

    if(BufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }

    PULONG RequiredBufferLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &RequiredBufferLength, sizeof(RequiredBufferLength));

    ULONG rlRequiredBufferLength{};

    if(RequiredBufferLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequiredBufferLength, &rlRequiredBufferLength, sizeof(rlRequiredBufferLength));
    }


    NTSTATUS ZwQueryMultipleValueKeyResult = ZwQueryMultipleValueKey((HANDLE)KeyHandle,(PKEY_VALUE_ENTRY)&stValueEntries,(ULONG)EntryCount,(PVOID)&ValueBuffer,(PULONG)&rlBufferLength,(PULONG)&rlRequiredBufferLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryMultipleValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ValueEntries);

    if(ValueEntries != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ValueEntries, &stValueEntries, sizeof(stValueEntries));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &EntryCount);
    uc_reg_write(uc, UC_X86_REG_R9, &ValueBuffer);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &BufferLength, sizeof(BufferLength));

    if(BufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferLength, &rlBufferLength, sizeof(rlBufferLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &RequiredBufferLength, sizeof(RequiredBufferLength));

    if(RequiredBufferLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequiredBufferLength, &rlRequiredBufferLength, sizeof(rlRequiredBufferLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryMultipleValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwReplaceKey(
    IN  POBJECT_ATTRIBUTES  NewFile       ,
    IN  HANDLE              TargetHandle  ,
    IN  POBJECT_ATTRIBUTES  OldFile       );

*/
void EmuApi::EmuZwReplaceKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES NewFile{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NewFile);

    OBJECT_ATTRIBUTES rlNewFile{};

    if(NewFile != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewFile, &rlNewFile, sizeof(rlNewFile));
    }

    HANDLE TargetHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TargetHandle);

    POBJECT_ATTRIBUTES OldFile{};
    uc_reg_read(uc, UC_X86_REG_R8, &OldFile);

    OBJECT_ATTRIBUTES rlOldFile{};

    if(OldFile != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldFile, &rlOldFile, sizeof(rlOldFile));
    }


    NTSTATUS ZwReplaceKeyResult = ZwReplaceKey((POBJECT_ATTRIBUTES)&rlNewFile,(HANDLE)TargetHandle,(POBJECT_ATTRIBUTES)&rlOldFile);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwReplaceKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NewFile);

    if(NewFile != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewFile, &rlNewFile, sizeof(rlNewFile));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &TargetHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &OldFile);

    if(OldFile != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldFile, &rlOldFile, sizeof(rlOldFile));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwReplaceKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRenameKey(
    IN  HANDLE           KeyHandle  ,
    IN  PUNICODE_STRING  NewName    );

*/
void EmuApi::EmuZwRenameKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING NewName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NewName);

    std::wstring rlwNewName;

    USHORT rlLengthNewName;

    USHORT rlMaxLengthNewName;
    uc_mem_read(uc, (DWORD_PTR)NewName, &rlLengthNewName, sizeof(rlLengthNewName));
    uc_mem_read(uc, (DWORD_PTR)NewName+16, &rlMaxLengthNewName, sizeof(rlMaxLengthNewName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)NewName+64, rlwNewName, true, rlLengthNewName)) { printf("Error when read NewName in ZwRenameKey"); _CrtDbgBreak(); }

    UNICODE_STRING stNewName{};
    stNewName.Length = rlLengthNewName;
    stNewName.MaximumLength = rlMaxLengthNewName;
    stNewName.Buffer = rlwNewName.data();


    NTSTATUS ZwRenameKeyResult = ZwRenameKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stNewName);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRenameKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)NewName, &stNewName.Length, sizeof(stNewName.Length));
    uc_mem_write(uc, (DWORD_PTR)NewName+16, &stNewName.MaximumLength, sizeof(stNewName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)NewName+64, stNewName.Buffer, true, stNewName.Length)) { printf("Error when read NewName in ZwRenameKey"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRenameKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCompactKeys(
    IN  ULONG     Count     ,
    IN  HANDLE *  KeyArray  );

*/
void EmuApi::EmuZwCompactKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Count{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Count);

    PHANDLE KeyArray{};
    uc_reg_read(uc, UC_X86_REG_RDX, &KeyArray);

    HANDLE rlKeyArray{};

    if(KeyArray != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)KeyArray, &rlKeyArray, sizeof(rlKeyArray));
    }


    NTSTATUS ZwCompactKeysResult = ZwCompactKeys((ULONG)Count,(HANDLE *)rlKeyArray);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCompactKeysResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Count);
    uc_reg_write(uc, UC_X86_REG_RDX, &KeyArray);

    if(KeyArray != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)KeyArray, &rlKeyArray, sizeof(rlKeyArray));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCompactKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCompressKey(
    IN  HANDLE  Key  );

*/
void EmuApi::EmuZwCompressKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE Key{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Key);


    NTSTATUS ZwCompressKeyResult = ZwCompressKey((HANDLE)Key);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCompressKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Key);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCompressKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRestoreKey(
    IN  HANDLE  KeyHandle   ,
    IN  HANDLE  FileHandle  ,
    IN  ULONG   Flags       );

*/
void EmuApi::EmuZwRestoreKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS ZwRestoreKeyResult = ZwRestoreKey((HANDLE)KeyHandle,(HANDLE)FileHandle,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRestoreKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRestoreKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSaveKey(
    IN  HANDLE  KeyHandle   ,
    IN  HANDLE  FileHandle  );

*/
void EmuApi::EmuZwSaveKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileHandle);


    NTSTATUS ZwSaveKeyResult = ZwSaveKey((HANDLE)KeyHandle,(HANDLE)FileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSaveKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &FileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSaveKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSaveKeyEx(
    IN  HANDLE  KeyHandle   ,
    IN  HANDLE  FileHandle  ,
    IN  ULONG   Format      );

*/
void EmuApi::EmuZwSaveKeyEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FileHandle);

    ULONG Format{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Format);


    NTSTATUS ZwSaveKeyExResult = ZwSaveKeyEx((HANDLE)KeyHandle,(HANDLE)FileHandle,(ULONG)Format);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSaveKeyExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &Format);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSaveKeyEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSaveMergedKeys(
    IN  HANDLE  HighPrecedenceKeyHandle  ,
    IN  HANDLE  LowPrecedenceKeyHandle   ,
    IN  HANDLE  FileHandle               );

*/
void EmuApi::EmuZwSaveMergedKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE HighPrecedenceKeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &HighPrecedenceKeyHandle);

    HANDLE LowPrecedenceKeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LowPrecedenceKeyHandle);

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &FileHandle);


    NTSTATUS ZwSaveMergedKeysResult = ZwSaveMergedKeys((HANDLE)HighPrecedenceKeyHandle,(HANDLE)LowPrecedenceKeyHandle,(HANDLE)FileHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSaveMergedKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &HighPrecedenceKeyHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &LowPrecedenceKeyHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &FileHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSaveMergedKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetValueKey(
    IN          HANDLE           KeyHandle   ,
    IN          PUNICODE_STRING  ValueName   ,
    INOPTIONAL  ULONG            TitleIndex  ,
    IN          ULONG            Type        ,
    INOPTIONAL  PVOID            Data        ,
    IN          ULONG            DataSize    );

*/
void EmuApi::EmuZwSetValueKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    PUNICODE_STRING ValueName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ValueName);

    std::wstring rlwValueName;

    USHORT rlLengthValueName;

    USHORT rlMaxLengthValueName;
    uc_mem_read(uc, (DWORD_PTR)ValueName, &rlLengthValueName, sizeof(rlLengthValueName));
    uc_mem_read(uc, (DWORD_PTR)ValueName+16, &rlMaxLengthValueName, sizeof(rlMaxLengthValueName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, rlwValueName, true, rlLengthValueName)) { printf("Error when read ValueName in ZwSetValueKey"); _CrtDbgBreak(); }

    UNICODE_STRING stValueName{};
    stValueName.Length = rlLengthValueName;
    stValueName.MaximumLength = rlMaxLengthValueName;
    stValueName.Buffer = rlwValueName.data();

    ULONG TitleIndex{};
    uc_reg_read(uc, UC_X86_REG_R8D, &TitleIndex);

    ULONG Type{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Type);

    PVOID Data{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Data, sizeof(Data));

    ULONG DataSize{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &DataSize, sizeof(DataSize));


    NTSTATUS ZwSetValueKeyResult = ZwSetValueKey((HANDLE)KeyHandle,(PUNICODE_STRING)&stValueName,(ULONG)TitleIndex,(ULONG)Type,(PVOID)&Data,(ULONG)DataSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetValueKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_mem_write(uc, (DWORD_PTR)ValueName, &stValueName.Length, sizeof(stValueName.Length));
    uc_mem_write(uc, (DWORD_PTR)ValueName+16, &stValueName.MaximumLength, sizeof(stValueName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ValueName+64, stValueName.Buffer, true, stValueName.Length)) { printf("Error when read ValueName in ZwSetValueKey"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &TitleIndex);
    uc_reg_write(uc, UC_X86_REG_R9D, &Type);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Data, sizeof(Data));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &DataSize, sizeof(DataSize));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetValueKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnloadKey(
    IN  POBJECT_ATTRIBUTES  TargetKey  );

*/
void EmuApi::EmuZwUnloadKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }


    NTSTATUS ZwUnloadKeyResult = ZwUnloadKey((POBJECT_ATTRIBUTES)&rlTargetKey);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnloadKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnloadKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnloadKey2(
    IN  POBJECT_ATTRIBUTES  TargetKey  ,
    IN  ULONG               Flags      );

*/
void EmuApi::EmuZwUnloadKey2(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);


    NTSTATUS ZwUnloadKey2Result = ZwUnloadKey2((POBJECT_ATTRIBUTES)&rlTargetKey,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnloadKey2Result);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnloadKey2\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwUnloadKeyEx(
    IN          POBJECT_ATTRIBUTES  TargetKey  ,
    INOPTIONAL  HANDLE              Event      );

*/
void EmuApi::EmuZwUnloadKeyEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);


    NTSTATUS ZwUnloadKeyExResult = ZwUnloadKeyEx((POBJECT_ATTRIBUTES)&rlTargetKey,(HANDLE)Event);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwUnloadKeyExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwUnloadKeyEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationKey(
    IN  HANDLE                     KeyHandle                ,
    IN  KEY_SET_INFORMATION_CLASS  KeySetInformationClass   ,
    IN  PVOID                      KeySetInformation        ,
    IN  ULONG                      KeySetInformationLength  );

*/
void EmuApi::EmuZwSetInformationKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);

    KEY_SET_INFORMATION_CLASS KeySetInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &KeySetInformationClass);

    PVOID KeySetInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &KeySetInformation);

    ULONG KeySetInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &KeySetInformationLength);


    NTSTATUS ZwSetInformationKeyResult = ZwSetInformationKey((HANDLE)KeyHandle,(KEY_SET_INFORMATION_CLASS)KeySetInformationClass,(PVOID)&KeySetInformation,(ULONG)KeySetInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &KeySetInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &KeySetInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &KeySetInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryOpenSubKeys(
    IN   POBJECT_ATTRIBUTES  TargetKey    ,
    OUT  PULONG              HandleCount  );

*/
void EmuApi::EmuZwQueryOpenSubKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    PULONG HandleCount{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleCount);

    ULONG rlHandleCount{};

    if(HandleCount != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)HandleCount, &rlHandleCount, sizeof(rlHandleCount));
    }


    NTSTATUS ZwQueryOpenSubKeysResult = ZwQueryOpenSubKeys((POBJECT_ATTRIBUTES)&rlTargetKey,(PULONG)&rlHandleCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryOpenSubKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleCount);

    if(HandleCount != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)HandleCount, &rlHandleCount, sizeof(rlHandleCount));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryOpenSubKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryOpenSubKeysEx(
    IN   POBJECT_ATTRIBUTES  TargetKey     ,
    IN   ULONG               BufferLength  ,
    OUT  PVOID               Buffer        ,
    OUT  PULONG              RequiredSize  );

*/
void EmuApi::EmuZwQueryOpenSubKeysEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    POBJECT_ATTRIBUTES TargetKey{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TargetKey);

    OBJECT_ATTRIBUTES rlTargetKey{};

    if(TargetKey != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }

    ULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BufferLength);

    PVOID Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    PULONG RequiredSize{};
    uc_reg_read(uc, UC_X86_REG_R9, &RequiredSize);

    ULONG rlRequiredSize{};

    if(RequiredSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequiredSize, &rlRequiredSize, sizeof(rlRequiredSize));
    }


    NTSTATUS ZwQueryOpenSubKeysExResult = ZwQueryOpenSubKeysEx((POBJECT_ATTRIBUTES)&rlTargetKey,(ULONG)BufferLength,(PVOID)&Buffer,(PULONG)&rlRequiredSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryOpenSubKeysExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TargetKey);

    if(TargetKey != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TargetKey, &rlTargetKey, sizeof(rlTargetKey));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &BufferLength);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);
    uc_reg_write(uc, UC_X86_REG_R9, &RequiredSize);

    if(RequiredSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequiredSize, &rlRequiredSize, sizeof(rlRequiredSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryOpenSubKeysEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLockRegistryKey(
    IN  HANDLE  KeyHandle  );

*/
void EmuApi::EmuZwLockRegistryKey(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE KeyHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &KeyHandle);


    NTSTATUS ZwLockRegistryKeyResult = ZwLockRegistryKey((HANDLE)KeyHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLockRegistryKeyResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &KeyHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLockRegistryKey\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwLockProductActivationKeys(
    INOUTOPTIONAL  ULONG *  pPrivateVer  ,
    OUTOPTIONAL    ULONG *  pSafeMode    );

*/
void EmuApi::EmuZwLockProductActivationKeys(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PULONG pPrivateVer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &pPrivateVer);

    ULONG rlpPrivateVer{};

    if(pPrivateVer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pPrivateVer, &rlpPrivateVer, sizeof(rlpPrivateVer));
    }

    PULONG pSafeMode{};
    uc_reg_read(uc, UC_X86_REG_RDX, &pSafeMode);

    ULONG rlpSafeMode{};

    if(pSafeMode != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pSafeMode, &rlpSafeMode, sizeof(rlpSafeMode));
    }


    NTSTATUS ZwLockProductActivationKeysResult = ZwLockProductActivationKeys((ULONG *)&rlpPrivateVer,(ULONG *)&rlpSafeMode);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwLockProductActivationKeysResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &pPrivateVer);

    if(pPrivateVer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pPrivateVer, &rlpPrivateVer, sizeof(rlpPrivateVer));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &pSafeMode);

    if(pSafeMode != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pSafeMode, &rlpSafeMode, sizeof(rlpSafeMode));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwLockProductActivationKeys\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheck(
    IN     PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN     HANDLE                ClientToken         ,
    IN     ACCESS_MASK           DesiredAccess       ,
    IN     PGENERIC_MAPPING      GenericMapping      ,
    OUT    PPRIVILEGE_SET        PrivilegeSet        ,
    INOUT  PULONG                PrivilegeSetLength  ,
    OUT    PACCESS_MASK          GrantedAccess       ,
    OUT    PNTSTATUS             AccessStatus        );

*/
void EmuApi::EmuZwAccessCheck(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DesiredAccess);

    PGENERIC_MAPPING GenericMapping{};
    uc_reg_read(uc, UC_X86_REG_R9, &GenericMapping);

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    PPRIVILEGE_SET PrivilegeSet{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &PrivilegeSet, sizeof(PrivilegeSet));

    PRIVILEGE_SET stPrivilegeSet{};

    if(PrivilegeSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }

    PULONG PrivilegeSetLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    ULONG rlPrivilegeSetLength{};

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }


    NTSTATUS ZwAccessCheckResult = ZwAccessCheck((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(PGENERIC_MAPPING)&rlGenericMapping,(PPRIVILEGE_SET)&stPrivilegeSet,(PULONG)&rlPrivilegeSetLength,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R8D, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R9, &GenericMapping);

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &PrivilegeSet, sizeof(PrivilegeSet));

    if(PrivilegeSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheck\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheckByType(
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          HANDLE                ClientToken           ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    OUT         PPRIVILEGE_SET        PrivilegeSet          ,
    INOUT       PULONG                PrivilegeSetLength    ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          );

*/
void EmuApi::EmuZwAccessCheckByType(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID PrincipalSelfSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PrincipalSelfSid);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    POBJECT_TYPE_LIST ObjectTypeList{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    PPRIVILEGE_SET PrivilegeSet{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    PRIVILEGE_SET stPrivilegeSet{};

    if(PrivilegeSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }

    PULONG PrivilegeSetLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    ULONG rlPrivilegeSetLength{};

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }


    NTSTATUS ZwAccessCheckByTypeResult = ZwAccessCheckByType((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(PPRIVILEGE_SET)&stPrivilegeSet,(PULONG)&rlPrivilegeSetLength,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckByTypeResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &PrincipalSelfSid);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    if(PrivilegeSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheckByType\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheckByTypeResultList(
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          HANDLE                ClientToken           ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    OUT         PPRIVILEGE_SET        PrivilegeSet          ,
    INOUT       PULONG                PrivilegeSetLength    ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          );

*/
void EmuApi::EmuZwAccessCheckByTypeResultList(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SecurityDescriptor);

    PSID PrincipalSelfSid{};
    uc_reg_read(uc, UC_X86_REG_RDX, &PrincipalSelfSid);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    POBJECT_TYPE_LIST ObjectTypeList{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    PPRIVILEGE_SET PrivilegeSet{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    PRIVILEGE_SET stPrivilegeSet{};

    if(PrivilegeSet != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }

    PULONG PrivilegeSetLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    ULONG rlPrivilegeSetLength{};

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }


    NTSTATUS ZwAccessCheckByTypeResultListResult = ZwAccessCheckByTypeResultList((PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(PPRIVILEGE_SET)&stPrivilegeSet,(PULONG)&rlPrivilegeSetLength,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckByTypeResultListResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &SecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &PrincipalSelfSid);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &PrivilegeSet, sizeof(PrivilegeSet));

    if(PrivilegeSet != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSet, &stPrivilegeSet, sizeof(stPrivilegeSet));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &PrivilegeSetLength, sizeof(PrivilegeSetLength));

    if(PrivilegeSetLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegeSetLength, &rlPrivilegeSetLength, sizeof(rlPrivilegeSetLength));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheckByTypeResultList\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCreateToken(
    OUT         PHANDLE               TokenHandle       ,
    IN          ACCESS_MASK           DesiredAccess     ,
    INOPTIONAL  POBJECT_ATTRIBUTES    ObjectAttributes  ,
    IN          TOKEN_TYPE            TokenType         ,
    IN          PLUID                 AuthenticationId  ,
    IN          PLARGE_INTEGER        ExpirationTime    ,
    IN          PTOKEN_USER           User              ,
    IN          PTOKEN_GROUPS         Groups            ,
    IN          PTOKEN_PRIVILEGES     Privileges        ,
    INOPTIONAL  PTOKEN_OWNER          Owner             ,
    IN          PTOKEN_PRIMARY_GROUP  PrimaryGroup      ,
    INOPTIONAL  PTOKEN_DEFAULT_DACL   DefaultDacl       ,
    IN          PTOKEN_SOURCE         TokenSource       );

*/
void EmuApi::EmuZwCreateToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    TOKEN_TYPE TokenType{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TokenType);

    PLUID AuthenticationId{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AuthenticationId, sizeof(AuthenticationId));

    LUID stAuthenticationId{};

    if(AuthenticationId != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AuthenticationId, &stAuthenticationId, sizeof(stAuthenticationId));
    }

    PLARGE_INTEGER ExpirationTime{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ExpirationTime, sizeof(ExpirationTime));

    LARGE_INTEGER rlExpirationTime{};

    if(ExpirationTime != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ExpirationTime, &rlExpirationTime, sizeof(rlExpirationTime));
    }

    PTOKEN_USER User{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &User, sizeof(User));

    TOKEN_USER stUser{};

    if(User != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)User, &stUser, sizeof(stUser));
    }

    PTOKEN_GROUPS Groups{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Groups, sizeof(Groups));

    TOKEN_GROUPS stGroups{};

    if(Groups != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Groups, &stGroups, sizeof(stGroups));
    }

    PTOKEN_PRIVILEGES Privileges{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    TOKEN_PRIVILEGES stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    PTOKEN_OWNER Owner{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Owner, sizeof(Owner));

    TOKEN_OWNER stOwner{};

    if(Owner != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Owner, &stOwner, sizeof(stOwner));
    }

    PTOKEN_PRIMARY_GROUP PrimaryGroup{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &PrimaryGroup, sizeof(PrimaryGroup));

    TOKEN_PRIMARY_GROUP stPrimaryGroup{};

    if(PrimaryGroup != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrimaryGroup, &stPrimaryGroup, sizeof(stPrimaryGroup));
    }

    PTOKEN_DEFAULT_DACL DefaultDacl{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &DefaultDacl, sizeof(DefaultDacl));

    TOKEN_DEFAULT_DACL stDefaultDacl{};

    if(DefaultDacl != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DefaultDacl, &stDefaultDacl, sizeof(stDefaultDacl));
    }

    PTOKEN_SOURCE FnTokenSource{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &FnTokenSource, sizeof(FnTokenSource));

    TOKEN_SOURCE stTokenSource{};

    if(FnTokenSource != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FnTokenSource, &stTokenSource, sizeof(stTokenSource));
    }


    NTSTATUS ZwCreateTokenResult = ZwCreateToken((PHANDLE)dpTokenHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(TOKEN_TYPE)TokenType,(PLUID)&stAuthenticationId,(PLARGE_INTEGER)&rlExpirationTime,(PTOKEN_USER)&stUser,(PTOKEN_GROUPS)&stGroups,(PTOKEN_PRIVILEGES)&stPrivileges,(PTOKEN_OWNER)&stOwner,(PTOKEN_PRIMARY_GROUP)&stPrimaryGroup,(PTOKEN_DEFAULT_DACL)&stDefaultDacl,(PTOKEN_SOURCE)&stTokenSource);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCreateTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &TokenType);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AuthenticationId, sizeof(AuthenticationId));

    if(AuthenticationId != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AuthenticationId, &stAuthenticationId, sizeof(stAuthenticationId));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ExpirationTime, sizeof(ExpirationTime));

    if(ExpirationTime != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ExpirationTime, &rlExpirationTime, sizeof(rlExpirationTime));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+56, &User, sizeof(User));

    if(User != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)User, &stUser, sizeof(stUser));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Groups, sizeof(Groups));

    if(Groups != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Groups, &stGroups, sizeof(stGroups));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &Owner, sizeof(Owner));

    if(Owner != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Owner, &stOwner, sizeof(stOwner));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &PrimaryGroup, sizeof(PrimaryGroup));

    if(PrimaryGroup != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrimaryGroup, &stPrimaryGroup, sizeof(stPrimaryGroup));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+96, &DefaultDacl, sizeof(DefaultDacl));

    if(DefaultDacl != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DefaultDacl, &stDefaultDacl, sizeof(stDefaultDacl));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &FnTokenSource, sizeof(FnTokenSource));

    if(FnTokenSource != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)FnTokenSource, &stTokenSource, sizeof(stTokenSource));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCreateToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCompareTokens(
    IN   HANDLE    FirstTokenHandle   ,
    IN   HANDLE    SecondTokenHandle  ,
    OUT  PBOOLEAN  Equal              );

*/
void EmuApi::EmuZwCompareTokens(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FirstTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FirstTokenHandle);

    HANDLE SecondTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &SecondTokenHandle);

    PBOOLEAN Equal{};
    uc_reg_read(uc, UC_X86_REG_R8, &Equal);

    BOOLEAN rlEqual{};

    if(Equal != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Equal, &rlEqual, sizeof(rlEqual));
    }


    NTSTATUS ZwCompareTokensResult = ZwCompareTokens((HANDLE)FirstTokenHandle,(HANDLE)SecondTokenHandle,(PBOOLEAN)&rlEqual);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCompareTokensResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FirstTokenHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &SecondTokenHandle);
    uc_reg_write(uc, UC_X86_REG_R8, &Equal);

    if(Equal != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Equal, &rlEqual, sizeof(rlEqual));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCompareTokens\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenThreadToken(
    IN   HANDLE       ThreadHandle   ,
    IN   ACCESS_MASK  DesiredAccess  ,
    IN   BOOLEAN      OpenAsSelf     ,
    OUT  PHANDLE      TokenHandle    );

*/
void EmuApi::EmuZwOpenThreadToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    BOOLEAN OpenAsSelf{};
    uc_reg_read(uc, UC_X86_REG_R8B, &OpenAsSelf);

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS ZwOpenThreadTokenResult = ZwOpenThreadToken((HANDLE)ThreadHandle,(ACCESS_MASK)DesiredAccess,(BOOLEAN)OpenAsSelf,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenThreadTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8B, &OpenAsSelf);
    uc_reg_write(uc, UC_X86_REG_R9, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenThreadToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenThreadTokenEx(
    IN   HANDLE       ThreadHandle      ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   BOOLEAN      OpenAsSelf        ,
    IN   ULONG        HandleAttributes  ,
    OUT  PHANDLE      TokenHandle       );

*/
void EmuApi::EmuZwOpenThreadTokenEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    BOOLEAN OpenAsSelf{};
    uc_reg_read(uc, UC_X86_REG_R8B, &OpenAsSelf);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R9D, &HandleAttributes);

    HANDLE TokenHandle{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TokenHandle, sizeof(TokenHandle));

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS ZwOpenThreadTokenExResult = ZwOpenThreadTokenEx((HANDLE)ThreadHandle,(ACCESS_MASK)DesiredAccess,(BOOLEAN)OpenAsSelf,(ULONG)HandleAttributes,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenThreadTokenExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8B, &OpenAsSelf);
    uc_reg_write(uc, UC_X86_REG_R9D, &HandleAttributes);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TokenHandle, sizeof(TokenHandle));

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenThreadTokenEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenProcessToken(
    IN   HANDLE       ProcessHandle  ,
    IN   ACCESS_MASK  DesiredAccess  ,
    OUT  PHANDLE      TokenHandle    );

*/
void EmuApi::EmuZwOpenProcessToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS ZwOpenProcessTokenResult = ZwOpenProcessToken((HANDLE)ProcessHandle,(ACCESS_MASK)DesiredAccess,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenProcessTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenProcessToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenProcessTokenEx(
    IN   HANDLE       ProcessHandle     ,
    IN   ACCESS_MASK  DesiredAccess     ,
    IN   ULONG        HandleAttributes  ,
    OUT  PHANDLE      TokenHandle       );

*/
void EmuApi::EmuZwOpenProcessTokenEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ProcessHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ProcessHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    ULONG HandleAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8D, &HandleAttributes);

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &TokenHandle);

    HANDLE dpTokenHandle{};

    if(TokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }


    NTSTATUS ZwOpenProcessTokenExResult = ZwOpenProcessTokenEx((HANDLE)ProcessHandle,(ACCESS_MASK)DesiredAccess,(ULONG)HandleAttributes,(PHANDLE)dpTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenProcessTokenExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ProcessHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8D, &HandleAttributes);
    uc_reg_write(uc, UC_X86_REG_R9, &TokenHandle);

    if(TokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)TokenHandle, &dpTokenHandle, sizeof(dpTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenProcessTokenEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDuplicateToken(
    IN   HANDLE              ExistingTokenHandle  ,
    IN   ACCESS_MASK         DesiredAccess        ,
    IN   POBJECT_ATTRIBUTES  ObjectAttributes     ,
    IN   BOOLEAN             EffectiveOnly        ,
    IN   TOKEN_TYPE          TokenType            ,
    OUT  PHANDLE             NewTokenHandle       );

*/
void EmuApi::EmuZwDuplicateToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ExistingTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExistingTokenHandle);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_EDX, &DesiredAccess);

    POBJECT_ATTRIBUTES ObjectAttributes{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectAttributes);

    OBJECT_ATTRIBUTES rlObjectAttributes{};

    if(ObjectAttributes != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }

    BOOLEAN EffectiveOnly{};
    uc_reg_read(uc, UC_X86_REG_R9B, &EffectiveOnly);

    TOKEN_TYPE TokenType{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &TokenType, sizeof(TokenType));

    HANDLE NewTokenHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    HANDLE dpNewTokenHandle{};

    if(NewTokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }


    NTSTATUS ZwDuplicateTokenResult = ZwDuplicateToken((HANDLE)ExistingTokenHandle,(ACCESS_MASK)DesiredAccess,(POBJECT_ATTRIBUTES)&rlObjectAttributes,(BOOLEAN)EffectiveOnly,(TOKEN_TYPE)TokenType,(PHANDLE)dpNewTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDuplicateTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExistingTokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &DesiredAccess);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectAttributes);

    if(ObjectAttributes != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectAttributes, &rlObjectAttributes, sizeof(rlObjectAttributes));
    }
    uc_reg_write(uc, UC_X86_REG_R9B, &EffectiveOnly);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &TokenType, sizeof(TokenType));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    if(NewTokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDuplicateToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwFilterToken(
    IN          HANDLE             ExistingTokenHandle  ,
    IN          ULONG              Flags                ,
    INOPTIONAL  PTOKEN_GROUPS      SidsToDisable        ,
    INOPTIONAL  PTOKEN_PRIVILEGES  PrivilegesToDelete   ,
    INOPTIONAL  PTOKEN_GROUPS      RestrictedSids       ,
    OUT         PHANDLE            NewTokenHandle       );

*/
void EmuApi::EmuZwFilterToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ExistingTokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExistingTokenHandle);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PTOKEN_GROUPS SidsToDisable{};
    uc_reg_read(uc, UC_X86_REG_R8, &SidsToDisable);

    TOKEN_GROUPS stSidsToDisable{};

    if(SidsToDisable != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)SidsToDisable, &stSidsToDisable, sizeof(stSidsToDisable));
    }

    PTOKEN_PRIVILEGES PrivilegesToDelete{};
    uc_reg_read(uc, UC_X86_REG_R9, &PrivilegesToDelete);

    TOKEN_PRIVILEGES stPrivilegesToDelete{};

    if(PrivilegesToDelete != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PrivilegesToDelete, &stPrivilegesToDelete, sizeof(stPrivilegesToDelete));
    }

    PTOKEN_GROUPS RestrictedSids{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &RestrictedSids, sizeof(RestrictedSids));

    TOKEN_GROUPS stRestrictedSids{};

    if(RestrictedSids != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RestrictedSids, &stRestrictedSids, sizeof(stRestrictedSids));
    }

    HANDLE NewTokenHandle{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    HANDLE dpNewTokenHandle{};

    if(NewTokenHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }


    NTSTATUS ZwFilterTokenResult = ZwFilterToken((HANDLE)ExistingTokenHandle,(ULONG)Flags,(PTOKEN_GROUPS)&stSidsToDisable,(PTOKEN_PRIVILEGES)&stPrivilegesToDelete,(PTOKEN_GROUPS)&stRestrictedSids,(PHANDLE)dpNewTokenHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwFilterTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExistingTokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &SidsToDisable);

    if(SidsToDisable != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)SidsToDisable, &stSidsToDisable, sizeof(stSidsToDisable));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &PrivilegesToDelete);

    if(PrivilegesToDelete != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PrivilegesToDelete, &stPrivilegesToDelete, sizeof(stPrivilegesToDelete));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &RestrictedSids, sizeof(RestrictedSids));

    if(RestrictedSids != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RestrictedSids, &stRestrictedSids, sizeof(stRestrictedSids));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &NewTokenHandle, sizeof(NewTokenHandle));

    if(NewTokenHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewTokenHandle, &dpNewTokenHandle, sizeof(dpNewTokenHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwFilterToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwImpersonateAnonymousToken(
    IN  HANDLE  ThreadHandle  );

*/
void EmuApi::EmuZwImpersonateAnonymousToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ThreadHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ThreadHandle);


    NTSTATUS ZwImpersonateAnonymousTokenResult = ZwImpersonateAnonymousToken((HANDLE)ThreadHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwImpersonateAnonymousTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ThreadHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwImpersonateAnonymousToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwQueryInformationToken(
    IN   HANDLE                   TokenHandle             ,
    IN   TOKEN_INFORMATION_CLASS  TokenInformationClass   ,
    OUT  PVOID                    TokenInformation        ,
    IN   ULONG                    TokenInformationLength  ,
    OUT  PULONG                   ReturnLength            );

*/
void EmuApi::EmuZwQueryInformationToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    TOKEN_INFORMATION_CLASS TokenInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TokenInformationClass);

    PVOID TokenInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &TokenInformation);

    ULONG TokenInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TokenInformationLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwQueryInformationTokenResult = ZwQueryInformationToken((HANDLE)TokenHandle,(TOKEN_INFORMATION_CLASS)TokenInformationClass,(PVOID)&TokenInformation,(ULONG)TokenInformationLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwQueryInformationTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &TokenInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &TokenInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &TokenInformationLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwQueryInformationToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwSetInformationToken(
    IN  HANDLE                   TokenHandle             ,
    IN  TOKEN_INFORMATION_CLASS  TokenInformationClass   ,
    IN  PVOID                    TokenInformation        ,
    IN  ULONG                    TokenInformationLength  );

*/
void EmuApi::EmuZwSetInformationToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    TOKEN_INFORMATION_CLASS TokenInformationClass{};
    uc_reg_read(uc, UC_X86_REG_EDX, &TokenInformationClass);

    PVOID TokenInformation{};
    uc_reg_read(uc, UC_X86_REG_R8, &TokenInformation);

    ULONG TokenInformationLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &TokenInformationLength);


    NTSTATUS ZwSetInformationTokenResult = ZwSetInformationToken((HANDLE)TokenHandle,(TOKEN_INFORMATION_CLASS)TokenInformationClass,(PVOID)&TokenInformation,(ULONG)TokenInformationLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwSetInformationTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_EDX, &TokenInformationClass);
    uc_reg_write(uc, UC_X86_REG_R8, &TokenInformation);
    uc_reg_write(uc, UC_X86_REG_R9D, &TokenInformationLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwSetInformationToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAdjustPrivilegesToken(
    IN           HANDLE             TokenHandle           ,
    IN           BOOLEAN            DisableAllPrivileges  ,
    INOPTIONAL   PTOKEN_PRIVILEGES  NewState              ,
    INOPTIONAL   ULONG              BufferLength          ,
    OUT          PTOKEN_PRIVILEGES  PreviousState         ,
    OUTOPTIONAL  PULONG             ReturnLength          );

*/
void EmuApi::EmuZwAdjustPrivilegesToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    BOOLEAN DisableAllPrivileges{};
    uc_reg_read(uc, UC_X86_REG_DL, &DisableAllPrivileges);

    PTOKEN_PRIVILEGES NewState{};
    uc_reg_read(uc, UC_X86_REG_R8, &NewState);

    TOKEN_PRIVILEGES stNewState{};

    if(NewState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }

    ULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &BufferLength);

    PTOKEN_PRIVILEGES PreviousState{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    TOKEN_PRIVILEGES stPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwAdjustPrivilegesTokenResult = ZwAdjustPrivilegesToken((HANDLE)TokenHandle,(BOOLEAN)DisableAllPrivileges,(PTOKEN_PRIVILEGES)&stNewState,(ULONG)BufferLength,(PTOKEN_PRIVILEGES)&stPreviousState,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAdjustPrivilegesTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_DL, &DisableAllPrivileges);
    uc_reg_write(uc, UC_X86_REG_R8, &NewState);

    if(NewState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &BufferLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAdjustPrivilegesToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAdjustGroupsToken(
    IN          HANDLE         TokenHandle     ,
    IN          BOOLEAN        ResetToDefault  ,
    IN          PTOKEN_GROUPS  NewState        ,
    INOPTIONAL  ULONG          BufferLength    ,
    OUT         PTOKEN_GROUPS  PreviousState   ,
    OUT         PULONG         ReturnLength    );

*/
void EmuApi::EmuZwAdjustGroupsToken(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TokenHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TokenHandle);

    BOOLEAN ResetToDefault{};
    uc_reg_read(uc, UC_X86_REG_DL, &ResetToDefault);

    PTOKEN_GROUPS NewState{};
    uc_reg_read(uc, UC_X86_REG_R8, &NewState);

    TOKEN_GROUPS stNewState{};

    if(NewState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }

    ULONG BufferLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &BufferLength);

    PTOKEN_GROUPS PreviousState{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    TOKEN_GROUPS stPreviousState{};

    if(PreviousState != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }

    PULONG ReturnLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS ZwAdjustGroupsTokenResult = ZwAdjustGroupsToken((HANDLE)TokenHandle,(BOOLEAN)ResetToDefault,(PTOKEN_GROUPS)&stNewState,(ULONG)BufferLength,(PTOKEN_GROUPS)&stPreviousState,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAdjustGroupsTokenResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TokenHandle);
    uc_reg_write(uc, UC_X86_REG_DL, &ResetToDefault);
    uc_reg_write(uc, UC_X86_REG_R8, &NewState);

    if(NewState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewState, &stNewState, sizeof(stNewState));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &BufferLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &PreviousState, sizeof(PreviousState));

    if(PreviousState != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)PreviousState, &stPreviousState, sizeof(stPreviousState));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAdjustGroupsToken\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwPrivilegeCheck(
    IN     HANDLE          ClientToken         ,
    INOUT  PPRIVILEGE_SET  RequiredPrivileges  ,
    OUT    PBOOLEAN        Result              );

*/
void EmuApi::EmuZwPrivilegeCheck(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ClientToken);

    PPRIVILEGE_SET RequiredPrivileges{};
    uc_reg_read(uc, UC_X86_REG_RDX, &RequiredPrivileges);

    PRIVILEGE_SET stRequiredPrivileges{};

    if(RequiredPrivileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)RequiredPrivileges, &stRequiredPrivileges, sizeof(stRequiredPrivileges));
    }

    PBOOLEAN Result{};
    uc_reg_read(uc, UC_X86_REG_R8, &Result);

    BOOLEAN rlResult{};

    if(Result != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }


    NTSTATUS ZwPrivilegeCheckResult = ZwPrivilegeCheck((HANDLE)ClientToken,(PPRIVILEGE_SET)&stRequiredPrivileges,(PBOOLEAN)&rlResult);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwPrivilegeCheckResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_RDX, &RequiredPrivileges);

    if(RequiredPrivileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)RequiredPrivileges, &stRequiredPrivileges, sizeof(stRequiredPrivileges));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Result);

    if(Result != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwPrivilegeCheck\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheckAndAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName       ,
    INOPTIONAL  PVOID                 HandleId            ,
    IN          PUNICODE_STRING       ObjectTypeName      ,
    IN          PUNICODE_STRING       ObjectName          ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN          ACCESS_MASK           DesiredAccess       ,
    IN          PGENERIC_MAPPING      GenericMapping      ,
    IN          BOOLEAN               ObjectCreation      ,
    OUT         PACCESS_MASK          GrantedAccess       ,
    OUT         PNTSTATUS             AccessStatus        ,
    OUT         PBOOLEAN              GenerateOnClose     );

*/
void EmuApi::EmuZwAccessCheckAndAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in ZwAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in ZwAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &DesiredAccess, sizeof(DesiredAccess));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS ZwAccessCheckAndAuditAlarmResult = ZwAccessCheckAndAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(ACCESS_MASK)DesiredAccess,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckAndAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in ZwAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in ZwAccessCheckAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+64, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheckAndAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheckByTypeAndAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName         ,
    INOPTIONAL  PVOID                 HandleId              ,
    IN          PUNICODE_STRING       ObjectTypeName        ,
    IN          PUNICODE_STRING       ObjectName            ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          AUDIT_EVENT_TYPE      AuditType             ,
    IN          ULONG                 Flags                 ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    IN          BOOLEAN               ObjectCreation        ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          ,
    OUT         PBOOLEAN              GenerateOnClose       );

*/
void EmuApi::EmuZwAccessCheckByTypeAndAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in ZwAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in ZwAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    PSID PrincipalSelfSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));

    AUDIT_EVENT_TYPE AuditType{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));

    POBJECT_TYPE_LIST ObjectTypeList{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS ZwAccessCheckByTypeAndAuditAlarmResult = ZwAccessCheckByTypeAndAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(ACCESS_MASK)DesiredAccess,(AUDIT_EVENT_TYPE)AuditType,(ULONG)Flags,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckByTypeAndAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in ZwAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in ZwAccessCheckByTypeAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheckByTypeAndAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheckByTypeResultListAndAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName         ,
    INOPTIONAL  PVOID                 HandleId              ,
    IN          PUNICODE_STRING       ObjectTypeName        ,
    IN          PUNICODE_STRING       ObjectName            ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          AUDIT_EVENT_TYPE      AuditType             ,
    IN          ULONG                 Flags                 ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    IN          BOOLEAN               ObjectCreation        ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          ,
    OUT         PBOOLEAN              GenerateOnClose       );

*/
void EmuApi::EmuZwAccessCheckByTypeResultListAndAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in ZwAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in ZwAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    PSID PrincipalSelfSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));

    AUDIT_EVENT_TYPE AuditType{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));

    POBJECT_TYPE_LIST ObjectTypeList{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS ZwAccessCheckByTypeResultListAndAuditAlarmResult = ZwAccessCheckByTypeResultListAndAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(ACCESS_MASK)DesiredAccess,(AUDIT_EVENT_TYPE)AuditType,(ULONG)Flags,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckByTypeResultListAndAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in ZwAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in ZwAccessCheckByTypeResultListAndAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheckByTypeResultListAndAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
    IN          PUNICODE_STRING       SubsystemName         ,
    INOPTIONAL  PVOID                 HandleId              ,
    IN          HANDLE                ClientToken           ,
    IN          PUNICODE_STRING       ObjectTypeName        ,
    IN          PUNICODE_STRING       ObjectName            ,
    IN          PSECURITY_DESCRIPTOR  SecurityDescriptor    ,
    INOPTIONAL  PSID                  PrincipalSelfSid      ,
    IN          ACCESS_MASK           DesiredAccess         ,
    IN          AUDIT_EVENT_TYPE      AuditType             ,
    IN          ULONG                 Flags                 ,
    IN          POBJECT_TYPE_LIST     ObjectTypeList        ,
    IN          ULONG                 ObjectTypeListLength  ,
    IN          PGENERIC_MAPPING      GenericMapping        ,
    IN          BOOLEAN               ObjectCreation        ,
    OUT         PACCESS_MASK          GrantedAccess         ,
    OUT         PNTSTATUS             AccessStatus          ,
    OUT         PBOOLEAN              GenerateOnClose       );

*/
void EmuApi::EmuZwAccessCheckByTypeResultListAndAuditAlarmByHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in ZwAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ObjectName, sizeof(ObjectName));

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in ZwAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &SecurityDescriptor, sizeof(SecurityDescriptor));

    PSID PrincipalSelfSid{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &PrincipalSelfSid, sizeof(PrincipalSelfSid));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &DesiredAccess, sizeof(DesiredAccess));

    AUDIT_EVENT_TYPE AuditType{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &AuditType, sizeof(AuditType));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &Flags, sizeof(Flags));

    POBJECT_TYPE_LIST ObjectTypeList{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &ObjectTypeList, sizeof(ObjectTypeList));

    OBJECT_TYPE_LIST stObjectTypeList{};

    if(ObjectTypeList != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }

    ULONG ObjectTypeListLength{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &ObjectTypeListLength, sizeof(ObjectTypeListLength));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+104, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+112, &ObjectCreation, sizeof(ObjectCreation));

    PACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+120, &GrantedAccess, sizeof(GrantedAccess));

    ACCESS_MASK rlGrantedAccess{};

    if(GrantedAccess != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }

    PNTSTATUS AccessStatus{};
    uc_mem_read(uc, (DWORD_PTR)SP+128, &AccessStatus, sizeof(AccessStatus));

    NTSTATUS rlAccessStatus{};

    if(AccessStatus != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+136, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS ZwAccessCheckByTypeResultListAndAuditAlarmByHandleResult = ZwAccessCheckByTypeResultListAndAuditAlarmByHandle((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(HANDLE)ClientToken,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(PSID)&PrincipalSelfSid,(ACCESS_MASK)DesiredAccess,(AUDIT_EVENT_TYPE)AuditType,(ULONG)Flags,(POBJECT_TYPE_LIST)&stObjectTypeList,(ULONG)ObjectTypeListLength,(PGENERIC_MAPPING)&rlGenericMapping,(BOOLEAN)ObjectCreation,(PACCESS_MASK)&rlGrantedAccess,(PNTSTATUS)&rlAccessStatus,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwAccessCheckByTypeResultListAndAuditAlarmByHandleResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in ZwAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in ZwAccessCheckByTypeResultListAndAuditAlarmByHandle"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &PrincipalSelfSid, sizeof(PrincipalSelfSid));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &AuditType, sizeof(AuditType));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Flags, sizeof(Flags));
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectTypeList, sizeof(ObjectTypeList));

    if(ObjectTypeList != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectTypeList, &stObjectTypeList, sizeof(stObjectTypeList));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+88, &ObjectTypeListLength, sizeof(ObjectTypeListLength));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+104, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+112, &GrantedAccess, sizeof(GrantedAccess));

    if(GrantedAccess != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GrantedAccess, &rlGrantedAccess, sizeof(rlGrantedAccess));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+120, &AccessStatus, sizeof(AccessStatus));

    if(AccessStatus != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)AccessStatus, &rlAccessStatus, sizeof(rlAccessStatus));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+128, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwAccessCheckByTypeResultListAndAuditAlarmByHandle\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwOpenObjectAuditAlarm(
    IN          PUNICODE_STRING       SubsystemName       ,
    INOPTIONAL  PVOID                 HandleId            ,
    IN          PUNICODE_STRING       ObjectTypeName      ,
    IN          PUNICODE_STRING       ObjectName          ,
    INOPTIONAL  PSECURITY_DESCRIPTOR  SecurityDescriptor  ,
    IN          HANDLE                ClientToken         ,
    IN          ACCESS_MASK           DesiredAccess       ,
    IN          ACCESS_MASK           GrantedAccess       ,
    INOPTIONAL  PPRIVILEGE_SET        Privileges          ,
    IN          BOOLEAN               ObjectCreation      ,
    IN          BOOLEAN               AccessGranted       ,
    OUT         PBOOLEAN              GenerateOnClose     );

*/
void EmuApi::EmuZwOpenObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwOpenObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    PUNICODE_STRING ObjectTypeName{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectTypeName);

    std::wstring rlwObjectTypeName;

    USHORT rlLengthObjectTypeName;

    USHORT rlMaxLengthObjectTypeName;
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName, &rlLengthObjectTypeName, sizeof(rlLengthObjectTypeName));
    uc_mem_read(uc, (DWORD_PTR)ObjectTypeName+16, &rlMaxLengthObjectTypeName, sizeof(rlMaxLengthObjectTypeName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, rlwObjectTypeName, true, rlLengthObjectTypeName)) { printf("Error when read ObjectTypeName in ZwOpenObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectTypeName{};
    stObjectTypeName.Length = rlLengthObjectTypeName;
    stObjectTypeName.MaximumLength = rlMaxLengthObjectTypeName;
    stObjectTypeName.Buffer = rlwObjectTypeName.data();

    PUNICODE_STRING ObjectName{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectName);

    std::wstring rlwObjectName;

    USHORT rlLengthObjectName;

    USHORT rlMaxLengthObjectName;
    uc_mem_read(uc, (DWORD_PTR)ObjectName, &rlLengthObjectName, sizeof(rlLengthObjectName));
    uc_mem_read(uc, (DWORD_PTR)ObjectName+16, &rlMaxLengthObjectName, sizeof(rlMaxLengthObjectName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, rlwObjectName, true, rlLengthObjectName)) { printf("Error when read ObjectName in ZwOpenObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stObjectName{};
    stObjectName.Length = rlLengthObjectName;
    stObjectName.MaximumLength = rlMaxLengthObjectName;
    stObjectName.Buffer = rlwObjectName.data();

    PSECURITY_DESCRIPTOR SecurityDescriptor{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));

    HANDLE ClientToken{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &ClientToken, sizeof(ClientToken));

    ACCESS_MASK DesiredAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));

    ACCESS_MASK GrantedAccess{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &GrantedAccess, sizeof(GrantedAccess));

    PPRIVILEGE_SET Privileges{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    PRIVILEGE_SET stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    BOOLEAN ObjectCreation{};
    uc_mem_read(uc, (DWORD_PTR)SP+80, &ObjectCreation, sizeof(ObjectCreation));

    BOOLEAN AccessGranted{};
    uc_mem_read(uc, (DWORD_PTR)SP+88, &AccessGranted, sizeof(AccessGranted));

    PBOOLEAN GenerateOnClose{};
    uc_mem_read(uc, (DWORD_PTR)SP+96, &GenerateOnClose, sizeof(GenerateOnClose));

    BOOLEAN rlGenerateOnClose{};

    if(GenerateOnClose != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }


    NTSTATUS ZwOpenObjectAuditAlarmResult = ZwOpenObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(PUNICODE_STRING)&stObjectTypeName,(PUNICODE_STRING)&stObjectName,(PSECURITY_DESCRIPTOR)&SecurityDescriptor,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(ACCESS_MASK)GrantedAccess,(PPRIVILEGE_SET)&stPrivileges,(BOOLEAN)ObjectCreation,(BOOLEAN)AccessGranted,(PBOOLEAN)&rlGenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwOpenObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwOpenObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName, &stObjectTypeName.Length, sizeof(stObjectTypeName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectTypeName+16, &stObjectTypeName.MaximumLength, sizeof(stObjectTypeName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectTypeName+64, stObjectTypeName.Buffer, true, stObjectTypeName.Length)) { printf("Error when read ObjectTypeName in ZwOpenObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ObjectName, &stObjectName.Length, sizeof(stObjectName.Length));
    uc_mem_write(uc, (DWORD_PTR)ObjectName+16, &stObjectName.MaximumLength, sizeof(stObjectName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ObjectName+64, stObjectName.Buffer, true, stObjectName.Length)) { printf("Error when read ObjectName in ZwOpenObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &SecurityDescriptor, sizeof(SecurityDescriptor));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &ClientToken, sizeof(ClientToken));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &DesiredAccess, sizeof(DesiredAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &GrantedAccess, sizeof(GrantedAccess));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &Privileges, sizeof(Privileges));

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+80, &ObjectCreation, sizeof(ObjectCreation));
    uc_mem_write(uc, (DWORD_PTR)SP+88, &AccessGranted, sizeof(AccessGranted));
    uc_mem_write(uc, (DWORD_PTR)SP+96, &GenerateOnClose, sizeof(GenerateOnClose));

    if(GenerateOnClose != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenerateOnClose, &rlGenerateOnClose, sizeof(rlGenerateOnClose));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwOpenObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwPrivilegeObjectAuditAlarm(
    IN          PUNICODE_STRING  SubsystemName  ,
    INOPTIONAL  PVOID            HandleId       ,
    IN          HANDLE           ClientToken    ,
    IN          ACCESS_MASK      DesiredAccess  ,
    IN          PPRIVILEGE_SET   Privileges     ,
    IN          BOOLEAN          AccessGranted  );

*/
void EmuApi::EmuZwPrivilegeObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwPrivilegeObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    ACCESS_MASK DesiredAccess{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DesiredAccess);

    PPRIVILEGE_SET Privileges{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Privileges, sizeof(Privileges));

    PRIVILEGE_SET stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    BOOLEAN AccessGranted{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AccessGranted, sizeof(AccessGranted));


    NTSTATUS ZwPrivilegeObjectAuditAlarmResult = ZwPrivilegeObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(HANDLE)ClientToken,(ACCESS_MASK)DesiredAccess,(PPRIVILEGE_SET)&stPrivileges,(BOOLEAN)AccessGranted);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwPrivilegeObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwPrivilegeObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9D, &DesiredAccess);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Privileges, sizeof(Privileges));

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AccessGranted, sizeof(AccessGranted));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwPrivilegeObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwCloseObjectAuditAlarm(
    IN          PUNICODE_STRING  SubsystemName    ,
    INOPTIONAL  PVOID            HandleId         ,
    IN          BOOLEAN          GenerateOnClose  );

*/
void EmuApi::EmuZwCloseObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwCloseObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    BOOLEAN GenerateOnClose{};
    uc_reg_read(uc, UC_X86_REG_R8B, &GenerateOnClose);


    NTSTATUS ZwCloseObjectAuditAlarmResult = ZwCloseObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(BOOLEAN)GenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwCloseObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwCloseObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8B, &GenerateOnClose);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwCloseObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwDeleteObjectAuditAlarm(
    IN          PUNICODE_STRING  SubsystemName    ,
    INOPTIONAL  PVOID            HandleId         ,
    IN          BOOLEAN          GenerateOnClose  );

*/
void EmuApi::EmuZwDeleteObjectAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwDeleteObjectAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PVOID HandleId{};
    uc_reg_read(uc, UC_X86_REG_RDX, &HandleId);

    BOOLEAN GenerateOnClose{};
    uc_reg_read(uc, UC_X86_REG_R8B, &GenerateOnClose);


    NTSTATUS ZwDeleteObjectAuditAlarmResult = ZwDeleteObjectAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PVOID)&HandleId,(BOOLEAN)GenerateOnClose);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwDeleteObjectAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwDeleteObjectAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &HandleId);
    uc_reg_write(uc, UC_X86_REG_R8B, &GenerateOnClose);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwDeleteObjectAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwPrivilegedServiceAuditAlarm(
    IN  PUNICODE_STRING  SubsystemName  ,
    IN  PUNICODE_STRING  ServiceName    ,
    IN  HANDLE           ClientToken    ,
    IN  PPRIVILEGE_SET   Privileges     ,
    IN  BOOLEAN          AccessGranted  );

*/
void EmuApi::EmuZwPrivilegedServiceAuditAlarm(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING SubsystemName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &SubsystemName);

    std::wstring rlwSubsystemName;

    USHORT rlLengthSubsystemName;

    USHORT rlMaxLengthSubsystemName;
    uc_mem_read(uc, (DWORD_PTR)SubsystemName, &rlLengthSubsystemName, sizeof(rlLengthSubsystemName));
    uc_mem_read(uc, (DWORD_PTR)SubsystemName+16, &rlMaxLengthSubsystemName, sizeof(rlMaxLengthSubsystemName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, rlwSubsystemName, true, rlLengthSubsystemName)) { printf("Error when read SubsystemName in ZwPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stSubsystemName{};
    stSubsystemName.Length = rlLengthSubsystemName;
    stSubsystemName.MaximumLength = rlMaxLengthSubsystemName;
    stSubsystemName.Buffer = rlwSubsystemName.data();

    PUNICODE_STRING ServiceName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ServiceName);

    std::wstring rlwServiceName;

    USHORT rlLengthServiceName;

    USHORT rlMaxLengthServiceName;
    uc_mem_read(uc, (DWORD_PTR)ServiceName, &rlLengthServiceName, sizeof(rlLengthServiceName));
    uc_mem_read(uc, (DWORD_PTR)ServiceName+16, &rlMaxLengthServiceName, sizeof(rlMaxLengthServiceName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ServiceName+64, rlwServiceName, true, rlLengthServiceName)) { printf("Error when read ServiceName in ZwPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }

    UNICODE_STRING stServiceName{};
    stServiceName.Length = rlLengthServiceName;
    stServiceName.MaximumLength = rlMaxLengthServiceName;
    stServiceName.Buffer = rlwServiceName.data();

    HANDLE ClientToken{};
    uc_reg_read(uc, UC_X86_REG_R8, &ClientToken);

    PPRIVILEGE_SET Privileges{};
    uc_reg_read(uc, UC_X86_REG_R9, &Privileges);

    PRIVILEGE_SET stPrivileges{};

    if(Privileges != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }

    BOOLEAN AccessGranted{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &AccessGranted, sizeof(AccessGranted));


    NTSTATUS ZwPrivilegedServiceAuditAlarmResult = ZwPrivilegedServiceAuditAlarm((PUNICODE_STRING)&stSubsystemName,(PUNICODE_STRING)&stServiceName,(HANDLE)ClientToken,(PPRIVILEGE_SET)&stPrivileges,(BOOLEAN)AccessGranted);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwPrivilegedServiceAuditAlarmResult);
    uc_mem_write(uc, (DWORD_PTR)SubsystemName, &stSubsystemName.Length, sizeof(stSubsystemName.Length));
    uc_mem_write(uc, (DWORD_PTR)SubsystemName+16, &stSubsystemName.MaximumLength, sizeof(stSubsystemName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)SubsystemName+64, stSubsystemName.Buffer, true, stSubsystemName.Length)) { printf("Error when read SubsystemName in ZwPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)ServiceName, &stServiceName.Length, sizeof(stServiceName.Length));
    uc_mem_write(uc, (DWORD_PTR)ServiceName+16, &stServiceName.MaximumLength, sizeof(stServiceName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)ServiceName+64, stServiceName.Buffer, true, stServiceName.Length)) { printf("Error when read ServiceName in ZwPrivilegedServiceAuditAlarm"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &ClientToken);
    uc_reg_write(uc, UC_X86_REG_R9, &Privileges);

    if(Privileges != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Privileges, &stPrivileges, sizeof(stPrivileges));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &AccessGranted, sizeof(AccessGranted));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwPrivilegedServiceAuditAlarm\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwContinue(
    IN  PCONTEXT  ContextRecord  ,
    IN  BOOLEAN   TestAlert      );

*/
void EmuApi::EmuZwContinue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCONTEXT ContextRecord{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ContextRecord);

    CONTEXT stContextRecord{};

    if(ContextRecord != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }

    BOOLEAN TestAlert{};
    uc_reg_read(uc, UC_X86_REG_DL, &TestAlert);


    NTSTATUS ZwContinueResult = ZwContinue((PCONTEXT)&stContextRecord,(BOOLEAN)TestAlert);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwContinueResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ContextRecord);

    if(ContextRecord != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }
    uc_reg_write(uc, UC_X86_REG_DL, &TestAlert);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwContinue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
ZwRaiseException(
    IN  PEXCEPTION_RECORD  ExceptionRecord  ,
    IN  PCONTEXT           ContextRecord    ,
    IN  BOOLEAN            FirstChance      );

*/
void EmuApi::EmuZwRaiseException(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PEXCEPTION_RECORD ExceptionRecord{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ExceptionRecord);

    EXCEPTION_RECORD rlExceptionRecord{};

    if(ExceptionRecord != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ExceptionRecord, &rlExceptionRecord, sizeof(rlExceptionRecord));
    }

    PCONTEXT ContextRecord{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ContextRecord);

    CONTEXT stContextRecord{};

    if(ContextRecord != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }

    BOOLEAN FirstChance{};
    uc_reg_read(uc, UC_X86_REG_R8B, &FirstChance);


    NTSTATUS ZwRaiseExceptionResult = ZwRaiseException((PEXCEPTION_RECORD)&rlExceptionRecord,(PCONTEXT)&stContextRecord,(BOOLEAN)FirstChance);


    uc_reg_write(uc, UC_X86_REG_EAX, &ZwRaiseExceptionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ExceptionRecord);

    if(ExceptionRecord != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ExceptionRecord, &rlExceptionRecord, sizeof(rlExceptionRecord));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &ContextRecord);

    if(ContextRecord != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ContextRecord, &stContextRecord, sizeof(stContextRecord));
    }
    uc_reg_write(uc, UC_X86_REG_R8B, &FirstChance);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuZwRaiseException\n";
    #endif

    return;
}


/*
ULONG
__cdecl
DbgPrint(
    IN  PCH  Format  );

*/
void EmuApi::EmuDbgPrint(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PCH Format{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Format);

    std::string rlaFormat;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in DbgPrint"); _CrtDbgBreak(); }


    ULONG DbgPrintResult = DbgPrint((PCH)rlaFormat.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &DbgPrintResult);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)Format, rlaFormat)) { printf("Error when read Format in DbgPrint"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuDbgPrint\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlCheckBit(
      PRTL_BITMAP  BitMapHeader  ,
      ULONG        BitPosition   );

*/
void EmuApi::EmuRtlCheckBit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_BITMAP BitMapHeader{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BitMapHeader);

    RTL_BITMAP rlBitMapHeader{};

    if(BitMapHeader != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }

    ULONG BitPosition{};
    uc_reg_read(uc, UC_X86_REG_EDX, &BitPosition);


    BOOLEAN RtlCheckBitResult = RtlCheckBit((PRTL_BITMAP)&rlBitMapHeader,(ULONG)BitPosition);


    uc_reg_write(uc, UC_X86_REG_AL, &RtlCheckBitResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BitMapHeader);

    if(BitMapHeader != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BitMapHeader, &rlBitMapHeader, sizeof(rlBitMapHeader));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &BitPosition);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCheckBit\n";
    #endif

    return;
}


/*
RTL_PATH_TYPE
__cdecl
RtlDetermineDosPathNameType_U(
    IN  PCWSTR  DosFileName  );

*/
void EmuApi::EmuRtlDetermineDosPathNameType_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR DosFileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DosFileName);

    std::wstring rlwDosFileName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DosFileName, rlwDosFileName)) { printf("Error when read DosFileName in RtlDetermineDosPathNameType_U"); _CrtDbgBreak(); }


    RTL_PATH_TYPE RtlDetermineDosPathNameType_UResult = RtlDetermineDosPathNameType_U((PCWSTR)rlwDosFileName.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDetermineDosPathNameType_UResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DosFileName, rlwDosFileName)) { printf("Error when read DosFileName in RtlDetermineDosPathNameType_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDetermineDosPathNameType_U\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlEnterCriticalSection(
      PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlEnterCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    NTSTATUS RtlEnterCriticalSectionResult = RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlEnterCriticalSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEnterCriticalSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlLeaveCriticalSection(
      PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlLeaveCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    NTSTATUS RtlLeaveCriticalSectionResult = RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlLeaveCriticalSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlLeaveCriticalSection\n";
    #endif

    return;
}


/*
LOGICAL
__cdecl
RtlIsCriticalSectionLocked(
    IN  PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlIsCriticalSectionLocked(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    LOGICAL RtlIsCriticalSectionLockedResult = RtlIsCriticalSectionLocked((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIsCriticalSectionLockedResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsCriticalSectionLocked\n";
    #endif

    return;
}


/*
LOGICAL
__cdecl
RtlIsCriticalSectionLockedByThread(
    IN  PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlIsCriticalSectionLockedByThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    LOGICAL RtlIsCriticalSectionLockedByThreadResult = RtlIsCriticalSectionLockedByThread((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlIsCriticalSectionLockedByThreadResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsCriticalSectionLockedByThread\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlGetCriticalSectionRecursionCount(
    IN  PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlGetCriticalSectionRecursionCount(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    ULONG RtlGetCriticalSectionRecursionCountResult = RtlGetCriticalSectionRecursionCount((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetCriticalSectionRecursionCountResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCriticalSectionRecursionCount\n";
    #endif

    return;
}


/*
LOGICAL
__cdecl
RtlTryEnterCriticalSection(
      PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlTryEnterCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    LOGICAL RtlTryEnterCriticalSectionResult = RtlTryEnterCriticalSection((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlTryEnterCriticalSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlTryEnterCriticalSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlInitializeCriticalSection(
      PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlInitializeCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    NTSTATUS RtlInitializeCriticalSectionResult = RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlInitializeCriticalSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeCriticalSection\n";
    #endif

    return;
}

/*
NTSTATUS
__cdecl
RtlInitializeCriticalSectionAndSpinCount(
      PRTL_CRITICAL_SECTION  CriticalSection  ,
      ULONG                  SpinCount        );

*/
void EmuApi::EmuRtlInitializeCriticalSectionAndSpinCount(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }

    ULONG SpinCount{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SpinCount);


    NTSTATUS RtlInitializeCriticalSectionAndSpinCountResult = RtlInitializeCriticalSectionAndSpinCount((PRTL_CRITICAL_SECTION)&stCriticalSection,(ULONG)SpinCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlInitializeCriticalSectionAndSpinCountResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &SpinCount);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlInitializeCriticalSectionAndSpinCount\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlSetCriticalSectionSpinCount(
      PRTL_CRITICAL_SECTION  CriticalSection  ,
      ULONG                  SpinCount        );

*/
void EmuApi::EmuRtlSetCriticalSectionSpinCount(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }

    ULONG SpinCount{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SpinCount);


    ULONG RtlSetCriticalSectionSpinCountResult = RtlSetCriticalSectionSpinCount((PRTL_CRITICAL_SECTION)&stCriticalSection,(ULONG)SpinCount);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetCriticalSectionSpinCountResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    uc_reg_write(uc, UC_X86_REG_EDX, &SpinCount);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetCriticalSectionSpinCount\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteCriticalSection(
      PRTL_CRITICAL_SECTION  CriticalSection  );

*/
void EmuApi::EmuRtlDeleteCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_CRITICAL_SECTION CriticalSection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

    RTL_CRITICAL_SECTION stCriticalSection{};

    if(CriticalSection != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }


    NTSTATUS RtlDeleteCriticalSectionResult = RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)&stCriticalSection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteCriticalSectionResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &CriticalSection);

    if(CriticalSection != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)CriticalSection, &stCriticalSection, sizeof(stCriticalSection));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteCriticalSection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrDisableThreadCalloutsForDll(
    IN  PVOID  DllHandle  );

*/
void EmuApi::EmuLdrDisableThreadCalloutsForDll(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllHandle);


    NTSTATUS LdrDisableThreadCalloutsForDllResult = LdrDisableThreadCalloutsForDll((PVOID)&DllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrDisableThreadCalloutsForDllResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DllHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrDisableThreadCalloutsForDll\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrLoadDll(
    INOPTIONAL  PWSTR            DllPath             ,
    INOPTIONAL  PULONG           DllCharacteristics  ,
    IN          PUNICODE_STRING  DllName             ,
    OUT         PVOID *          DllHandle           );

*/
void EmuApi::EmuLdrLoadDll(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR DllPath{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllPath);

    std::wstring rlwDllPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllPath, rlwDllPath)) { printf("Error when read DllPath in LdrLoadDll"); _CrtDbgBreak(); }

    PULONG DllCharacteristics{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DllCharacteristics);

    ULONG rlDllCharacteristics{};

    if(DllCharacteristics != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllCharacteristics, &rlDllCharacteristics, sizeof(rlDllCharacteristics));
    }

    PUNICODE_STRING DllName{};
    uc_reg_read(uc, UC_X86_REG_R8, &DllName);

    std::wstring rlwDllName;

    USHORT rlLengthDllName;

    USHORT rlMaxLengthDllName;
    uc_mem_read(uc, (DWORD_PTR)DllName, &rlLengthDllName, sizeof(rlLengthDllName));
    uc_mem_read(uc, (DWORD_PTR)DllName+16, &rlMaxLengthDllName, sizeof(rlMaxLengthDllName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllName+64, rlwDllName, true, rlLengthDllName)) { printf("Error when read DllName in LdrLoadDll"); _CrtDbgBreak(); }

    UNICODE_STRING stDllName{};
    stDllName.Length = rlLengthDllName;
    stDllName.MaximumLength = rlMaxLengthDllName;
    stDllName.Buffer = rlwDllName.data();

    PVOID * DllHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &DllHandle);

    PVOID * dpDllHandle{};

    if(DllHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }


    NTSTATUS LdrLoadDllResult = LdrLoadDll((PWSTR)rlwDllPath.data(),(PULONG)&rlDllCharacteristics,(PUNICODE_STRING)&stDllName,(PVOID *)&dpDllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrLoadDllResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllPath, rlwDllPath)) { printf("Error when read DllPath in LdrLoadDll"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &DllCharacteristics);

    if(DllCharacteristics != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllCharacteristics, &rlDllCharacteristics, sizeof(rlDllCharacteristics));
    }
    uc_mem_write(uc, (DWORD_PTR)DllName, &stDllName.Length, sizeof(stDllName.Length));
    uc_mem_write(uc, (DWORD_PTR)DllName+16, &stDllName.MaximumLength, sizeof(stDllName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllName+64, stDllName.Buffer, true, stDllName.Length)) { printf("Error when read DllName in LdrLoadDll"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &DllHandle);

    if(DllHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrLoadDll\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrUnloadDll(
    IN  PVOID  DllHandle  );

*/
void EmuApi::EmuLdrUnloadDll(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllHandle);


    NTSTATUS LdrUnloadDllResult = LdrUnloadDll((PVOID)&DllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrUnloadDllResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DllHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrUnloadDll\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrGetDllHandle(
    INOPTIONAL  PWSTR            DllPath             ,
    INOPTIONAL  PULONG           DllCharacteristics  ,
    IN          PUNICODE_STRING  DllName             ,
    OUT         PVOID *          DllHandle           );

*/
void EmuApi::EmuLdrGetDllHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR DllPath{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllPath);

    std::wstring rlwDllPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllPath, rlwDllPath)) { printf("Error when read DllPath in LdrGetDllHandle"); _CrtDbgBreak(); }

    PULONG DllCharacteristics{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DllCharacteristics);

    ULONG rlDllCharacteristics{};

    if(DllCharacteristics != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllCharacteristics, &rlDllCharacteristics, sizeof(rlDllCharacteristics));
    }

    PUNICODE_STRING DllName{};
    uc_reg_read(uc, UC_X86_REG_R8, &DllName);

    std::wstring rlwDllName;

    USHORT rlLengthDllName;

    USHORT rlMaxLengthDllName;
    uc_mem_read(uc, (DWORD_PTR)DllName, &rlLengthDllName, sizeof(rlLengthDllName));
    uc_mem_read(uc, (DWORD_PTR)DllName+16, &rlMaxLengthDllName, sizeof(rlMaxLengthDllName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllName+64, rlwDllName, true, rlLengthDllName)) { printf("Error when read DllName in LdrGetDllHandle"); _CrtDbgBreak(); }

    UNICODE_STRING stDllName{};
    stDllName.Length = rlLengthDllName;
    stDllName.MaximumLength = rlMaxLengthDllName;
    stDllName.Buffer = rlwDllName.data();

    PVOID * DllHandle{};
    uc_reg_read(uc, UC_X86_REG_R9, &DllHandle);

    PVOID * dpDllHandle{};

    if(DllHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }


    NTSTATUS LdrGetDllHandleResult = LdrGetDllHandle((PWSTR)rlwDllPath.data(),(PULONG)&rlDllCharacteristics,(PUNICODE_STRING)&stDllName,(PVOID *)&dpDllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrGetDllHandleResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllPath, rlwDllPath)) { printf("Error when read DllPath in LdrGetDllHandle"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_RDX, &DllCharacteristics);

    if(DllCharacteristics != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllCharacteristics, &rlDllCharacteristics, sizeof(rlDllCharacteristics));
    }
    uc_mem_write(uc, (DWORD_PTR)DllName, &stDllName.Length, sizeof(stDllName.Length));
    uc_mem_write(uc, (DWORD_PTR)DllName+16, &stDllName.MaximumLength, sizeof(stDllName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllName+64, stDllName.Buffer, true, stDllName.Length)) { printf("Error when read DllName in LdrGetDllHandle"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &DllHandle);

    if(DllHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrGetDllHandle\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrGetDllHandleEx(
    IN           ULONG            Flags               ,
    INOPTIONAL   PCWSTR           DllPath             ,
    INOPTIONAL   PULONG           DllCharacteristics  ,
    IN           PUNICODE_STRING  DllName             ,
    OUTOPTIONAL  PVOID *          DllHandle           );

*/
void EmuApi::EmuLdrGetDllHandleEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PWSTR DllPath{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DllPath);

    std::wstring rlwDllPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllPath, rlwDllPath)) { printf("Error when read DllPath in LdrGetDllHandleEx"); _CrtDbgBreak(); }

    PULONG DllCharacteristics{};
    uc_reg_read(uc, UC_X86_REG_R8, &DllCharacteristics);

    ULONG rlDllCharacteristics{};

    if(DllCharacteristics != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllCharacteristics, &rlDllCharacteristics, sizeof(rlDllCharacteristics));
    }

    PUNICODE_STRING DllName{};
    uc_reg_read(uc, UC_X86_REG_R9, &DllName);

    std::wstring rlwDllName;

    USHORT rlLengthDllName;

    USHORT rlMaxLengthDllName;
    uc_mem_read(uc, (DWORD_PTR)DllName, &rlLengthDllName, sizeof(rlLengthDllName));
    uc_mem_read(uc, (DWORD_PTR)DllName+16, &rlMaxLengthDllName, sizeof(rlMaxLengthDllName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DllName+64, rlwDllName, true, rlLengthDllName)) { printf("Error when read DllName in LdrGetDllHandleEx"); _CrtDbgBreak(); }

    UNICODE_STRING stDllName{};
    stDllName.Length = rlLengthDllName;
    stDllName.MaximumLength = rlMaxLengthDllName;
    stDllName.Buffer = rlwDllName.data();

    PVOID * DllHandle{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &DllHandle, sizeof(DllHandle));

    PVOID * dpDllHandle{};

    if(DllHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }


    NTSTATUS LdrGetDllHandleExResult = LdrGetDllHandleEx((ULONG)Flags,(PWSTR)rlwDllPath.data(),(PULONG)&rlDllCharacteristics,(PUNICODE_STRING)&stDllName,(PVOID *)&dpDllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrGetDllHandleExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllPath, rlwDllPath)) { printf("Error when read DllPath in LdrGetDllHandleEx"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &DllCharacteristics);

    if(DllCharacteristics != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllCharacteristics, &rlDllCharacteristics, sizeof(rlDllCharacteristics));
    }
    uc_mem_write(uc, (DWORD_PTR)DllName, &stDllName.Length, sizeof(stDllName.Length));
    uc_mem_write(uc, (DWORD_PTR)DllName+16, &stDllName.MaximumLength, sizeof(stDllName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DllName+64, stDllName.Buffer, true, stDllName.Length)) { printf("Error when read DllName in LdrGetDllHandleEx"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &DllHandle, sizeof(DllHandle));

    if(DllHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrGetDllHandleEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrGetDllHandleByMapping(
    IN   PVOID    Base       ,
    OUT  PVOID *  DllHandle  );

*/
void EmuApi::EmuLdrGetDllHandleByMapping(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Base{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Base);

    PVOID * DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DllHandle);

    PVOID * dpDllHandle{};

    if(DllHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }


    NTSTATUS LdrGetDllHandleByMappingResult = LdrGetDllHandleByMapping((PVOID)&Base,(PVOID *)&dpDllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrGetDllHandleByMappingResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Base);
    uc_reg_write(uc, UC_X86_REG_RDX, &DllHandle);

    if(DllHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrGetDllHandleByMapping\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrGetDllHandleByName(
    INOPTIONAL  PUNICODE_STRING  BaseDllName  ,
    INOPTIONAL  PUNICODE_STRING  FullDllName  ,
    OUT         PVOID *          DllHandle    );

*/
void EmuApi::EmuLdrGetDllHandleByName(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING BaseDllName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BaseDllName);

    std::wstring rlwBaseDllName;

    USHORT rlLengthBaseDllName;

    USHORT rlMaxLengthBaseDllName;
    uc_mem_read(uc, (DWORD_PTR)BaseDllName, &rlLengthBaseDllName, sizeof(rlLengthBaseDllName));
    uc_mem_read(uc, (DWORD_PTR)BaseDllName+16, &rlMaxLengthBaseDllName, sizeof(rlMaxLengthBaseDllName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)BaseDllName+64, rlwBaseDllName, true, rlLengthBaseDllName)) { printf("Error when read BaseDllName in LdrGetDllHandleByName"); _CrtDbgBreak(); }

    UNICODE_STRING stBaseDllName{};
    stBaseDllName.Length = rlLengthBaseDllName;
    stBaseDllName.MaximumLength = rlMaxLengthBaseDllName;
    stBaseDllName.Buffer = rlwBaseDllName.data();

    PUNICODE_STRING FullDllName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &FullDllName);

    std::wstring rlwFullDllName;

    USHORT rlLengthFullDllName;

    USHORT rlMaxLengthFullDllName;
    uc_mem_read(uc, (DWORD_PTR)FullDllName, &rlLengthFullDllName, sizeof(rlLengthFullDllName));
    uc_mem_read(uc, (DWORD_PTR)FullDllName+16, &rlMaxLengthFullDllName, sizeof(rlMaxLengthFullDllName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)FullDllName+64, rlwFullDllName, true, rlLengthFullDllName)) { printf("Error when read FullDllName in LdrGetDllHandleByName"); _CrtDbgBreak(); }

    UNICODE_STRING stFullDllName{};
    stFullDllName.Length = rlLengthFullDllName;
    stFullDllName.MaximumLength = rlMaxLengthFullDllName;
    stFullDllName.Buffer = rlwFullDllName.data();

    PVOID * DllHandle{};
    uc_reg_read(uc, UC_X86_REG_R8, &DllHandle);

    PVOID * dpDllHandle{};

    if(DllHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }


    NTSTATUS LdrGetDllHandleByNameResult = LdrGetDllHandleByName((PUNICODE_STRING)&stBaseDllName,(PUNICODE_STRING)&stFullDllName,(PVOID *)&dpDllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrGetDllHandleByNameResult);
    uc_mem_write(uc, (DWORD_PTR)BaseDllName, &stBaseDllName.Length, sizeof(stBaseDllName.Length));
    uc_mem_write(uc, (DWORD_PTR)BaseDllName+16, &stBaseDllName.MaximumLength, sizeof(stBaseDllName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)BaseDllName+64, stBaseDllName.Buffer, true, stBaseDllName.Length)) { printf("Error when read BaseDllName in LdrGetDllHandleByName"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)FullDllName, &stFullDllName.Length, sizeof(stFullDllName.Length));
    uc_mem_write(uc, (DWORD_PTR)FullDllName+16, &stFullDllName.MaximumLength, sizeof(stFullDllName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)FullDllName+64, stFullDllName.Buffer, true, stFullDllName.Length)) { printf("Error when read FullDllName in LdrGetDllHandleByName"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8, &DllHandle);

    if(DllHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)DllHandle, &dpDllHandle, sizeof(dpDllHandle));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrGetDllHandleByName\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrAddRefDll(
    IN  ULONG  Flags      ,
    IN  PVOID  DllHandle  );

*/
void EmuApi::EmuLdrAddRefDll(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &DllHandle);


    NTSTATUS LdrAddRefDllResult = LdrAddRefDll((ULONG)Flags,(PVOID)&DllHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrAddRefDllResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_reg_write(uc, UC_X86_REG_RDX, &DllHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrAddRefDll\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrGetProcedureAddress(
    IN          PVOID         DllHandle         ,
    INOPTIONAL  PANSI_STRING  ProcedureName     ,
    INOPTIONAL  ULONG         ProcedureNumber   ,
    OUT         PVOID *       ProcedureAddress  );

*/
void EmuApi::EmuLdrGetProcedureAddress(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllHandle);

    PANSI_STRING ProcedureName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcedureName);

    STRING rlProcedureName{};

    if(ProcedureName != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcedureName, &rlProcedureName, sizeof(rlProcedureName));
    }

    ULONG ProcedureNumber{};
    uc_reg_read(uc, UC_X86_REG_R8D, &ProcedureNumber);

    PVOID * ProcedureAddress{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProcedureAddress);

    PVOID * dpProcedureAddress{};

    if(ProcedureAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcedureAddress, &dpProcedureAddress, sizeof(dpProcedureAddress));
    }


    NTSTATUS LdrGetProcedureAddressResult = LdrGetProcedureAddress((PVOID)&DllHandle,(PANSI_STRING)&rlProcedureName,(ULONG)ProcedureNumber,(PVOID *)&dpProcedureAddress);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrGetProcedureAddressResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DllHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcedureName);

    if(ProcedureName != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcedureName, &rlProcedureName, sizeof(rlProcedureName));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &ProcedureNumber);
    uc_reg_write(uc, UC_X86_REG_R9, &ProcedureAddress);

    if(ProcedureAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcedureAddress, &dpProcedureAddress, sizeof(dpProcedureAddress));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrGetProcedureAddress\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrGetProcedureAddressEx(
    IN          PVOID         DllHandle         ,
    INOPTIONAL  PANSI_STRING  ProcedureName     ,
    INOPTIONAL  ULONG         ProcedureNumber   ,
    OUT         PVOID *       ProcedureAddress  ,
    IN          ULONG         Flags             );

*/
void EmuApi::EmuLdrGetProcedureAddressEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllHandle);

    PANSI_STRING ProcedureName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcedureName);

    STRING rlProcedureName{};

    if(ProcedureName != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcedureName, &rlProcedureName, sizeof(rlProcedureName));
    }

    ULONG ProcedureNumber{};
    uc_reg_read(uc, UC_X86_REG_R8D, &ProcedureNumber);

    PVOID * ProcedureAddress{};
    uc_reg_read(uc, UC_X86_REG_R9, &ProcedureAddress);

    PVOID * dpProcedureAddress{};

    if(ProcedureAddress != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcedureAddress, &dpProcedureAddress, sizeof(dpProcedureAddress));
    }

    ULONG Flags{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));


    NTSTATUS LdrGetProcedureAddressExResult = LdrGetProcedureAddressEx((PVOID)&DllHandle,(PANSI_STRING)&rlProcedureName,(ULONG)ProcedureNumber,(PVOID *)&dpProcedureAddress,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrGetProcedureAddressExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DllHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcedureName);

    if(ProcedureName != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcedureName, &rlProcedureName, sizeof(rlProcedureName));
    }
    uc_reg_write(uc, UC_X86_REG_R8D, &ProcedureNumber);
    uc_reg_write(uc, UC_X86_REG_R9, &ProcedureAddress);

    if(ProcedureAddress != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcedureAddress, &dpProcedureAddress, sizeof(dpProcedureAddress));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Flags, sizeof(Flags));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrGetProcedureAddressEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrLockLoaderLock(
    IN           ULONG    Flags        ,
    OUTOPTIONAL  ULONG *  Disposition  ,
    OUT          PVOID *  Cookie       );

*/
void EmuApi::EmuLdrLockLoaderLock(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PULONG Disposition{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Disposition);

    ULONG rlDisposition{};

    if(Disposition != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Disposition, &rlDisposition, sizeof(rlDisposition));
    }

    PVOID * Cookie{};
    uc_reg_read(uc, UC_X86_REG_R8, &Cookie);

    PVOID * dpCookie{};

    if(Cookie != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Cookie, &dpCookie, sizeof(dpCookie));
    }


    NTSTATUS LdrLockLoaderLockResult = LdrLockLoaderLock((ULONG)Flags,(ULONG *)&rlDisposition,(PVOID *)&dpCookie);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrLockLoaderLockResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_reg_write(uc, UC_X86_REG_RDX, &Disposition);

    if(Disposition != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Disposition, &rlDisposition, sizeof(rlDisposition));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Cookie);

    if(Cookie != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Cookie, &dpCookie, sizeof(dpCookie));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrLockLoaderLock\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrRelocateImage(
    IN  PVOID     NewBase     ,
    IN  PSTR      LoaderName  ,
    IN  NTSTATUS  Success     ,
    IN  NTSTATUS  Conflict    ,
    IN  NTSTATUS  Invalid     );

*/
void EmuApi::EmuLdrRelocateImage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID NewBase{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NewBase);

    PSTR LoaderName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &LoaderName);

    std::string rlaLoaderName;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)LoaderName, rlaLoaderName)) { printf("Error when read LoaderName in LdrRelocateImage"); _CrtDbgBreak(); }

    NTSTATUS Success{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Success);

    NTSTATUS Conflict{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Conflict);

    NTSTATUS Invalid{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Invalid, sizeof(Invalid));


    NTSTATUS LdrRelocateImageResult = LdrRelocateImage((PVOID)&NewBase,(PSTR)rlaLoaderName.data(),(NTSTATUS)Success,(NTSTATUS)Conflict,(NTSTATUS)Invalid);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrRelocateImageResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NewBase);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)LoaderName, rlaLoaderName)) { printf("Error when read LoaderName in LdrRelocateImage"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &Success);
    uc_reg_write(uc, UC_X86_REG_R9D, &Conflict);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Invalid, sizeof(Invalid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrRelocateImage\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrRelocateImageWithBias(
    IN  PVOID     NewBase     ,
    IN  LONGLONG  Bias        ,
    IN  PSTR      LoaderName  ,
    IN  NTSTATUS  Success     ,
    IN  NTSTATUS  Conflict    ,
    IN  NTSTATUS  Invalid     );

*/
void EmuApi::EmuLdrRelocateImageWithBias(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID NewBase{};
    uc_reg_read(uc, UC_X86_REG_RCX, &NewBase);

    LONGLONG Bias{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Bias);

    PSTR LoaderName{};
    uc_reg_read(uc, UC_X86_REG_R8, &LoaderName);

    std::string rlaLoaderName;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)LoaderName, rlaLoaderName)) { printf("Error when read LoaderName in LdrRelocateImageWithBias"); _CrtDbgBreak(); }

    NTSTATUS Success{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Success);

    NTSTATUS Conflict{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Conflict, sizeof(Conflict));

    NTSTATUS Invalid{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Invalid, sizeof(Invalid));


    NTSTATUS LdrRelocateImageWithBiasResult = LdrRelocateImageWithBias((PVOID)&NewBase,(LONGLONG)Bias,(PSTR)rlaLoaderName.data(),(NTSTATUS)Success,(NTSTATUS)Conflict,(NTSTATUS)Invalid);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrRelocateImageWithBiasResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &NewBase);
    uc_reg_write(uc, UC_X86_REG_RDX, &Bias);
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)LoaderName, rlaLoaderName)) { printf("Error when read LoaderName in LdrRelocateImageWithBias"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9D, &Success);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Conflict, sizeof(Conflict));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Invalid, sizeof(Invalid));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrRelocateImageWithBias\n";
    #endif

    return;
}


/*
PIMAGE_BASE_RELOCATION
__cdecl
LdrProcessRelocationBlock(
    IN  ULONG_PTR  VA           ,
    IN  ULONG      SizeOfBlock  ,
    IN  PUSHORT    NextOffset   ,
    IN  LONG_PTR   Diff         );

*/
void EmuApi::EmuLdrProcessRelocationBlock(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG_PTR VA{};
    uc_reg_read(uc, UC_X86_REG_RCX, &VA);

    ULONG SizeOfBlock{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SizeOfBlock);

    PUSHORT NextOffset{};
    uc_reg_read(uc, UC_X86_REG_R8, &NextOffset);

    USHORT rlNextOffset{};

    if(NextOffset != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NextOffset, &rlNextOffset, sizeof(rlNextOffset));
    }

    LONG_PTR Diff{};
    uc_reg_read(uc, UC_X86_REG_R9, &Diff);


    PIMAGE_BASE_RELOCATION LdrProcessRelocationBlockResult = LdrProcessRelocationBlock((ULONG_PTR)VA,(ULONG)SizeOfBlock,(PUSHORT)&rlNextOffset,(LONG_PTR)Diff);


    uc_reg_write(uc, UC_X86_REG_RAX, &LdrProcessRelocationBlockResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &VA);
    uc_reg_write(uc, UC_X86_REG_EDX, &SizeOfBlock);
    uc_reg_write(uc, UC_X86_REG_R8, &NextOffset);

    if(NextOffset != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NextOffset, &rlNextOffset, sizeof(rlNextOffset));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &Diff);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrProcessRelocationBlock\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
LdrVerifyMappedImageMatchesChecksum(
    IN  PVOID   BaseAddress    ,
    IN  SIZE_T  NumberOfBytes  ,
    IN  ULONG   FileLength     );

*/
void EmuApi::EmuLdrVerifyMappedImageMatchesChecksum(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID BaseAddress{};
    uc_reg_read(uc, UC_X86_REG_RCX, &BaseAddress);

    SIZE_T NumberOfBytes{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NumberOfBytes);

    ULONG FileLength{};
    uc_reg_read(uc, UC_X86_REG_R8D, &FileLength);


    BOOLEAN LdrVerifyMappedImageMatchesChecksumResult = LdrVerifyMappedImageMatchesChecksum((PVOID)&BaseAddress,(SIZE_T)NumberOfBytes,(ULONG)FileLength);


    uc_reg_write(uc, UC_X86_REG_AL, &LdrVerifyMappedImageMatchesChecksumResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &BaseAddress);
    uc_reg_write(uc, UC_X86_REG_RDX, &NumberOfBytes);
    uc_reg_write(uc, UC_X86_REG_R8D, &FileLength);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrVerifyMappedImageMatchesChecksum\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrQueryModuleServiceTags(
    IN     PVOID   DllHandle         ,
    OUT    PULONG  ServiceTagBuffer  ,
    INOUT  PULONG  BufferSize        );

*/
void EmuApi::EmuLdrQueryModuleServiceTags(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID DllHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DllHandle);

    PULONG ServiceTagBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ServiceTagBuffer);

    ULONG rlServiceTagBuffer{};

    if(ServiceTagBuffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ServiceTagBuffer, &rlServiceTagBuffer, sizeof(rlServiceTagBuffer));
    }

    PULONG BufferSize{};
    uc_reg_read(uc, UC_X86_REG_R8, &BufferSize);

    ULONG rlBufferSize{};

    if(BufferSize != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)BufferSize, &rlBufferSize, sizeof(rlBufferSize));
    }


    NTSTATUS LdrQueryModuleServiceTagsResult = LdrQueryModuleServiceTags((PVOID)&DllHandle,(PULONG)&rlServiceTagBuffer,(PULONG)&rlBufferSize);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrQueryModuleServiceTagsResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &DllHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &ServiceTagBuffer);

    if(ServiceTagBuffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ServiceTagBuffer, &rlServiceTagBuffer, sizeof(rlServiceTagBuffer));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &BufferSize);

    if(BufferSize != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)BufferSize, &rlBufferSize, sizeof(rlBufferSize));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrQueryModuleServiceTags\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrRegisterDllNotification(
    IN   ULONG                           Flags                 ,
    IN   PLDR_DLL_NOTIFICATION_FUNCTION  NotificationFunction  ,
    IN   PVOID                           Context               ,
    OUT  PVOID *                         Cookie                );

*/
void EmuApi::EmuLdrRegisterDllNotification(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &Flags);

    PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NotificationFunction);

    PVOID Context{};
    uc_reg_read(uc, UC_X86_REG_R8, &Context);

    PVOID * Cookie{};
    uc_reg_read(uc, UC_X86_REG_R9, &Cookie);

    PVOID * dpCookie{};

    if(Cookie != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Cookie, &dpCookie, sizeof(dpCookie));
    }


    NTSTATUS LdrRegisterDllNotificationResult = LdrRegisterDllNotification((ULONG)Flags,(PLDR_DLL_NOTIFICATION_FUNCTION)NotificationFunction,(PVOID)&Context,(PVOID *)&dpCookie);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrRegisterDllNotificationResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &Flags);
    uc_reg_write(uc, UC_X86_REG_RDX, &NotificationFunction);
    uc_reg_write(uc, UC_X86_REG_R8, &Context);
    uc_reg_write(uc, UC_X86_REG_R9, &Cookie);

    if(Cookie != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Cookie, &dpCookie, sizeof(dpCookie));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrRegisterDllNotification\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
LdrUnregisterDllNotification(
    IN  PVOID  Cookie  );

*/
void EmuApi::EmuLdrUnregisterDllNotification(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Cookie{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Cookie);


    NTSTATUS LdrUnregisterDllNotificationResult = LdrUnregisterDllNotification((PVOID)&Cookie);


    uc_reg_write(uc, UC_X86_REG_EAX, &LdrUnregisterDllNotificationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Cookie);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrUnregisterDllNotification\n";
    #endif

    return;
}


/*
HANDLE
__cdecl
CsrGetProcessId(VOID);

*/
void EmuApi::EmuCsrGetProcessId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    HANDLE CsrGetProcessIdResult = CsrGetProcessId();


    uc_reg_write(uc, UC_X86_REG_RAX, &CsrGetProcessIdResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuCsrGetProcessId\n";
    #endif

    return;
}


/*
void
__cdecl
A_SHAFinal(
      PSHA_CTX  Context  ,
      PULONG    Result   );

*/
void EmuApi::EmuA_SHAFinal(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PA_SHA_CTX Context{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Context);

    A_SHA_CTX stContext{};

    if(Context != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Context, &stContext, sizeof(stContext));
    }

    PUCHAR Result{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Result);

    PUCHAR rlResult{};

    if(Result != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }


    A_SHAFinal((PA_SHA_CTX)&stContext,(PUCHAR)&rlResult);


    uc_reg_write(uc, UC_X86_REG_RCX, &Context);

    if(Context != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Context, &stContext, sizeof(stContext));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Result);

    if(Result != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Result, &rlResult, sizeof(rlResult));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuA_SHAFinal\n";
    #endif

    return;
}


/*
PVOID
__cdecl
A_SHAUpdate(
             PSHA_CTX  namelessArg_0  ,
             PCHAR     namelessArg_1  ,
    INPCHAR  UINT      namelessArg_2  );

*/
void EmuApi::EmuA_SHAUpdate(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PA_SHA_CTX namelessArg_0{};
    uc_reg_read(uc, UC_X86_REG_RCX, &namelessArg_0);

    A_SHA_CTX stnamelessArg_0{};

    if(namelessArg_0 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)namelessArg_0, &stnamelessArg_0, sizeof(stnamelessArg_0));
    }

    PUCHAR namelessArg_1{};
    uc_reg_read(uc, UC_X86_REG_RDX, &namelessArg_1);

    std::string rlanamelessArg_1;
    if(!EmuReadNullTermString(uc, (DWORD_PTR)namelessArg_1, rlanamelessArg_1)) { printf("Error when read namelessArg_1 in A_SHAUpdate"); _CrtDbgBreak(); }

    UINT namelessArg_2{};
    uc_reg_read(uc, UC_X86_REG_R8D, &namelessArg_2);


    A_SHAUpdate((PA_SHA_CTX)&stnamelessArg_0,(PUCHAR)rlanamelessArg_1.data(),(UINT)namelessArg_2);

    uc_reg_write(uc, UC_X86_REG_RCX, &namelessArg_0);

    if(namelessArg_0 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)namelessArg_0, &stnamelessArg_0, sizeof(stnamelessArg_0));
    }
    if(!EmuWriteNullTermString(uc, (DWORD_PTR)namelessArg_1, rlanamelessArg_1)) { printf("Error when read namelessArg_1 in A_SHAUpdate"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R8D, &namelessArg_2);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuA_SHAUpdate\n";
    #endif

    return;
}


/*
PVOID
__cdecl
A_SHAInit(
      PSHA_CTX  namelessArg_0  ,
      PVOID     namelessArg_1  );

*/
void EmuApi::EmuA_SHAInit(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PA_SHA_CTX namelessArg_0{};
    uc_reg_read(uc, UC_X86_REG_RCX, &namelessArg_0);

    A_SHA_CTX stnamelessArg_0{};

    if(namelessArg_0 != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)namelessArg_0, &stnamelessArg_0, sizeof(stnamelessArg_0));
    }

    A_SHAInit((PA_SHA_CTX)&stnamelessArg_0);


    uc_reg_write(uc, UC_X86_REG_RCX, &namelessArg_0);

    if(namelessArg_0 != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)namelessArg_0, &stnamelessArg_0, sizeof(stnamelessArg_0));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuA_SHAInit\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDosPathNameToNtPathName_U_WithStatus(
    IN   PCWSTR           DosFileName  ,
    OUT  PUNICODE_STRING  NtFileName   ,
    OUT  PWSTR *          FilePart     ,
    ,    PVOID            Reserved     );

*/
void EmuApi::EmuRtlDosPathNameToNtPathName_U_WithStatus(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR DosFileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &DosFileName);

    std::wstring rlwDosFileName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)DosFileName, rlwDosFileName)) { printf("Error when read DosFileName in RtlDosPathNameToNtPathName_U_WithStatus"); _CrtDbgBreak(); }

    PUNICODE_STRING NtFileName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &NtFileName);

    std::wstring rlwNtFileName;

    USHORT rlLengthNtFileName;

    USHORT rlMaxLengthNtFileName;
    uc_mem_read(uc, (DWORD_PTR)NtFileName, &rlLengthNtFileName, sizeof(rlLengthNtFileName));
    uc_mem_read(uc, (DWORD_PTR)NtFileName+16, &rlMaxLengthNtFileName, sizeof(rlMaxLengthNtFileName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)NtFileName+64, rlwNtFileName, true, rlLengthNtFileName)) { printf("Error when read NtFileName in RtlDosPathNameToNtPathName_U_WithStatus"); _CrtDbgBreak(); }

    UNICODE_STRING stNtFileName{};
    stNtFileName.Length = rlLengthNtFileName;
    stNtFileName.MaximumLength = rlMaxLengthNtFileName;
    stNtFileName.Buffer = rlwNtFileName.data();

    PWSTR * FilePart{};
    uc_reg_read(uc, UC_X86_REG_R8, &FilePart);

    PWSTR * dpFilePart{};

    if(FilePart != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)FilePart, &dpFilePart, sizeof(dpFilePart));
    }

    std::wstring rlwFilePart;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)FilePart, rlwFilePart)) { printf("Error when read FilePart in RtlDosPathNameToNtPathName_U_WithStatus"); _CrtDbgBreak(); }

    PRTL_RELATIVE_NAME_U Reserved{};
    uc_reg_read(uc, UC_X86_REG_R9, &Reserved);


    NTSTATUS RtlDosPathNameToNtPathName_U_WithStatusResult = RtlDosPathNameToNtPathName_U_WithStatus((PCWSTR)rlwDosFileName.data(),(PUNICODE_STRING)&stNtFileName,(PWSTR *)rlwFilePart.data(),(PRTL_RELATIVE_NAME_U)&Reserved);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDosPathNameToNtPathName_U_WithStatusResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)DosFileName, rlwDosFileName)) { printf("Error when read DosFileName in RtlDosPathNameToNtPathName_U_WithStatus"); _CrtDbgBreak(); }
    uc_mem_write(uc, (DWORD_PTR)NtFileName, &stNtFileName.Length, sizeof(stNtFileName.Length));
    uc_mem_write(uc, (DWORD_PTR)NtFileName+16, &stNtFileName.MaximumLength, sizeof(stNtFileName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)NtFileName+64, stNtFileName.Buffer, true, stNtFileName.Length)) { printf("Error when read NtFileName in RtlDosPathNameToNtPathName_U_WithStatus"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)FilePart, rlwFilePart)) { printf("Error when read FilePart in RtlDosPathNameToNtPathName_U_WithStatus"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9, &Reserved);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDosPathNameToNtPathName_U_WithStatus\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlAddVectoredExceptionHandler(
    IN  ULONG                        First    ,
    IN  PVECTORED_EXCEPTION_HANDLER  Handler  );

*/
void EmuApi::EmuRtlAddVectoredExceptionHandler(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG First{};
    uc_reg_read(uc, UC_X86_REG_ECX, &First);

    PVECTORED_EXCEPTION_HANDLER Handler{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handler);


    PVOID RtlAddVectoredExceptionHandlerResult = RtlAddVectoredExceptionHandler((ULONG)First,(PVECTORED_EXCEPTION_HANDLER)Handler);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlAddVectoredExceptionHandlerResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &First);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handler);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddVectoredExceptionHandler\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlAddVectoredContinueHandler(
    IN  ULONG                        First    ,
    IN  PVECTORED_EXCEPTION_HANDLER  Handler  );

*/
void EmuApi::EmuRtlAddVectoredContinueHandler(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG First{};
    uc_reg_read(uc, UC_X86_REG_ECX, &First);

    PVECTORED_EXCEPTION_HANDLER Handler{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handler);


    PVOID RtlAddVectoredContinueHandlerResult = RtlAddVectoredContinueHandler((ULONG)First,(PVECTORED_EXCEPTION_HANDLER)Handler);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlAddVectoredContinueHandlerResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &First);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handler);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlAddVectoredContinueHandler\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlEncodePointer(
      PVOID  Ptr  );

*/
void EmuApi::EmuRtlEncodePointer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Ptr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ptr);


    PVOID RtlEncodePointerResult = RtlEncodePointer((PVOID)&Ptr);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEncodePointerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ptr);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEncodePointer\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlDecodePointer(
      PVOID  Ptr  );

*/
void EmuApi::EmuRtlDecodePointer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Ptr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ptr);


    PVOID RtlDecodePointerResult = RtlDecodePointer((PVOID)&Ptr);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlDecodePointerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ptr);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDecodePointer\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlEncodeSystemPointer(
      PVOID  Ptr  );

*/
void EmuApi::EmuRtlEncodeSystemPointer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Ptr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ptr);


    PVOID RtlEncodeSystemPointerResult = RtlEncodeSystemPointer((PVOID)&Ptr);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlEncodeSystemPointerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ptr);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlEncodeSystemPointer\n";
    #endif

    return;
}


/*
PVOID
__cdecl
RtlDecodeSystemPointer(
      PVOID  Ptr  );

*/
void EmuApi::EmuRtlDecodeSystemPointer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Ptr{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Ptr);


    PVOID RtlDecodeSystemPointerResult = RtlDecodeSystemPointer((PVOID)&Ptr);


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlDecodeSystemPointerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Ptr);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDecodeSystemPointer\n";
    #endif

    return;
}


/*
void
__cdecl
RtlDeleteResource(
      PRTL_RESOURCE  Resource  );

*/
void EmuApi::EmuRtlDeleteResource(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_RESOURCE Resource{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Resource);

    RTL_RESOURCE stResource{};

    if(Resource != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Resource, &stResource, sizeof(stResource));
    }


    RtlDeleteResource((PRTL_RESOURCE)&stResource);


    uc_reg_write(uc, UC_X86_REG_RCX, &Resource);

    if(Resource != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Resource, &stResource, sizeof(stResource));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteResource\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteSecurityObject(
      PSECURITY_DESCRIPTOR *  ObjectDescriptor  );

*/
void EmuApi::EmuRtlDeleteSecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR * ObjectDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectDescriptor);

    PSECURITY_DESCRIPTOR * dpObjectDescriptor{};

    if(ObjectDescriptor != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectDescriptor, &dpObjectDescriptor, sizeof(dpObjectDescriptor));
    }


    NTSTATUS RtlDeleteSecurityObjectResult = RtlDeleteSecurityObject((PSECURITY_DESCRIPTOR *)&dpObjectDescriptor);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteSecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectDescriptor);

    if(ObjectDescriptor != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectDescriptor, &dpObjectDescriptor, sizeof(dpObjectDescriptor));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteSecurityObject\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlDllShutdownInProgress(VOID);

*/
void EmuApi::EmuRtlDllShutdownInProgress(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    BOOLEAN RtlDllShutdownInProgressResult = RtlDllShutdownInProgress();


    uc_reg_write(uc, UC_X86_REG_AL, &RtlDllShutdownInProgressResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDllShutdownInProgress\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlGetCurrentProcessorNumber(VOID);

*/
void EmuApi::EmuRtlGetCurrentProcessorNumber(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    ULONG RtlGetCurrentProcessorNumberResult = RtlGetCurrentProcessorNumber();


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetCurrentProcessorNumberResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCurrentProcessorNumber\n";
    #endif

    return;
}


/*
PRTL_UNLOAD_EVENT_TRACE
__cdecl
RtlGetUnloadEventTrace(VOID);

*/
void EmuApi::EmuRtlGetUnloadEventTrace(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    PRTL_UNLOAD_EVENT_TRACE RtlGetUnloadEventTraceResult = RtlGetUnloadEventTrace();


    uc_reg_write(uc, UC_X86_REG_RAX, &RtlGetUnloadEventTraceResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetUnloadEventTrace\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlIsThreadWithinLoaderCallout(VOID);

*/
void EmuApi::EmuRtlIsThreadWithinLoaderCallout(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    BOOLEAN RtlIsThreadWithinLoaderCalloutResult = RtlIsThreadWithinLoaderCallout();


    uc_reg_write(uc, UC_X86_REG_AL, &RtlIsThreadWithinLoaderCalloutResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlIsThreadWithinLoaderCallout\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlNewSecurityObjectEx(
    IN    PSECURITY_DESCRIPTOR    ParentDescriptor   ,
    ,IN   PSECURITY_DESCRIPTOR    CreatorDescriptor  ,
    ,OUT  PSECURITY_DESCRIPTOR *  NewDescriptor      ,
    IN    GUID *                  ObjectType         ,
    ,IN   BOOLEAN                 IsDirectoryObject  ,
    IN    ULONG                   AutoInheritFlags   ,
    IN    HANDLE                  Token              ,
    IN    PGENERIC_MAPPING        GenericMapping     );

*/
void EmuApi::EmuRtlNewSecurityObjectEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR ParentDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ParentDescriptor);

    PSECURITY_DESCRIPTOR CreatorDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CreatorDescriptor);

    PSECURITY_DESCRIPTOR * NewDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &NewDescriptor);

    PSECURITY_DESCRIPTOR * dpNewDescriptor{};

    if(NewDescriptor != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewDescriptor, &dpNewDescriptor, sizeof(dpNewDescriptor));
    }

    GUID * ObjectType{};
    uc_reg_read(uc, UC_X86_REG_R9, &ObjectType);

    GUID stObjectType{};

    if(ObjectType != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectType, &stObjectType, sizeof(stObjectType));
    }

    BOOLEAN IsDirectoryObject{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &IsDirectoryObject, sizeof(IsDirectoryObject));

    ULONG AutoInheritFlags{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &AutoInheritFlags, sizeof(AutoInheritFlags));

    HANDLE Token{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Token, sizeof(Token));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }


    NTSTATUS RtlNewSecurityObjectExResult = RtlNewSecurityObjectEx((PSECURITY_DESCRIPTOR)&ParentDescriptor,(PSECURITY_DESCRIPTOR)&CreatorDescriptor,(PSECURITY_DESCRIPTOR *)&dpNewDescriptor,(GUID *)&stObjectType,(BOOLEAN)IsDirectoryObject,(ULONG)AutoInheritFlags,(HANDLE)Token,(PGENERIC_MAPPING)&rlGenericMapping);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNewSecurityObjectExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ParentDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &CreatorDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &NewDescriptor);

    if(NewDescriptor != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewDescriptor, &dpNewDescriptor, sizeof(dpNewDescriptor));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &ObjectType);

    if(ObjectType != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectType, &stObjectType, sizeof(stObjectType));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &IsDirectoryObject, sizeof(IsDirectoryObject));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &AutoInheritFlags, sizeof(AutoInheritFlags));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Token, sizeof(Token));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNewSecurityObjectEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlNewSecurityObjectWithMultipleInheritance(
    IN    PSECURITY_DESCRIPTOR    ParentDescriptor   ,
    ,IN   PSECURITY_DESCRIPTOR    CreatorDescriptor  ,
    ,OUT  PSECURITY_DESCRIPTOR *  NewDescriptor      ,
    IN    GUID **                 pObjectType        ,
    ,IN   ULONG                   GuidCount          ,
    IN    BOOLEAN                 IsDirectoryObject  ,
    IN    ULONG                   AutoInheritFlags   ,
    IN    HANDLE                  Token              ,
    IN    PGENERIC_MAPPING        GenericMapping     );

*/
void EmuApi::EmuRtlNewSecurityObjectWithMultipleInheritance(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR ParentDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ParentDescriptor);

    PSECURITY_DESCRIPTOR CreatorDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CreatorDescriptor);

    PSECURITY_DESCRIPTOR * NewDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &NewDescriptor);

    PSECURITY_DESCRIPTOR * dpNewDescriptor{};

    if(NewDescriptor != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)NewDescriptor, &dpNewDescriptor, sizeof(dpNewDescriptor));
    }

    GUID * pObjectType{};
    uc_reg_read(uc, UC_X86_REG_R9, &pObjectType);

    GUID * dppObjectType{};

    if(pObjectType != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)pObjectType, &dppObjectType, sizeof(dppObjectType));
    }

    GUID stpObjectType{};

    if(dppObjectType != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)dppObjectType, &stpObjectType, sizeof(stpObjectType));
    }

    ULONG GuidCount{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &GuidCount, sizeof(GuidCount));

    BOOLEAN IsDirectoryObject{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &IsDirectoryObject, sizeof(IsDirectoryObject));

    ULONG AutoInheritFlags{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &AutoInheritFlags, sizeof(AutoInheritFlags));

    HANDLE Token{};
    uc_mem_read(uc, (DWORD_PTR)SP+64, &Token, sizeof(Token));

    PGENERIC_MAPPING GenericMapping{};
    uc_mem_read(uc, (DWORD_PTR)SP+72, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }


    NTSTATUS RtlNewSecurityObjectWithMultipleInheritanceResult = RtlNewSecurityObjectWithMultipleInheritance((PSECURITY_DESCRIPTOR)&ParentDescriptor,(PSECURITY_DESCRIPTOR)&CreatorDescriptor,(PSECURITY_DESCRIPTOR *)&dpNewDescriptor,(GUID **)&stpObjectType,(ULONG)GuidCount,(BOOLEAN)IsDirectoryObject,(ULONG)AutoInheritFlags,(HANDLE)Token,(PGENERIC_MAPPING)&rlGenericMapping);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlNewSecurityObjectWithMultipleInheritanceResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ParentDescriptor);
    uc_reg_write(uc, UC_X86_REG_RDX, &CreatorDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &NewDescriptor);

    if(NewDescriptor != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)NewDescriptor, &dpNewDescriptor, sizeof(dpNewDescriptor));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &pObjectType);

    if(pObjectType != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)pObjectType, &dppObjectType, sizeof(dppObjectType));
    }

    if(dppObjectType != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)dppObjectType, &stpObjectType, sizeof(stpObjectType));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &GuidCount, sizeof(GuidCount));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &IsDirectoryObject, sizeof(IsDirectoryObject));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &AutoInheritFlags, sizeof(AutoInheritFlags));
    uc_mem_write(uc, (DWORD_PTR)SP+64, &Token, sizeof(Token));
    uc_mem_write(uc, (DWORD_PTR)SP+72, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlNewSecurityObjectWithMultipleInheritance\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQuerySecurityObject(
      PSECURITY_DESCRIPTOR  ObjectDescriptor     ,
      SECURITY_INFORMATION  SecurityInformation  ,
      PSECURITY_DESCRIPTOR  ResultantDescriptor  ,
      ULONG                 DescriptorLength     ,
      PULONG                ReturnLength         );

*/
void EmuApi::EmuRtlQuerySecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PSECURITY_DESCRIPTOR ObjectDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RCX, &ObjectDescriptor);

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_EDX, &SecurityInformation);

    PSECURITY_DESCRIPTOR ResultantDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &ResultantDescriptor);

    ULONG DescriptorLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &DescriptorLength);

    PULONG ReturnLength{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    ULONG rlReturnLength{};

    if(ReturnLength != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }


    NTSTATUS RtlQuerySecurityObjectResult = RtlQuerySecurityObject((PSECURITY_DESCRIPTOR)&ObjectDescriptor,(SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&ResultantDescriptor,(ULONG)DescriptorLength,(PULONG)&rlReturnLength);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlQuerySecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &ObjectDescriptor);
    uc_reg_write(uc, UC_X86_REG_EDX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_R8, &ResultantDescriptor);
    uc_reg_write(uc, UC_X86_REG_R9D, &DescriptorLength);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ReturnLength, sizeof(ReturnLength));

    if(ReturnLength != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ReturnLength, &rlReturnLength, sizeof(rlReturnLength));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQuerySecurityObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlRegisterWait(
    OUT  PHANDLE                  WaitHandle    ,
    IN   HANDLE                   Handle        ,
    IN   WAITORTIMERCALLBACKFUNC  Function      ,
    IN   PVOID                    Context       ,
    IN   ULONG                    Milliseconds  ,
    IN   ULONG                    Flags         );

*/
void EmuApi::EmuRtlRegisterWait(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE WaitHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &WaitHandle);

    HANDLE dpWaitHandle{};

    if(WaitHandle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)WaitHandle, &dpWaitHandle, sizeof(dpWaitHandle));
    }

    HANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handle);

    WAITORTIMERCALLBACKFUNC Function{};
    uc_reg_read(uc, UC_X86_REG_R8, &Function);

    PVOID Context{};
    uc_reg_read(uc, UC_X86_REG_R9, &Context);

    ULONG Milliseconds{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Milliseconds, sizeof(Milliseconds));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Flags, sizeof(Flags));


    NTSTATUS RtlRegisterWaitResult = RtlRegisterWait((PHANDLE)dpWaitHandle,(HANDLE)Handle,(WAITORTIMERCALLBACKFUNC)Function,(PVOID)&Context,(ULONG)Milliseconds,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlRegisterWaitResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &WaitHandle);

    if(WaitHandle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)WaitHandle, &dpWaitHandle, sizeof(dpWaitHandle));
    }
    uc_reg_write(uc, UC_X86_REG_RDX, &Handle);
    uc_reg_write(uc, UC_X86_REG_R8, &Function);
    uc_reg_write(uc, UC_X86_REG_R9, &Context);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Milliseconds, sizeof(Milliseconds));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Flags, sizeof(Flags));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRegisterWait\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlRemoveVectoredContinueHandler(
    IN  PVOID  Handle  );

*/
void EmuApi::EmuRtlRemoveVectoredContinueHandler(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    ULONG RtlRemoveVectoredContinueHandlerResult = RtlRemoveVectoredContinueHandler((PVOID)&Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlRemoveVectoredContinueHandlerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRemoveVectoredContinueHandler\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlRemoveVectoredExceptionHandler(
    IN  PVOID  Handle  );

*/
void EmuApi::EmuRtlRemoveVectoredExceptionHandler(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Handle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Handle);


    ULONG RtlRemoveVectoredExceptionHandlerResult = RtlRemoveVectoredExceptionHandler((PVOID)&Handle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlRemoveVectoredExceptionHandlerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Handle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlRemoveVectoredExceptionHandler\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetIoCompletionCallback(
    IN  HANDLE                 FileHandle      ,
    IN  APC_CALLBACK_FUNCTION  CompletionProc  ,
    IN  ULONG                  Flags           );

*/
void EmuApi::EmuRtlSetIoCompletionCallback(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE FileHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileHandle);

    APC_CALLBACK_FUNCTION CompletionProc{};
    uc_reg_read(uc, UC_X86_REG_RDX, &CompletionProc);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_R8D, &Flags);


    NTSTATUS RtlSetIoCompletionCallbackResult = RtlSetIoCompletionCallback((HANDLE)FileHandle,(APC_CALLBACK_FUNCTION)CompletionProc,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetIoCompletionCallbackResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &FileHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &CompletionProc);
    uc_reg_write(uc, UC_X86_REG_R8D, &Flags);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetIoCompletionCallback\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetSecurityObject(
      SECURITY_INFORMATION    SecurityInformation        ,
      PSECURITY_DESCRIPTOR    ModificationDescriptor     ,
      PSECURITY_DESCRIPTOR *  ObjectsSecurityDescriptor  ,
      PGENERIC_MAPPING        GenericMapping             ,
      HANDLE                  Token                      );

*/
void EmuApi::EmuRtlSetSecurityObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SecurityInformation);

    PSECURITY_DESCRIPTOR ModificationDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ModificationDescriptor);

    PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectsSecurityDescriptor);

    PSECURITY_DESCRIPTOR * dpObjectsSecurityDescriptor{};

    if(ObjectsSecurityDescriptor != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectsSecurityDescriptor, &dpObjectsSecurityDescriptor, sizeof(dpObjectsSecurityDescriptor));
    }

    PGENERIC_MAPPING GenericMapping{};
    uc_reg_read(uc, UC_X86_REG_R9, &GenericMapping);

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    HANDLE Token{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &Token, sizeof(Token));


    NTSTATUS RtlSetSecurityObjectResult = RtlSetSecurityObject((SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&ModificationDescriptor,(PSECURITY_DESCRIPTOR *)&dpObjectsSecurityDescriptor,(PGENERIC_MAPPING)&rlGenericMapping,(HANDLE)Token);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetSecurityObjectResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_RDX, &ModificationDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectsSecurityDescriptor);

    if(ObjectsSecurityDescriptor != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectsSecurityDescriptor, &dpObjectsSecurityDescriptor, sizeof(dpObjectsSecurityDescriptor));
    }
    uc_reg_write(uc, UC_X86_REG_R9, &GenericMapping);

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+40, &Token, sizeof(Token));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetSecurityObject\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetSecurityObjectEx(
    IN     SECURITY_INFORMATION    SecurityInformation        ,
    IN     PSECURITY_DESCRIPTOR    ModificationDescriptor     ,
    INOUT  PSECURITY_DESCRIPTOR *  ObjectsSecurityDescriptor  ,
    IN     ULONG                   AutoInheritFlags           ,
    IN     PGENERIC_MAPPING        GenericMapping             ,
    IN     HANDLE                  Token                      );

*/
void EmuApi::EmuRtlSetSecurityObjectEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    SECURITY_INFORMATION SecurityInformation{};
    uc_reg_read(uc, UC_X86_REG_ECX, &SecurityInformation);

    PSECURITY_DESCRIPTOR ModificationDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ModificationDescriptor);

    PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &ObjectsSecurityDescriptor);

    PSECURITY_DESCRIPTOR * dpObjectsSecurityDescriptor{};

    if(ObjectsSecurityDescriptor != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ObjectsSecurityDescriptor, &dpObjectsSecurityDescriptor, sizeof(dpObjectsSecurityDescriptor));
    }

    ULONG AutoInheritFlags{};
    uc_reg_read(uc, UC_X86_REG_R9D, &AutoInheritFlags);

    PGENERIC_MAPPING GenericMapping{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &GenericMapping, sizeof(GenericMapping));

    GENERIC_MAPPING rlGenericMapping{};

    if(GenericMapping != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }

    HANDLE Token{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Token, sizeof(Token));


    NTSTATUS RtlSetSecurityObjectExResult = RtlSetSecurityObjectEx((SECURITY_INFORMATION)SecurityInformation,(PSECURITY_DESCRIPTOR)&ModificationDescriptor,(PSECURITY_DESCRIPTOR *)&dpObjectsSecurityDescriptor,(ULONG)AutoInheritFlags,(PGENERIC_MAPPING)&rlGenericMapping,(HANDLE)Token);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetSecurityObjectExResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &SecurityInformation);
    uc_reg_write(uc, UC_X86_REG_RDX, &ModificationDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &ObjectsSecurityDescriptor);

    if(ObjectsSecurityDescriptor != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ObjectsSecurityDescriptor, &dpObjectsSecurityDescriptor, sizeof(dpObjectsSecurityDescriptor));
    }
    uc_reg_write(uc, UC_X86_REG_R9D, &AutoInheritFlags);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &GenericMapping, sizeof(GenericMapping));

    if(GenericMapping != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)GenericMapping, &rlGenericMapping, sizeof(rlGenericMapping));
    }
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Token, sizeof(Token));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetSecurityObjectEx\n";
    #endif

    return;
}


/*
void
__cdecl
RtlSetUnhandledExceptionFilter(
      PRTLP_UNHANDLED_EXCEPTION_FILTER  UnhandledExceptionFilter  );

*/
void EmuApi::EmuRtlSetUnhandledExceptionFilter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTLP_UNHANDLED_EXCEPTION_FILTER UnhandledExceptionFilter{};
    uc_reg_read(uc, UC_X86_REG_RCX, &UnhandledExceptionFilter);


    RtlSetUnhandledExceptionFilter((PRTLP_UNHANDLED_EXCEPTION_FILTER)&UnhandledExceptionFilter);


    uc_reg_write(uc, UC_X86_REG_RCX, &UnhandledExceptionFilter);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetUnhandledExceptionFilter\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlWow64EnableFsRedirection(
    IN  BOOLEAN  Wow64FsEnableRedirection  );

*/
void EmuApi::EmuRtlWow64EnableFsRedirection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    BOOLEAN Wow64FsEnableRedirection{};
    uc_reg_read(uc, UC_X86_REG_CL, &Wow64FsEnableRedirection);


    NTSTATUS RtlWow64EnableFsRedirectionResult = RtlWow64EnableFsRedirection((BOOLEAN)Wow64FsEnableRedirection);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlWow64EnableFsRedirectionResult);
    uc_reg_write(uc, UC_X86_REG_CL, &Wow64FsEnableRedirection);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlWow64EnableFsRedirection\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlWow64EnableFsRedirectionEx(
    IN   PVOID    Wow64FsEnableRedirection  ,
    OUT  PVOID *  OldFsRedirectionLevel     );

*/
void EmuApi::EmuRtlWow64EnableFsRedirectionEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PVOID Wow64FsEnableRedirection{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Wow64FsEnableRedirection);

    PVOID * OldFsRedirectionLevel{};
    uc_reg_read(uc, UC_X86_REG_RDX, &OldFsRedirectionLevel);

    PVOID * dpOldFsRedirectionLevel{};

    if(OldFsRedirectionLevel != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)OldFsRedirectionLevel, &dpOldFsRedirectionLevel, sizeof(dpOldFsRedirectionLevel));
    }


    NTSTATUS RtlWow64EnableFsRedirectionExResult = RtlWow64EnableFsRedirectionEx((PVOID)&Wow64FsEnableRedirection,(PVOID *)&dpOldFsRedirectionLevel);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlWow64EnableFsRedirectionExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Wow64FsEnableRedirection);
    uc_reg_write(uc, UC_X86_REG_RDX, &OldFsRedirectionLevel);

    if(OldFsRedirectionLevel != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)OldFsRedirectionLevel, &dpOldFsRedirectionLevel, sizeof(dpOldFsRedirectionLevel));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlWow64EnableFsRedirectionEx\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeregisterWait(
    IN  HANDLE  WaitHandle  );

*/
void EmuApi::EmuRtlDeregisterWait(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE WaitHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &WaitHandle);


    NTSTATUS RtlDeregisterWaitResult = RtlDeregisterWait((HANDLE)WaitHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeregisterWaitResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &WaitHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeregisterWait\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeregisterWaitEx(
    IN  HANDLE  WaitHandle  ,
    IN  HANDLE  Event       );

*/
void EmuApi::EmuRtlDeregisterWaitEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE WaitHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &WaitHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);


    NTSTATUS RtlDeregisterWaitExResult = RtlDeregisterWaitEx((HANDLE)WaitHandle,(HANDLE)Event);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeregisterWaitExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &WaitHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeregisterWaitEx\n";
    #endif

    return;
}

/*
NTSTATUS
__cdecl
RtlCloneUserProcess(
    IN          ULONG                          ProcessFlags               ,
    INOPTIONAL  PSECURITY_DESCRIPTOR           ProcessSecurityDescriptor  ,
    INOPTIONAL  PSECURITY_DESCRIPTOR           ThreadSecurityDescriptor   ,
    INOPTIONAL  HANDLE                         DebugPort                  ,
    OUT         PRTL_USER_PROCESS_INFORMATION  ProcessInformation         );

*/
void EmuApi::EmuRtlCloneUserProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG ProcessFlags{};
    uc_reg_read(uc, UC_X86_REG_ECX, &ProcessFlags);

    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_RDX, &ProcessSecurityDescriptor);

    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor{};
    uc_reg_read(uc, UC_X86_REG_R8, &ThreadSecurityDescriptor);

    HANDLE DebugPort{};
    uc_reg_read(uc, UC_X86_REG_R9, &DebugPort);

    PRTL_USER_PROCESS_INFORMATION ProcessInformation{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &ProcessInformation, sizeof(ProcessInformation));

    RTL_USER_PROCESS_INFORMATION stProcessInformation{};

    if(ProcessInformation != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)ProcessInformation, &stProcessInformation, sizeof(stProcessInformation));
    }


    NTSTATUS RtlCloneUserProcessResult = RtlCloneUserProcess((ULONG)ProcessFlags,(PSECURITY_DESCRIPTOR)&ProcessSecurityDescriptor,(PSECURITY_DESCRIPTOR)&ThreadSecurityDescriptor,(HANDLE)DebugPort,(PRTL_USER_PROCESS_INFORMATION)&stProcessInformation);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCloneUserProcessResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &ProcessFlags);
    uc_reg_write(uc, UC_X86_REG_RDX, &ProcessSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R8, &ThreadSecurityDescriptor);
    uc_reg_write(uc, UC_X86_REG_R9, &DebugPort);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &ProcessInformation, sizeof(ProcessInformation));

    if(ProcessInformation != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &stProcessInformation, sizeof(stProcessInformation));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCloneUserProcess\n";
    #endif

    return;
}


/*
void
__cdecl
LdrShutdownProcess(VOID);

*/
void EmuApi::EmuLdrShutdownProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    LdrShutdownProcess();


    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuLdrShutdownProcess\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryProcessModuleInformation(
    IN     HANDLE                  hProcess  ,
    ,IN    ULONG                   Flags     ,
    INOUT  PRTL_DEBUG_INFORMATION  Buffer    );

*/
void EmuApi::EmuRtlQueryProcessModuleInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE hProcess{};
    uc_reg_read(uc, UC_X86_REG_RCX, &hProcess);

    ULONG Flags{};
    uc_reg_read(uc, UC_X86_REG_EDX, &Flags);

    PRTL_DEBUG_INFORMATION Buffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &Buffer);

    RTL_DEBUG_INFORMATION stBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }


    //NTSTATUS RtlQueryProcessModuleInformationResult = RtlQueryProcessModuleInformation((HANDLE)hProcess,(ULONG)Flags,(PRTL_DEBUG_INFORMATION)&stBuffer);


    //uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryProcessModuleInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &hProcess);
    uc_reg_write(uc, UC_X86_REG_EDX, &Flags);
    uc_reg_write(uc, UC_X86_REG_R8, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryProcessModuleInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryProcessBackTraceInformation(
    INOUT  PRTL_DEBUG_INFORMATION  Buffer  );

*/
void EmuApi::EmuRtlQueryProcessBackTraceInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_DEBUG_INFORMATION Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    RTL_DEBUG_INFORMATION stBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }


    //NTSTATUS RtlQueryProcessBackTraceInformationResult = RtlQueryProcessBackTraceInformation((PRTL_DEBUG_INFORMATION)&stBuffer);


   // uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryProcessBackTraceInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryProcessBackTraceInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryProcessHeapInformation(
    INOUT  PRTL_DEBUG_INFORMATION  Buffer  );

*/
void EmuApi::EmuRtlQueryProcessHeapInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_DEBUG_INFORMATION Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    RTL_DEBUG_INFORMATION stBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }


    //NTSTATUS RtlQueryProcessHeapInformationResult = RtlQueryProcessHeapInformation((PRTL_DEBUG_INFORMATION)&stBuffer);


    //uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryProcessHeapInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryProcessHeapInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlQueryProcessLockInformation(
    INOUT  PRTL_DEBUG_INFORMATION  Buffer  );

*/
void EmuApi::EmuRtlQueryProcessLockInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PRTL_DEBUG_INFORMATION Buffer{};
    uc_reg_read(uc, UC_X86_REG_RCX, &Buffer);

    RTL_DEBUG_INFORMATION stBuffer{};

    if(Buffer != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }


    //NTSTATUS RtlQueryProcessLockInformationResult = RtlQueryProcessLockInformation((PRTL_DEBUG_INFORMATION)&stBuffer);


    //uc_reg_write(uc, UC_X86_REG_EAX, &RtlQueryProcessLockInformationResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &Buffer);

    if(Buffer != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Buffer, &stBuffer, sizeof(stBuffer));
    }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlQueryProcessLockInformation\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlCreateTimer(
    IN   HANDLE                   TimerQueueHandle  ,
    OUT  HANDLE *                 Handle            ,
    IN   WAITORTIMERCALLBACKFUNC  Function          ,
    IN   PVOID                    Context           ,
    IN   ULONG                    DueTime           ,
    IN   ULONG                    Period            ,
    IN   ULONG                    Flags             );

*/
void EmuApi::EmuRtlCreateTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerQueueHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerQueueHandle);

    PHANDLE Handle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Handle);

    HANDLE rlHandle{};

    if(Handle != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)Handle, &rlHandle, sizeof(rlHandle));
    }

    WAITORTIMERCALLBACKFUNC Function{};
    uc_reg_read(uc, UC_X86_REG_R8, &Function);

    PVOID Context{};
    uc_reg_read(uc, UC_X86_REG_R9, &Context);

    ULONG DueTime{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &DueTime, sizeof(DueTime));

    ULONG Period{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &Period, sizeof(Period));

    ULONG Flags{};
    uc_mem_read(uc, (DWORD_PTR)SP+56, &Flags, sizeof(Flags));


    NTSTATUS RtlCreateTimerResult = RtlCreateTimer((HANDLE)TimerQueueHandle,(HANDLE *)rlHandle,(WAITORTIMERCALLBACKFUNC)Function,(PVOID)&Context,(ULONG)DueTime,(ULONG)Period,(ULONG)Flags);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlCreateTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerQueueHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Handle);

    if(Handle != nullptr)
    {
        uc_mem_write(uc, (DWORD_PTR)Handle, &rlHandle, sizeof(rlHandle));
    }
    uc_reg_write(uc, UC_X86_REG_R8, &Function);
    uc_reg_write(uc, UC_X86_REG_R9, &Context);
    uc_mem_write(uc, (DWORD_PTR)SP+40, &DueTime, sizeof(DueTime));
    uc_mem_write(uc, (DWORD_PTR)SP+48, &Period, sizeof(Period));
    uc_mem_write(uc, (DWORD_PTR)SP+56, &Flags, sizeof(Flags));
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlCreateTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlUpdateTimer(
    IN  HANDLE  TimerQueueHandle  ,
    IN  HANDLE  TimerHandle       ,
    IN  ULONG   DueTime           ,
    IN  ULONG   Period            );

*/
void EmuApi::EmuRtlUpdateTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerQueueHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerQueueHandle);

    HANDLE TimerHandle{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TimerHandle);

    ULONG DueTime{};
    uc_reg_read(uc, UC_X86_REG_R8D, &DueTime);

    ULONG Period{};
    uc_reg_read(uc, UC_X86_REG_R9D, &Period);


    NTSTATUS RtlUpdateTimerResult = RtlUpdateTimer((HANDLE)TimerQueueHandle,(HANDLE)TimerHandle,(ULONG)DueTime,(ULONG)Period);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlUpdateTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerQueueHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &TimerHandle);
    uc_reg_write(uc, UC_X86_REG_R8D, &DueTime);
    uc_reg_write(uc, UC_X86_REG_R9D, &Period);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlUpdateTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteTimer(
    IN  HANDLE  TimerQueueHandle  ,
    IN  HANDLE  TimerToCancel     ,
    IN  HANDLE  Event             );

*/
void EmuApi::EmuRtlDeleteTimer(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerQueueHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerQueueHandle);

    HANDLE TimerToCancel{};
    uc_reg_read(uc, UC_X86_REG_RDX, &TimerToCancel);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_R8, &Event);


    NTSTATUS RtlDeleteTimerResult = RtlDeleteTimer((HANDLE)TimerQueueHandle,(HANDLE)TimerToCancel,(HANDLE)Event);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteTimerResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerQueueHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &TimerToCancel);
    uc_reg_write(uc, UC_X86_REG_R8, &Event);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteTimer\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteTimerQueue(
    IN  HANDLE  TimerQueueHandle  );

*/
void EmuApi::EmuRtlDeleteTimerQueue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerQueueHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerQueueHandle);


    NTSTATUS RtlDeleteTimerQueueResult = RtlDeleteTimerQueue((HANDLE)TimerQueueHandle);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteTimerQueueResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerQueueHandle);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteTimerQueue\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlDeleteTimerQueueEx(
    IN  HANDLE  TimerQueueHandle  ,
    IN  HANDLE  Event             );

*/
void EmuApi::EmuRtlDeleteTimerQueueEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    HANDLE TimerQueueHandle{};
    uc_reg_read(uc, UC_X86_REG_RCX, &TimerQueueHandle);

    HANDLE Event{};
    uc_reg_read(uc, UC_X86_REG_RDX, &Event);


    NTSTATUS RtlDeleteTimerQueueExResult = RtlDeleteTimerQueueEx((HANDLE)TimerQueueHandle,(HANDLE)Event);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDeleteTimerQueueExResult);
    uc_reg_write(uc, UC_X86_REG_RCX, &TimerQueueHandle);
    uc_reg_write(uc, UC_X86_REG_RDX, &Event);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDeleteTimerQueueEx\n";
    #endif

    return;
}


/*
BOOLEAN
__cdecl
RtlDoesFileExists_U(
      PCWSTR  FileName  );

*/
void EmuApi::EmuRtlDoesFileExists_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR FileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &FileName);

    std::wstring rlwFileName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)FileName, rlwFileName)) { printf("Error when read FileName in RtlDoesFileExists_U"); _CrtDbgBreak(); }


    BOOLEAN RtlDoesFileExists_UResult = RtlDoesFileExists_U((PCWSTR)rlwFileName.data());


    uc_reg_write(uc, UC_X86_REG_AL, &RtlDoesFileExists_UResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)FileName, rlwFileName)) { printf("Error when read FileName in RtlDoesFileExists_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDoesFileExists_U\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlGetCurrentDirectory_U(
      ULONG  nBufferLength  ,
      PWSTR  lpBuffer       );

*/
void EmuApi::EmuRtlGetCurrentDirectory_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    ULONG nBufferLength{};
    uc_reg_read(uc, UC_X86_REG_ECX, &nBufferLength);

    PWSTR lpBuffer{};
    uc_reg_read(uc, UC_X86_REG_RDX, &lpBuffer);

    std::wstring rlwlpBuffer;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpBuffer, rlwlpBuffer)) { printf("Error when read lpBuffer in RtlGetCurrentDirectory_U"); _CrtDbgBreak(); }


    ULONG RtlGetCurrentDirectory_UResult = RtlGetCurrentDirectory_U((ULONG)nBufferLength,(PWSTR)rlwlpBuffer.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetCurrentDirectory_UResult);
    uc_reg_write(uc, UC_X86_REG_ECX, &nBufferLength);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpBuffer, rlwlpBuffer)) { printf("Error when read lpBuffer in RtlGetCurrentDirectory_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetCurrentDirectory_U\n";
    #endif

    return;
}


/*
NTSTATUS
__cdecl
RtlSetCurrentDirectory_U(
      PUNICODE_STRING  PathName  );

*/
void EmuApi::EmuRtlSetCurrentDirectory_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PUNICODE_STRING PathName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &PathName);

    std::wstring rlwPathName;

    USHORT rlLengthPathName;

    USHORT rlMaxLengthPathName;
    uc_mem_read(uc, (DWORD_PTR)PathName, &rlLengthPathName, sizeof(rlLengthPathName));
    uc_mem_read(uc, (DWORD_PTR)PathName+16, &rlMaxLengthPathName, sizeof(rlMaxLengthPathName));
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)PathName+64, rlwPathName, true, rlLengthPathName)) { printf("Error when read PathName in RtlSetCurrentDirectory_U"); _CrtDbgBreak(); }

    UNICODE_STRING stPathName{};
    stPathName.Length = rlLengthPathName;
    stPathName.MaximumLength = rlMaxLengthPathName;
    stPathName.Buffer = rlwPathName.data();


    NTSTATUS RtlSetCurrentDirectory_UResult = RtlSetCurrentDirectory_U((PUNICODE_STRING)&stPathName);


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlSetCurrentDirectory_UResult);
    uc_mem_write(uc, (DWORD_PTR)PathName, &stPathName.Length, sizeof(stPathName.Length));
    uc_mem_write(uc, (DWORD_PTR)PathName+16, &stPathName.MaximumLength, sizeof(stPathName.MaximumLength));
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)PathName+64, stPathName.Buffer, true, stPathName.Length)) { printf("Error when read PathName in RtlSetCurrentDirectory_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlSetCurrentDirectory_U\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlDosSearchPath_U(
    IN   PWSTR    lpPath         ,
    IN   PWSTR    lpFileName     ,
    IN   PWSTR    lpExtension    ,
    ,IN  ULONG    nBufferLength  ,
    OUT  PWSTR    lpBuffer       ,
    OUT  PWSTR *  lpFilePart     );

*/
void EmuApi::EmuRtlDosSearchPath_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR lpPath{};
    uc_reg_read(uc, UC_X86_REG_RCX, &lpPath);

    std::wstring rlwlpPath;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpPath, rlwlpPath)) { printf("Error when read lpPath in RtlDosSearchPath_U"); _CrtDbgBreak(); }

    PWSTR lpFileName{};
    uc_reg_read(uc, UC_X86_REG_RDX, &lpFileName);

    std::wstring rlwlpFileName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpFileName, rlwlpFileName)) { printf("Error when read lpFileName in RtlDosSearchPath_U"); _CrtDbgBreak(); }

    PWSTR lpExtension{};
    uc_reg_read(uc, UC_X86_REG_R8, &lpExtension);

    std::wstring rlwlpExtension;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpExtension, rlwlpExtension)) { printf("Error when read lpExtension in RtlDosSearchPath_U"); _CrtDbgBreak(); }

    ULONG nBufferLength{};
    uc_reg_read(uc, UC_X86_REG_R9D, &nBufferLength);

    PWSTR lpBuffer{};

    DWORD_PTR SP = 0;
    uc_reg_read(uc, UC_X86_REG_RSP, &SP);
    uc_mem_read(uc, (DWORD_PTR)SP+40, &lpBuffer, sizeof(lpBuffer));

    std::wstring rlwlpBuffer;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpBuffer, rlwlpBuffer)) { printf("Error when read lpBuffer in RtlDosSearchPath_U"); _CrtDbgBreak(); }

    PWSTR * lpFilePart{};
    uc_mem_read(uc, (DWORD_PTR)SP+48, &lpFilePart, sizeof(lpFilePart));

    PWSTR * dplpFilePart{};

    if(lpFilePart != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)lpFilePart, &dplpFilePart, sizeof(dplpFilePart));
    }

    std::wstring rlwlpFilePart;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpFilePart, rlwlpFilePart)) { printf("Error when read lpFilePart in RtlDosSearchPath_U"); _CrtDbgBreak(); }


    ULONG RtlDosSearchPath_UResult = RtlDosSearchPath_U((PWSTR)rlwlpPath.data(),(PWSTR)rlwlpFileName.data(),(PWSTR)rlwlpExtension.data(),(ULONG)nBufferLength,(PWSTR)rlwlpBuffer.data(),(PWSTR *)rlwlpFilePart.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlDosSearchPath_UResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpPath, rlwlpPath)) { printf("Error when read lpPath in RtlDosSearchPath_U"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpFileName, rlwlpFileName)) { printf("Error when read lpFileName in RtlDosSearchPath_U"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpExtension, rlwlpExtension)) { printf("Error when read lpExtension in RtlDosSearchPath_U"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_R9D, &nBufferLength);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpBuffer, rlwlpBuffer)) { printf("Error when read lpBuffer in RtlDosSearchPath_U"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpFilePart, rlwlpFilePart)) { printf("Error when read lpFilePart in RtlDosSearchPath_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlDosSearchPath_U\n";
    #endif

    return;
}


/*
ULONG
__cdecl
RtlGetFullPathName_U(
    IN           PCWSTR   lpFileName     ,
    IN           ULONG    nBufferLength  ,
    OUT          PWSTR    lpBuffer       ,
    OUTOPTIONAL  PWSTR *  lpFilePart     );

*/
void EmuApi::EmuRtlGetFullPathName_U(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{

    PWSTR lpFileName{};
    uc_reg_read(uc, UC_X86_REG_RCX, &lpFileName);

    std::wstring rlwlpFileName;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpFileName, rlwlpFileName)) { printf("Error when read lpFileName in RtlGetFullPathName_U"); _CrtDbgBreak(); }

    ULONG nBufferLength{};
    uc_reg_read(uc, UC_X86_REG_EDX, &nBufferLength);

    PWSTR lpBuffer{};
    uc_reg_read(uc, UC_X86_REG_R8, &lpBuffer);

    std::wstring rlwlpBuffer;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpBuffer, rlwlpBuffer)) { printf("Error when read lpBuffer in RtlGetFullPathName_U"); _CrtDbgBreak(); }

    PWSTR * lpFilePart{};
    uc_reg_read(uc, UC_X86_REG_R9, &lpFilePart);

    PWSTR * dplpFilePart{};

    if(lpFilePart != nullptr)
    {
        uc_mem_read(uc, (DWORD_PTR)lpFilePart, &dplpFilePart, sizeof(dplpFilePart));
    }

    std::wstring rlwlpFilePart;
    if(!EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpFilePart, rlwlpFilePart)) { printf("Error when read lpFilePart in RtlGetFullPathName_U"); _CrtDbgBreak(); }


    ULONG RtlGetFullPathName_UResult = RtlGetFullPathName_U((PCWSTR)rlwlpFileName.data(),(ULONG)nBufferLength,(PWSTR)rlwlpBuffer.data(),(PWSTR *)rlwlpFilePart.data());


    uc_reg_write(uc, UC_X86_REG_EAX, &RtlGetFullPathName_UResult);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpFileName, rlwlpFileName)) { printf("Error when read lpFileName in RtlGetFullPathName_U"); _CrtDbgBreak(); }
    uc_reg_write(uc, UC_X86_REG_EDX, &nBufferLength);
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpBuffer, rlwlpBuffer)) { printf("Error when read lpBuffer in RtlGetFullPathName_U"); _CrtDbgBreak(); }
    if(!EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpFilePart, rlwlpFilePart)) { printf("Error when read lpFilePart in RtlGetFullPathName_U"); _CrtDbgBreak(); }
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuRtlGetFullPathName_U\n";
    #endif

    return;
}


/*
ULONG
__cdecl
EtwRegisterSecurityProvider(VOID);

*/
void EmuApi::EmuEtwRegisterSecurityProvider(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
{


    ULONG EtwRegisterSecurityProviderResult = EtwRegisterSecurityProvider();


    uc_reg_write(uc, UC_X86_REG_EAX, &EtwRegisterSecurityProviderResult);
    #ifdef TRACE_LOG_CONSOLE
    *outs << "EmuEtwRegisterSecurityProvider\n";
    #endif

    return;
}